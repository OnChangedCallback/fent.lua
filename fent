loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))() -- ac bypass dont touch or remove
local game = game
local workspace = workspace
local a = game:GetService("Players")
local b = game:GetService("RunService")
local c = game:GetService("UserInputService")
local d = game:GetService("TweenService")
local e = game:GetService("HttpService")
local f = game:GetService("Lighting")
local g = a.LocalPlayer
local h, i = math.random, math.huge
local _j, k = math.floor, math.ceil
local l, m = math.abs, math.sqrt
local n, o = math.sin, math.cos
local p, q = table.insert, table.remove
local r, s = table.sort, table.concat
local t, u = string.format, string.match
local v, w = string.lower, string.upper
local x, y = string.sub, string.gsub
local pairs, ipairs = pairs, ipairs
local type, tostring = type, tostring
local pcall, xpcall = pcall, xpcall
local loadstring = loadstring
local setmetatable = setmetatable
local getmetatable = getmetatable
local z = Color3.fromRGB
local A = UDim2.new
local B = Vector3.new
local C = CFrame.new
local UDim2 = UDim2
local Color3 = Color3
local isfolder = isfolder
local isfile = isfile
local listfiles = listfiles
local writefile = writefile
local readfile = readfile
local delfile = delfile
local makefolder = makefolder
local setclipboard = setclipboard
local D = game:GetService("TeleportService")
local cam = workspace.CurrentCamera
local Vector2 = Vector2
local Instance = Instance
local ColorSequence = ColorSequence
local NumberSequence = NumberSequence
local Enum = Enum
local hookmetamethod = hookmetamethod or function() end
local checkcaller = checkcaller or function() return true end
local newcclosure = newcclosure or function(f) return f end
local getgenv = getgenv
local task = task
local _wait = wait
local fireclickdetector = fireclickdetector
local E = {}
local F = {}
do
    function E.new_connection(G, H)
        local I = G:Connect(H)
        p(F, I)
        return I
    end
    function E.disconnect_all()
        for J, I in ipairs(F) do
            if I then
                I:Disconnect()
            end
        end
        F = {}
    end
end

do -- Targeting Framework
    local targeting_state = {current = nil}
    pcall(function()
        _G.targeting_state = targeting_state
    end)
    
    local TargetingFramework = {}
    
    do -- Utility Functions
        local utility = {}
        
        function utility:ValidateClient(player)
            if not player then
                return false
            end
            local character = player.Character
            if not character then
                return false
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                return false
            end
            return humanoid.RootPart ~= nil
        end
        
        function utility:GetPreferredPart(character)
            return character and 
                (character:FindFirstChild("HumanoidRootPart") or 
                 character:FindFirstChild("Head") or 
                 character:FindFirstChild("UpperTorso") or
                 character:FindFirstChild("Torso")) or nil
        end
        
        function utility:ToScreen(position)
            local screenPos, onScreen = cam:WorldToViewportPoint(position)
            return Vector2.new(screenPos.X, screenPos.Y), onScreen
        end
        
        function utility:GetMouseLocation()
            return c:GetMouseLocation()
        end
        
        function utility:GetMouseDistance(screenPos)
            return (utility:GetMouseLocation() - screenPos).Magnitude
        end
        
        function utility:getHeld()
            local character = g.Character
            if not character then return "None" end
            local tool = character:FindFirstChildOfClass("Tool")
            return tool or "None"
        end
        
        function utility:GetOrigin()
            local Tool = utility:getHeld()
            return (Tool ~= "None" and Tool.Handle and Tool.Handle.Position) or cam.CFrame.Position
        end
        
        TargetingFramework.utility = utility
    end
    
    do -- Core Framework Functions
        TargetingFramework._hit_listeners = {}
        TargetingFramework._target = {info = nil, listeners = {}}
        TargetingFramework._dd = {
            last_target = nil,
            last_char = nil,
            hum = nil,
            last_health = nil,
            last_max = nil,
            conn = nil,
            hum_conn = nil,
            last_debug_t = 0,
            override_player = nil
        }
        
        function TargetingFramework:GetClosestToMouse()
            local closestPlayer, closestDistance = nil, nil
            for _, player in ipairs(a:GetPlayers()) do
                if player ~= g and self.utility:ValidateClient(player) then
                    local character = player.Character
                    local targetPart = self.utility:GetPreferredPart(character)
                    if targetPart then
                        local screenPos, onScreen = self.utility:ToScreen(targetPart.Position)
                        if onScreen then
                            local distance = self.utility:GetMouseDistance(screenPos)
                            if not closestDistance or distance < closestDistance then
                                closestPlayer, closestDistance = player, distance
                            end
                        end
                    end
                end
            end
            return closestPlayer, closestDistance or math.huge
        end
        
        function TargetingFramework:OnHit(callback)
            if typeof(callback) == "function" then
                p(self._hit_listeners, callback)
            end
        end
        
        function TargetingFramework:OnTargetUpdate(callback)
            if typeof(callback) == "function" then
                p(self._target.listeners, callback)
            end
        end
        
        function TargetingFramework:_emit_hit(targetInfo)
            for _, callback in ipairs(self._hit_listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:GetTargetInfo()
            local targetInfo = self._target.info
            return targetInfo ~= nil, targetInfo
        end
        
        function TargetingFramework:SetTargetInfo(player)
            local targetInfo = nil
            self._dd.override_player = player or nil
            
            if player and player.Character then
                local character = player.Character
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local rootPart = humanoid and humanoid.RootPart or character:FindFirstChild("HumanoidRootPart")
                local health = humanoid and humanoid.Health or nil
                local maxHealth = humanoid and humanoid.MaxHealth or nil
                local cframe = rootPart and rootPart.CFrame or (character.GetPivot and character:GetPivot() or nil)
                local position = rootPart and rootPart.Position or (cframe and cframe.Position or nil)
                
                targetInfo = {
                    isTarget = true,
                    player = player,
                    userId = player.UserId,
                    name = player.Name,
                    displayName = player.DisplayName,
                    character = character,
                    humanoid = humanoid,
                    root = rootPart,
                    cframe = cframe,
                    position = position,
                    health = health,
                    maxHealth = maxHealth,
                    alive = humanoid and humanoid.Health > 0,
                    time = os.clock()
                }
            end
            
            self._target.info = targetInfo
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:ClearTargetInfo()
            self._target.info = nil
            self._dd.override_player = nil
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, nil)
            end
        end
        
        function TargetingFramework:SetCurrentTarget(player)
            self._dd.override_player = player
        end
        
        function TargetingFramework:ClearCurrentTarget()
            self._dd.override_player = nil
        end
        
        function TargetingFramework:GetCurrentTarget()
            return self._dd.override_player or (targeting_state and targeting_state.current or nil)
        end
    end
    
    do -- Target Selection Logic
        local TargetSelector = {}
        
        function TargetSelector:selectTarget()
            if targeting_state.current then
                targeting_state.current = nil
                TargetingFramework:ClearTargetInfo()
                TargetingFramework:ClearCurrentTarget()
            else
                local closestTarget, _distance = TargetingFramework:GetClosestToMouse()
                if closestTarget then
                    targeting_state.current = closestTarget
                    TargetingFramework:SetTargetInfo(closestTarget)
                    TargetingFramework:SetCurrentTarget(closestTarget)
                end
            end
        end
        
        TargetingFramework.selector = TargetSelector
    end
    
    do -- Health Detection System
        TargetingFramework.StartHealthDetection = function()
            if TargetingFramework._dd.conn then
                TargetingFramework._dd.conn:Disconnect()
            end
            TargetingFramework._dd.conn = b.Heartbeat:Connect(function()
                
                local dd = TargetingFramework._dd
                local currentTarget = dd.override_player or (targeting_state and targeting_state.current or nil)
                
                if currentTarget ~= dd.last_target then
                    dd.last_target = currentTarget
                    dd.last_char = nil
                    dd.hum = nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                end
                
                if not currentTarget then
                    return
                end
                
                local character = currentTarget.Character
                if character ~= dd.last_char or (dd.hum and not dd.hum.Parent) then
                    dd.last_char = character
                    dd.hum = character and character:FindFirstChildOfClass("Humanoid") or nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                    
                    if dd.hum then
                        task.wait()
                        dd.hum_conn = dd.hum.HealthChanged:Connect(function(newHealth)
                            local maxHealth = dd.hum and dd.hum.MaxHealth or 0
                            if dd.last_health == nil or dd.last_max == nil or maxHealth ~= dd.last_max then
                                dd.last_health = newHealth
                                dd.last_max = maxHealth
                                return
                            end
                            
                            if newHealth < dd.last_health then
                                local damage = dd.last_health - newHealth
                                TargetingFramework:_emit_hit({
                                    player = currentTarget,
                                    damage = damage,
                                    health = newHealth,
                                    maxHealth = maxHealth,
                                    time = os.clock()
                                })
                            end
                            
                            dd.last_health = newHealth
                            dd.last_max = maxHealth
                        end)
                    end
                end
            end)
        end
        
        TargetingFramework.StopHealthDetection = function()
            if TargetingFramework._dd.conn then
                TargetingFramework._dd.conn:Disconnect()
                TargetingFramework._dd.conn = nil
            end
            if TargetingFramework._dd.hum_conn then
                TargetingFramework._dd.hum_conn:Disconnect()
                TargetingFramework._dd.hum_conn = nil
            end
        end
    end
    
    _G.TargetingFramework = TargetingFramework
end

do -- Desync Framework
    local desync_vars = {
        Players = a,
        RunService = b,
        StarterGui = game:GetService("StarterGui"),
        newcf = C,
        v3 = B,
        typeof = typeof,
        task = task,
        math = math,
        cam = cam,
        uis = c
    }

    local config = {
        Desync = {
            Enabled = false,
            LogInterval = 2
        }
    }

    local state = {
        enabled = false,
        targetCFrame = nil,
        realCFrame = nil,
        hookInstalled = false,
        logStarted = false,
        followMode = false,
        viz_enabled = false,
        viz_part = nil,
        viz_line = nil,
        viz_conn = nil,
        heartbeatConn = nil
    }

    local desync_utility = {}

    function desync_utility:ValidateClient(player)
        if not player then
            return false
        end
        local character = player.Character
        if not character then
            return false
        end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            return false
        end
        local rootPart = humanoid.RootPart
        return rootPart ~= nil
    end

    function desync_utility:getPlayerParts(player)
        local character = player and player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local rootPart = humanoid and humanoid.RootPart
        return character, humanoid, rootPart
    end

    local function parseCFrame(arg1, arg2, arg3)
        local argType = desync_vars.typeof(arg1)
        if argType == "CFrame" then
            return arg1
        end
        if argType == "Vector3" then
            return desync_vars.newcf(arg1)
        end
        if argType == "table" and arg1[1] and arg1[2] and arg1[3] then
            return desync_vars.newcf(arg1[1], arg1[2], arg1[3])
        end
        if argType == "number" and type(arg2) == "number" and type(arg3) == "number" then
            return desync_vars.newcf(arg1, arg2, arg3)
        end
        return nil
    end

    local function installHook()
        if state.hookInstalled then
            return
        end
        if not hookmetamethod or not newcclosure or not checkcaller then
            state.hookInstalled = true
            return
        end
        local oldIndex
        oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
            if not checkcaller() then
                if key == "CFrame" and state.enabled then
                    local _, _, rootPart = desync_utility:getPlayerParts(g)
                    if rootPart and self == rootPart and state.realCFrame then
                        return state.realCFrame
                    end
                end
            end
            return oldIndex(self, key)
        end))
        state.hookInstalled = true
    end

    local function startDesyncLoop()
        if state.heartbeatConn then
            return
        end
        state.heartbeatConn = desync_vars.RunService.Heartbeat:Connect(function()
            if not config.Desync.Enabled or not state.enabled then
                return
            end
            if not desync_utility:ValidateClient(g) then
                return
            end
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            if not rootPart then
                return
            end
            state.realCFrame = rootPart.CFrame
            local targetCF
            if state.followMode then
                targetCF = rootPart.CFrame
            else
                targetCF = state.targetCFrame or state.realCFrame
            end
            rootPart.CFrame = targetCF
            task.wait()
            rootPart.CFrame = state.realCFrame
        end)
    end

    local DesyncLibrary = {}

    function DesyncLibrary.movedesyncto(arg1, arg2, arg3)
        local targetCF = parseCFrame(arg1, arg2, arg3)
        if not targetCF then
            error("movedesyncto: invalid coordinates")
        end
        state.targetCFrame = targetCF
        state.followMode = false
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        return targetCF
    end

    function DesyncLibrary.checksyncposition()
        local position
        if state.targetCFrame then
            position = state.targetCFrame.Position
        else
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            position = rootPart and rootPart.Position or nil
        end
        return position
    end

    function DesyncLibrary.SynchronizeSyncWithPlayer()
        if not desync_utility:ValidateClient(g) then
            error("SynchronizeSyncWithPlayer: player not ready")
        end
        state.targetCFrame = nil
        state.followMode = true
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        local _, _, rootPart = desync_utility:getPlayerParts(g)
        return rootPart and rootPart.CFrame or nil
    end

    function DesyncLibrary.StopDesync()
        config.Desync.Enabled = false
        state.enabled = false
        state.targetCFrame = nil
        state.followMode = false
        
        if state.heartbeatConn then
            pcall(function()
                state.heartbeatConn:Disconnect()
            end)
            state.heartbeatConn = nil
        end
    end

    function DesyncLibrary.IsEnabled()
        return state.enabled
    end

    pcall(function()
        getgenv().DesyncLibrary = DesyncLibrary
    end)
    _G.DesyncLibrary = DesyncLibrary
end

local K =
    loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/fent.lua/refs/heads/main/library"))()
local L =
    K:Window(
    {
        Name = "Fentik.sexyy",
        Size = UDim2.new(0, 700, 0, 670),
        GradientTitle = {
            Enabled = false,
            Start = Color3.fromRGB(255, 255, 255),
            Middle = Color3.fromRGB(255, 255, 255),
            End = Color3.fromRGB(255, 255, 255),
            Speed = 0.1
        }
    }
)
local M = L:Page({Name = "Ragebot", Columns = 2})
-- Неиспользуемые вкладки (закомментированы для оптимизации)
-- local N = L:Page({Name = "Visuals", Columns = 2})
-- local O = L:Page({Name = "Misc", Columns = 2})
-- local P = L:Page({Name = "AntiAim", Columns = 2})

do -- Ragebot Tab
    do -- Targeting Section
        local aP = M:Section({Name = "Targeting", Side = 1})
    local aQ = aP:Toggle({
        Name = "Targeting",
        Default = false,
        Flag = "TargetingEnabled",
        Callback = function(aR)
            if _G.TargetingFramework then
                if aR then
                    _G.TargetingFramework.StartHealthDetection()
                else
                    _G.TargetingFramework.StopHealthDetection()
                    _G.TargetingFramework:ClearTargetInfo()
                    _G.TargetingFramework:ClearCurrentTarget()
                    if _G.targeting_state then
                        _G.targeting_state.current = nil
                    end
                end
            end
        end
    })
    
        local aS = aQ:Keybind({
            Name = "Target Selection",
            Mode = "Toggle",
            Default = Enum.KeyCode.T,
            Flag = "TargetSelectionKey",
            Callback = function(aT)
                if K.Flags["TargetingEnabled"] and _G.TargetingFramework and _G.TargetingFramework.selector then
                    _G.TargetingFramework.selector:selectTarget()
                end
            end
        })
    end
    
    
    do -- Aimbot Section
        local aY = M:Section({Name = "Aimbot", Side = 1})
    local aZ = aY:Toggle({
        Name = "Enabled",
        Default = false,
        Flag = "AimbotEnabled",
        Callback = function(ba)
            -- Callback обрабатывается через aimbot logic
        end
    })
    
    local bb = aY:Textbox({
        Name = "XZ Prediction",
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotXZPrediction",
        Callback = function(bc)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bd = aY:Textbox({
        Name = "Y Prediction", 
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotYPrediction",
        Callback = function(be)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bf = aY:Toggle({
        Name = "ShowAimbot",
        Default = false,
        Flag = "ShowAimbot",
        Callback = function(bg)
            if _G.BeamVisualization then
                if bg then
                    _G.BeamVisualization.start()
                else
                    _G.BeamVisualization.stop()
                end
            end
        end
    })
    
        local bh = aY:Dropdown({
            Name = "Resolver Type",
            Items = {"Velocity", "MoveDirection", "CalculateCFrame"},
            Default = "Velocity",
            Flag = "ResolverType",
            Callback = function(bi)
                -- Callback обрабатывается через resolver logic
            end
        })
    end
    
    
    do -- Notify Section
        local aT = M:Section({Name = "Notify", Side = 2})
    local aU = aT:Toggle({
        Name = "OnSelected",
        Default = false,
        Flag = "NotifyOnSelected",
        Callback = function(aV)
            -- Callback будет обработан через targeting framework
        end
    })
    
        local aW = aT:Toggle({
            Name = "OnDamage", 
            Default = false,
            Flag = "NotifyOnDamage",
            Callback = function(aX)
                -- Callback будет обработан через targeting framework
            end
        })
    end
    
    do -- Desync Section
        local desyncSection = M:Section({Name = "Desync", Side = 2})
        local _autoArmorToggle = desyncSection:Toggle({
            Name = "AutoArmor",
            Default = false,
            Flag = "AutoArmorEnabled",
            Callback = function(enabled)
                if _G.AutoArmorFramework then
                    if enabled then
                        _G.AutoArmorFramework.start()
                    else
                        _G.AutoArmorFramework.stop()
                        -- Синхронизируемся при выключении
                        if getgenv().DesyncLibrary then
                            pcall(function()
                                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                            end)
                        end
                    end
                end
            end
        })
    end
    
    do -- Notification Integration
        if _G.TargetingFramework then
            _G.TargetingFramework:OnTargetUpdate(function(targetInfo)
                if K.Flags["NotifyOnSelected"] then
                    if targetInfo then
                        K:Notification("ragebot set to " .. targetInfo.name, 1, z(0, 255, 0))
                    else
                        K:Notification("ragebot set to nobody", 1, z(255, 255, 0))
                    end
                end
            end)
            
            _G.TargetingFramework:OnHit(function(hitInfo)
                if K.Flags["NotifyOnDamage"] and hitInfo then
                    local healthPercent = math.floor((hitInfo.health / hitInfo.maxHealth) * 100)
                    local damageText = t("Ragebot target %s hit for %.1f (%d%%)", hitInfo.player.Name, hitInfo.damage, healthPercent)
                    K:Notification(damageText, 1, z(255, 100, 100))
                end
            end)
        end
    end
    
    do -- Aimbot Framework
        local AimbotFramework = {}
        local LastPosition = nil
        local LastUpdateTime = nil
        
        local function GetPredictedPosition(targetPlayer)
            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") then 
                return nil 
            end
            
            local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
            if not targetPart then 
                return nil
            end
            
            if not LastPosition or not LastUpdateTime then
                LastPosition = targetPart.Position
                LastUpdateTime = os.clock()
                return LastPosition
            end
            
            local resolverType = K.Flags["ResolverType"] or "Velocity"
            local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
            local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
            
            if resolverType == "Velocity" then
                return targetPart.Position + B(
                    targetPart.Velocity.X * xzPrediction,
                    targetPart.Velocity.Y * yPrediction,
                    targetPart.Velocity.Z * xzPrediction
                )
            elseif resolverType == "MoveDirection" then
                return targetPart.Position + (targetPlayer.Character.Humanoid.MoveDirection * (xzPrediction * 10))
            elseif resolverType == "CalculateCFrame" then
                if (targetPart.Position - LastPosition).Magnitude < 0.001 then
                    return targetPart.Position
                else
                    local currentTime = os.clock()
                    local deltaTime = currentTime - LastUpdateTime
                    local deltaPosition = targetPart.Position - LastPosition
                    LastUpdateTime, LastPosition = currentTime, targetPart.Position
                    
                    if deltaTime > 0 and deltaPosition.Magnitude > 0.001 then
                        local velocity = deltaPosition / deltaTime
                        return targetPart.Position + velocity * (0.1 * xzPrediction)
                    else
                        return targetPart.Position
                    end
                end
            end
            
            return targetPart.Position
        end
        
        local function CheckAimbot()
            return K.Flags["AimbotEnabled"] and K.Flags["TargetingEnabled"] and _G.targeting_state and _G.targeting_state.current
        end
        
        local originalIndex
        originalIndex = hookmetamethod(game, "__index", function(t, k)
            if t:IsA("Mouse") and (k == "Hit" or k == "Target") and not checkcaller() then
                if CheckAimbot() and _G.targeting_state.current then
                    local targetPlayer = _G.targeting_state.current
                    local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
                    
                    if targetPart then
                        local predictedPos = GetPredictedPosition(targetPlayer) or targetPart.Position
                        local hit = C(predictedPos)
                        return k == "Hit" and hit or targetPart
                    end
                end
            end
            return originalIndex(t, k)
        end)
        
        _G.AimbotFramework = AimbotFramework
    end
    
    do -- Beam Visualization
        local currentBeam = nil
        local beamConnection = nil
        
        local function CreateBeam()
            if currentBeam then
                currentBeam:Destroy()
                currentBeam = nil
            end
            
            local beam = Instance.new("Beam")
            beam.Color = ColorSequence.new(z(255, 0, 0))
            beam.Transparency = NumberSequence.new(0.3)
            beam.Width0 = 0.08
            beam.Width1 = 0.08
            beam.FaceCamera = true
            
            local attachment0 = Instance.new("Attachment")
            local attachment1 = Instance.new("Attachment")
            
            attachment0.Parent = workspace
            attachment1.Parent = workspace
            
            beam.Attachment0 = attachment0
            beam.Attachment1 = attachment1
            beam.Parent = workspace
            
            currentBeam = {beam = beam, att0 = attachment0, att1 = attachment1}
            return currentBeam
        end
        
        local function UpdateBeam()
            if not K.Flags["ShowAimbot"] or not K.Flags["AimbotEnabled"] or not K.Flags["TargetingEnabled"] then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not _G.targeting_state or not _G.targeting_state.current then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not currentBeam then
                currentBeam = CreateBeam()
            end
            
            -- Проверяем наличие оружия с handle
            local tool = _G.TargetingFramework and _G.TargetingFramework.utility and _G.TargetingFramework.utility:getHeld()
            if not tool or tool == "None" or not tool.Handle then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not tool.Handle then return end
            local origin = tool.Handle.Position
            
            local targetPlayer = _G.targeting_state.current
            local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
            if not targetPart then return end
            
            local function GetPredictedPosition(targetPlayer)
                if not targetPlayer or not targetPlayer.Character then return nil end
                
                local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
                if not targetPart then return nil end
                
                -- Получаем актуальные значения из UI
                local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
                local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
                local velocity = targetPart.Velocity or B(0, 0, 0)
                
                -- Используем логику как в примере кода
                local predicted = targetPart.Position + B(
                    velocity.X * xzPrediction,
                    velocity.Y * yPrediction,
                    velocity.Z * xzPrediction
                )
                
                return predicted
            end
            
            local predictedPos = GetPredictedPosition(targetPlayer)
            currentBeam.att0.WorldPosition = origin
            currentBeam.att1.WorldPosition = predictedPos
        end
        
        -- НЕ создаем постоянное подключение, вместо этого будем создавать его при включении ShowAimbot
        local function StartBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
            end
            beamConnection = b.Heartbeat:Connect(UpdateBeam)
        end
        
        local function StopBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
                beamConnection = nil
            end
            if currentBeam then
                currentBeam.beam:Destroy()
                currentBeam.att0:Destroy()
                currentBeam.att1:Destroy()
                currentBeam = nil
            end
        end
        
        _G.BeamVisualization = {
            start = StartBeamVisualization,
            stop = StopBeamVisualization,
            cleanup = StopBeamVisualization
        }
    end
    
    do -- AutoArmor Framework
        local AutoArmorFramework = {}
        local armorConnection = nil
        local ARMOR_THRESHOLD = 199
        local isBuying = false
        
        local function GetArmorItem()
            local shopItems = workspace.Ignored and workspace.Ignored.Shop and workspace.Ignored.Shop:GetChildren()
            if shopItems and #shopItems >= 28 then
                return shopItems[28]
            end
            return nil
        end
        
        local function BuyArmor()
            if not K.Flags["AutoArmorEnabled"] then return end
            if isBuying then return end -- Предотвращаем спам
            
            local player = g
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            if not player.Character:FindFirstChild("BodyEffects") or 
               not player.Character.BodyEffects:FindFirstChild("Armor") then
                return
            end
            
            local armorItem = GetArmorItem()
            if not armorItem then return end
            
            local currentArmor = player.Character.BodyEffects.Armor.Value
            if currentArmor > ARMOR_THRESHOLD then return end
            
            isBuying = true -- Блокируем повторные вызовы
            
            -- Уведомление о начале цикла покупки
            K:Notification("Buying armor...", 1, z(255, 255, 0))
            
            -- Используем новый desync фреймворк для покупки
            if getgenv().DesyncLibrary then
                local success = pcall(function()
                    -- Перемещаемся к объекту брони через новый desync API
                    getgenv().DesyncLibrary.movedesyncto(armorItem.Head.CFrame)
                    task.wait(0.5)
                    
                    -- Покупаем броню
                    fireclickdetector(armorItem.ClickDetector)
                    task.wait(0.5)
                    
                    -- Синхронизируемся с локальным игроком
                    getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                end)
                
                if not success then
                    -- В случае ошибки синхронизируемся с локальным игроком
                    pcall(function()
                        getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                    end)
                end
                
                -- Уведомление о завершении цикла
                K:Notification("Armor buyed, player synced", 1, z(0, 255, 0))
            end
            
            isBuying = false -- Разблокируем после завершения
        end
        
        local function StartAutoArmor()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
            
            if K.Flags["AutoArmorEnabled"] then
                armorConnection = b.Heartbeat:Connect(function()
                    task.wait(1)
                    BuyArmor()
                end)
            end
        end
        
        AutoArmorFramework.start = StartAutoArmor
        AutoArmorFramework.stop = function()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
        end
        AutoArmorFramework.connections = {}
        
        -- Обработка смерти игрока
        local function OnCharacterRemoving()
            if getgenv().DesyncLibrary then
                pcall(function()
                    getgenv().DesyncLibrary.StopDesync()
                end)
            end
        end
        
        local function OnCharacterAdded(character)
            if character then
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.Died:Connect(OnCharacterRemoving)
                end
            end
        end
        
        -- Подключаем обработчики смерти с возможностью отключения
        local charRemovingConn = g.CharacterRemoving:Connect(OnCharacterRemoving)
        local charAddedConn = g.CharacterAdded:Connect(OnCharacterAdded)
        
        -- Сохраняем подключения для возможного отключения
        AutoArmorFramework.connections.charRemoving = charRemovingConn
        AutoArmorFramework.connections.charAdded = charAddedConn
        
        -- Если персонаж уже существует
        if g.Character then
            OnCharacterAdded(g.Character)
        end
        
        _G.AutoArmorFramework = AutoArmorFramework
    end
end -- End Ragebot Tab
do -- Watermark & Keybinds
    local Q = K:Watermark("Fentanyl | " .. g.Name .. " | " .. os.date("%y.%m.%d") .. " | Premium")
    local R = K:KeybindList()
    if Q then
        Q:SetVisibility(false)
    end
    if R then
        R:SetVisibility(false)
    end
    _G.Watermark = Q
    _G.KeybindList = R
end
do -- Settings Tab
    local S = L:Page({Name = "Settings", Columns = 2})
    local T = S:Section({Name = "Config", Side = 1})
    local U = ""
    local V = ""
    local _W = {}
    do
        if not isfolder("fentanyl") then
            makefolder("fentanyl")
        end
        if not isfolder("fentanyl/Configs") then
            makefolder("fentanyl/Configs")
        end
    end
    local function X()
        local configList = {}
        if isfolder("fentanyl/Configs") then
            for J, Y in ipairs(listfiles("fentanyl/Configs")) do
                local Z = Y:gsub("\\", "/")
                Z = Z:gsub("fentanyl/Configs/", "")
                p(configList, Z)
            end
        end
        return configList
    end
    local _ =
        T:Listbox(
        {Name = "Select Config", Items = X(), Default = "", Flag = "SelectedConfig", Callback = function(a0)
                U = a0
                print("Selected config:", a0)
            end}
    )
    local a1 =
        T:Textbox(
        {Name = "", Default = "", Placeholder = "Enter config name...", Flag = "ConfigName", Callback = function(a0)
                V = a0
            end}
    )
    local a2 =
        T:Button(
        {Name = "Create Config", Callback = function()
                if V and V ~= "" then
                    local a3 = V:gsub("%.json$", "") .. ".json"
                    local a4 = "fentanyl/Configs/" .. a3
                    if not isfile(a4) then
                        local a5 = K:GetConfig()
                        writefile(a4, a5)
                        K:Notification("Config created: " .. a3, 1, z(0, 255, 0))
                        _:Refresh(X())
                    else
                        K:Notification("Config already exists: " .. a3, 1, z(255, 0, 0))
                    end
                else
                    K:Notification("Please enter a config name", 1, z(255, 255, 0))
                end
            end}
    )
    local a6 =
        T:Button(
        {Name = "Save Config", Callback = function()
                local a3
                if U and U ~= "" then
                    a3 = U
                elseif V and V ~= "" then
                    a3 = V:gsub("%.json$", "") .. ".json"
                end
                if a3 then
                    local a4 = "fentanyl/Configs/" .. a3
                    local a5 = K:GetConfig()
                    writefile(a4, a5)
                    K:Notification("Config saved: " .. a3, 1, z(0, 255, 0))
                    _:Refresh(X())
                else
                    K:Notification("Please select or enter a config name", 1, z(255, 255, 0))
                end
            end}
    )
    local a7 =
        T:Button(
        {Name = "Load Config", Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    if isfile(a4) then
                        local a5 = readfile(a4)
                        K:LoadConfig(a5)
                        K:Notification("Config loaded: " .. U, 1, z(0, 255, 0))
                    else
                        K:Notification("Config not found: " .. U, 1, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 1, z(255, 255, 0))
                end
            end}
    )
    local a8 =
        T:Button(
        {Name = "Delete Config", Risky = true, Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    print("Trying to delete config at path:", a4)
                    print("File exists:", isfile(a4))
                    if isfile(a4) then
                        delfile(a4)
                        K:Notification("Config deleted: " .. U, 1, z(0, 255, 0))
                        _:Refresh(X())
                        U = ""
                    else
                        K:Notification("Config not found: " .. a4, 1, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 1, z(255, 255, 0))
                end
            end}
    )
    local a9 =
        T:Button(
        {Name = "Refresh Config List", Callback = function()
                _:Refresh(X())
                K:Notification("Config list refreshed", 1, z(0, 255, 0))
            end}
    )
    local aa = S:Section({Name = "Theming", Side = 2})
    local ab = aa:Label("Accent Color", "Left")
    local ac =
        ab:Colorpicker(
        {
            Name = "Accent Color",
            Default = z(31, 226, 130),
            Alpha = 1,
            Flag = "ThemeAccentColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Accent", ad)
                if L.GradientTitle and L.GradientTitle.Enabled then
                    L.GradientTitle.Start = ad
                    L.GradientTitle.Middle = ad
                    L.GradientTitle.End = ad
                end
            end
        }
    )
    local af = aa:Label("Window Background", "Left")
    local ag =
        af:Colorpicker(
        {
            Name = "Window Background",
            Default = z(43, 43, 43),
            Alpha = 1,
            Flag = "ThemeWindowBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Window Background", ad)
            end
        }
    )
    local ah = aa:Label("Text Color", "Left")
    local ai =
        ah:Colorpicker(
        {
            Name = "Text Color",
            Default = z(180, 180, 180),
            Alpha = 1,
            Flag = "ThemeTextColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Text", ad)
            end
        }
    )
    local aj = aa:Label("Section Background", "Left")
    local ak =
        aj:Colorpicker(
        {
            Name = "Section Background",
            Default = z(19, 19, 19),
            Alpha = 1,
            Flag = "ThemeSectionBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Section Background", ad)
            end
        }
    )
    local al = aa:Label("Element Color", "Left")
    local am =
        al:Colorpicker(
        {
            Name = "Element Color",
            Default = z(63, 63, 63),
            Alpha = 1,
            Flag = "ThemeElementColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Element", ad)
            end
        }
    )
    local an = aa:Label("Border Color", "Left")
    local ao =
        an:Colorpicker(
        {
            Name = "Border Color",
            Default = z(68, 68, 68),
            Alpha = 1,
            Flag = "ThemeBorderColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Border", ad)
            end
        }
    )
    local ap = aa:Label("Outline Color", "Left")
    local aq =
        ap:Colorpicker(
        {
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 1,
            Flag = "ThemeOutlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Outline", ad)
            end
        }
    )
    local ar = aa:Label("Dark Liner", "Left")
    local as =
        ar:Colorpicker(
        {Name = "Dark Liner", Default = z(56, 56, 56), Alpha = 1, Flag = "ThemeDarkLiner", Callback = function(ad, ae)
                K:ChangeTheme("Dark Liner", ad)
            end}
    )
    local at = aa:Label("Risky Color", "Left")
    local au =
        at:Colorpicker(
        {
            Name = "Risky Color",
            Default = z(255, 50, 50),
            Alpha = 1,
            Flag = "ThemeRiskyColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Risky", ad)
            end
        }
    )
    local av = aa:Label("Inline Color", "Left")
    local aw =
        av:Colorpicker(
        {
            Name = "Inline Color",
            Default = z(12, 12, 12),
            Alpha = 1,
            Flag = "ThemeInlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Inline", ad)
            end
        }
    )
    local ax = S:Section({Name = "HUD", Side = 2})
    local ay =
        ax:Toggle(
        {Name = "Keybinds", Default = false, Flag = "HUDKeybinds", Callback = function(a0)
                if _G.KeybindList then
                    _G.KeybindList:SetVisibility(a0)
                end
            end}
    )
    local az =
        ax:Toggle(
        {Name = "Watermark", Default = false, Flag = "HUDWatermark", Callback = function(a0)
                if _G.Watermark then
                    _G.Watermark:SetVisibility(a0)
                end
            end}
    )
    local aA = ax:Label("GUI", "Left")
    local aB =
        aA:Keybind(
        {
            Name = "Toggle GUI",
            Mode = "Toggle",
            Default = Enum.KeyCode.Insert,
            Flag = "GUIToggleKey",
            Callback = function(aC)
                if L and L.SetOpen then
                    L:SetOpen(not L.IsOpen)
                end
            end
        }
    )
    do
        local aD = L.SetOpen
        L.SetOpen = function(self, aE)
            aD(self, aE)
            if aB and aB.Toggled ~= self.IsOpen then
                aB.Toggled = self.IsOpen
                if aB.KeybindListItem then
                    aB.KeybindListItem:SetStatus(self.IsOpen)
                end
            end
        end
    end
    do
        local aF = S:Section({Name = "Server", Side = 2})
        local aG =
            aF:Button(
            {Name = "Copy GameID", Callback = function()
                    setclipboard(tostring(game.GameId))
                    K:Notification("GameID copied to clipboard", 1, z(0, 255, 0))
                end}
        )
        local aH =
            aF:Button(
            {Name = "Copy JobID", Callback = function()
                    setclipboard(game.JobId)
                    K:Notification("JobID copied to clipboard", 1, z(0, 255, 0))
                end}
        )
        local aI =
            aF:Button(
            {
                Name = "Copy Join Script",
                Callback = function()
                    local aJ =
                        'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                    setclipboard(aJ)
                    K:Notification("Join script copied to clipboard", 1, z(0, 255, 0))
                end
            }
        )
        local aK =
            aF:Button(
            {Name = "Rejoin Game", Callback = function()
                    D:TeleportToPlaceInstance(game.PlaceId, game.JobId, g)
                end}
        )
        local aL =
            aF:Button(
            {
                Name = "Join New Server",
                Callback = function()
                    local aM, aN =
                        pcall(
                        function()
                            return e:JSONDecode(
                                game:HttpGetAsync(
                                    "https://games.roblox.com/v1/games/" ..
                                        game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                                )
                            )
                        end
                    )
                    if aM and aN and aN.data and #aN.data > 0 then
                        local aO = aN.data[h(1, #aN.data)]
                        D:TeleportToPlaceInstance(game.PlaceId, aO.id)
                    else
                        K:Notification("Failed to get server list", 1, z(255, 0, 0))
                    end
                end
            }
        )
    end
end
K:Notification("Script loaded, press Insert to toggle GUI", 1, z(0, 255, 0))
