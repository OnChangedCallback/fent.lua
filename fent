loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))() -- ac bypass dont touch or remove
local game = game
local workspace = workspace
local a = game:GetService("Players")
local b = game:GetService("RunService")
local c = game:GetService("UserInputService")
local d = game:GetService("TweenService")
local e = game:GetService("HttpService")
local f = game:GetService("Lighting")
local g = a.LocalPlayer
local h, i = math.random, math.huge
local j, k = math.floor, math.ceil
local l, m = math.abs, math.sqrt
local n, o = math.sin, math.cos
local p, q = table.insert, table.remove
local r, s = table.sort, table.concat
local t, u = string.format, string.match
local v, w = string.lower, string.upper
local x, y = string.sub, string.gsub
local ipairs = ipairs
local type, tostring = type, tostring
local typeof = typeof
local pcall, xpcall = pcall, xpcall
local loadstring = loadstring
local setmetatable = setmetatable
local getmetatable = getmetatable
local z = Color3.fromRGB
local A = UDim2.new
local B = Vector3.new
local C = CFrame.new
local replicated_storage = game:GetService("ReplicatedStorage")
local main_remote = replicated_storage.MainRemotes:WaitForChild("MainRemoteEvent")
local isfolder = isfolder
local isfile = isfile
local listfiles = listfiles
local writefile = writefile
local readfile = readfile
local delfile = delfile
local makefolder = makefolder
local setclipboard = setclipboard
local D = game:GetService("TeleportService")
local cam = workspace.CurrentCamera
local Vector2 = Vector2
local Instance = Instance
local ColorSequence = ColorSequence
local ColorSequenceKeypoint = ColorSequenceKeypoint
local NumberSequence = NumberSequence
local NumberSequenceKeypoint = NumberSequenceKeypoint
local NumberRange = NumberRange
local Enum = Enum
local hookmetamethod = hookmetamethod
local checkcaller = checkcaller
local newcclosure = newcclosure
local getgenv = getgenv
local task = task or {}
local wait = wait or function(t) return task.wait(t) end
local fireclickdetector = fireclickdetector
local getconnections = getconnections
local debug = debug

repeat wait() until game:IsLoaded()

-- Предварительная загрузка звуков с таймаутом
local availableSounds = {}
local soundsLoaded = false

local function createSoundsFolder()
    if not isfolder("FentSounds") then
        makefolder("FentSounds")
    end
end

local function downloadSoundWithTimeout(fileName, downloadUrl, timeout)
    local soundPath = "FentSounds/" .. fileName
    
    if isfile(soundPath) then
        return true
    end
    
    local startTime = tick()
    local success = false
    
    spawn(function()
        local downloadSuccess, soundData = pcall(function()
            return game:HttpGet(downloadUrl)
        end)
        
        if downloadSuccess and soundData then
            writefile(soundPath, soundData)
            success = true
        end
    end)
    
    -- Ждем загрузки с таймаутом
    while (tick() - startTime) < timeout and not success do
        wait(0.1)
    end
    
    return success
end

local function fetchAndDownloadSounds()
    createSoundsFolder()
    local sounds = {}
    local totalSounds = 0
    local loadedSounds = 0
    
    print("[Fentanyl] Загрузка списка звуков из репозиториев...")
    
    -- Источник 1: OnChangedCallback/sounds
    local success1, response1 = pcall(function()
        return game:HttpGet("https://api.github.com/repos/OnChangedCallback/sounds/contents/main")
    end)
    
    if success1 then
        local jsonSuccess1, data1 = pcall(function()
            return game:GetService("HttpService"):JSONDecode(response1)
        end)
        
        if jsonSuccess1 and type(data1) == "table" then
            for _, file in ipairs(data1) do
                if file.name and file.name:match("%.wav$") then
                    local fileName = file.name:gsub("%.wav$", "")
                    table.insert(sounds, {
                        name = fileName, 
                        url = file.download_url, 
                        fullName = file.name,
                        source = "OnChangedCallback"
                    })
                    totalSounds = totalSounds + 1
                end
            end
        end
    end
    
    -- Источник 2: f1nobe7650/Nebula
    local success2, response2 = pcall(function()
        return game:HttpGet("https://api.github.com/repos/f1nobe7650/Nebula/contents/Sounds")
    end)
    
    if success2 then
        local jsonSuccess2, data2 = pcall(function()
            return game:GetService("HttpService"):JSONDecode(response2)
        end)
        
        if jsonSuccess2 and type(data2) == "table" then
            for _, file in ipairs(data2) do
                if file.name and (file.name:match("%.wav$") or file.name:match("%.mp3$") or file.name:match("%.ogg$")) then
                    local fileName = file.name:gsub("%.%w+$", "")
                    -- Добавляем префикс для различения источников
                    table.insert(sounds, {
                        name = "Nebula_" .. fileName, 
                        url = "https://github.com/f1nobe7650/Nebula/raw/refs/heads/main/Sounds/" .. file.name, 
                        fullName = "Nebula_" .. file.name,
                        source = "Nebula"
                    })
                    totalSounds = totalSounds + 1
                end
            end
        end
    end
    
    print("[Fentanyl] Найдено " .. totalSounds .. " звуков из " .. (success1 and "OnChangedCallback" or "") .. (success1 and success2 and " + " or "") .. (success2 and "Nebula" or "") .. ". Начинаю загрузку...")
    
    -- Загружаем каждый звук с таймаутом 10 секунд
    for i, sound in ipairs(sounds) do
        print("[Fentanyl] Загрузка " .. i .. "/" .. totalSounds .. ": " .. sound.name .. " (" .. sound.source .. ")")
        
        local downloaded = downloadSoundWithTimeout(sound.fullName, sound.url, 10)
        
        if downloaded then
            loadedSounds = loadedSounds + 1
            print("[Fentanyl] ✓ Загружен: " .. sound.name)
        else
            print("[Fentanyl] ✗ Пропущен (таймаут): " .. sound.name)
        end
    end
    
    -- Оставляем только загруженные звуки
    local finalSounds = {}
    for _, sound in ipairs(sounds) do
        if isfile("FentSounds/" .. sound.fullName) then
            table.insert(finalSounds, sound.name)
        end
    end
    
    -- Fallback если оба API недоступны
    if #finalSounds == 0 then
        print("[Fentanyl] API недоступны, используем fallback звуки")
        for i = 1, 20 do
            table.insert(finalSounds, tostring(i))
        end
    end
    
    print("[Fentanyl] Загрузка звуков завершена: " .. loadedSounds .. "/" .. totalSounds)
    return finalSounds
end

-- Загружаем звуки и ждем завершения
spawn(function()
    availableSounds = fetchAndDownloadSounds()
    soundsLoaded = true
    print("[Fentanyl] Все звуки обработаны, можно инициализировать UI")
end)

-- Ждем завершения загрузки звуков
print("[Fentanyl] Ожидание загрузки звуков...")
while not soundsLoaded do
    wait(0.5)
end

-- Circle rendering variables
local tick = tick
local Drawing = Drawing
local E = {}
local F = {}
do
    function E.new_connection(G, H)
        local I = G:Connect(H)
        p(F, I)
        return I
    end
    function E.disconnect_all()
        for J, I in ipairs(F) do
            if I then
                I:Disconnect()
            end
        end
        F = {}
    end
end

do -- Targeting Framework
    local targeting_state = {current = nil}
    pcall(function()
        _G.targeting_state = targeting_state
    end)
    
    local TargetingFramework = {}
    
    do -- Utility Functions
        local utility = {}
        
        function utility:ValidateClient(player)
            if not player then
                return false
            end
            local character = player.Character
            if not character then
                return false
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                return false
            end
            return humanoid.RootPart ~= nil
        end
        
        function utility:GetPreferredPart(character)
            return character and 
                (character:FindFirstChild("HumanoidRootPart") or 
                 character:FindFirstChild("Head") or 
                 character:FindFirstChild("UpperTorso") or
                 character:FindFirstChild("Torso")) or nil
        end
        
        function utility:ToScreen(position)
            local screenPos, onScreen = cam:WorldToViewportPoint(position)
            return Vector2.new(screenPos.X, screenPos.Y), onScreen
        end
        
        function utility:GetMouseLocation()
            return c:GetMouseLocation()
        end
        
        function utility:GetMouseDistance(screenPos)
            return (utility:GetMouseLocation() - screenPos).Magnitude
        end
        
        function utility:getHeld()
            local character = g.Character
            if not character then return "None" end
            local tool = character:FindFirstChildOfClass("Tool")
            return tool or "None"
        end
        
        function utility:GetOrigin()
            local Tool = utility:getHeld()
            return (Tool ~= "None" and Tool.Handle and Tool.Handle.Position) or cam.CFrame.Position
        end
        
        -- Force Hit utility functions
        function utility:isPlayerKO(player)
            if not player or not player.Character then return false end
            
            -- Проверяем K.O статус через BodyEffects
            local success, isKO = pcall(function()
                local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
                if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                    local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                    if koEffect and koEffect:FindFirstChild("Value") then
                        return koEffect.Value.Value == true
                    end
                end
                return false
            end)
            
            if success then
                return isKO
            end
            
            -- Fallback к проверке здоровья если BodyEffects недоступны
            local humanoid = player.Character:FindFirstChild("Humanoid")
            return humanoid and humanoid.Health <= 0
        end
        
        function utility:isPlayerGrabbed(player)
            if not player or not player.Character then return false end
            -- Проверяем, схвачен ли игрок
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                return humanoid.PlatformStand or false
            end
            return false
        end
        
        function utility:hasForceField(player)
            if not player or not player.Character then return false end
            return player.Character:FindFirstChildOfClass("ForceField") ~= nil
        end
        
        function utility:performForceHit(targetPlayer)
            if not targetPlayer or not targetPlayer.Character then 
                return false 
            end
            
            -- Проверяем K.O статус цели перед выстрелом
            if self:isPlayerKO(targetPlayer) then
                return false
            end
            
            local character = g.Character
            if not character then 
                return false 
            end
            
            local tool = character:FindFirstChildOfClass("Tool")
            if not tool or not tool:FindFirstChild("Handle") then 
                return false 
            end
            
            local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local targetHead = targetPlayer.Character:FindFirstChild("Head")
            if not targetHRP or not targetHead then 
                return false 
            end
            
            -- Получаем RemoteEvent оружия
            local toolRemote = tool:FindFirstChild("RemoteEvent")
            if not toolRemote then
                return false
            end
            
            -- Получаем MainRemoteEvent
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local mainRemotes = replicatedStorage:FindFirstChild("MainRemotes")
            if not mainRemotes then
                return false
            end
            
            local mainRemoteEvent = mainRemotes:FindFirstChild("MainRemoteEvent")
            if not mainRemoteEvent then
                return false
            end
            
            -- Выполняем последовательность выстрела как в оригинальном скрипте
            local origin = tool.Handle.Position
            
            -- 1. Сначала отправляем "Shoot" через RemoteEvent оружия
            local success1 = pcall(function()
                toolRemote:FireServer("Shoot")
            end)
            if not success1 then
                return false
            end
            
            -- 2. Отправляем основной выстрел через MainRemoteEvent
            local success2 = pcall(function()
                mainRemoteEvent:FireServer(
                    "ShootGun",
                    tool.Handle,
                    origin,
                    targetHRP.Position,
                    targetHead,
                    B(0, 0, -1) -- Vector3.zAxis как в оригинале
                )
            end)
            if not success2 then
                return false
            end
            
            -- 3. Завершаем выстрел
            local success3 = pcall(function()
                toolRemote:FireServer()
            end)
            if not success3 then
                return false
            end
            
            return success2
        end
        
        -- HitChams utility functions
        function utility:createHitChams(player)
            if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            -- Получаем настройки цвета, прозрачности и материала из UI
            local uiLib = _G.FentanylUI
            local chamsColor = (uiLib and uiLib.Flags and uiLib.Flags["hit_chams_color"]) or z(255, 0, 0)
            local chamsAlpha = (uiLib and uiLib.Flags and uiLib.Flags["hit_chams_alpha"]) or 0.0
            local chamsMaterial = (uiLib and uiLib.Flags and uiLib.Flags["hit_chams_material"]) or "Neon"
            
            player.Character.Archivable = true
            local cloned = player.Character:Clone()
            cloned.Name = "HitChams_Clone"
            
            local bodyParts = {
                "Head", "UpperTorso", "LowerTorso",
                "LeftUpperArm", "LeftLowerArm", "LeftHand",
                "RightUpperArm", "RightLowerArm", "RightHand",
                "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
                "RightUpperLeg", "RightLowerLeg", "RightFoot"
            }
            
            -- Удаляем ненужные части
            for _, part in ipairs(cloned:GetChildren()) do
                if part:IsA("BasePart") then
                    local partValid = false
                    for _, validPart in ipairs(bodyParts) do
                        if part.Name == validPart then
                            partValid = true
                            break
                        end
                    end
                    
                    if not partValid then
                        part:Destroy()
                    end
                elseif part:IsA("Accessory") or part:IsA("Tool") or part.Name == "face" or 
                       part:IsA("Shirt") or part:IsA("Pants") or part:IsA("Hat") then
                    part:Destroy()
                end
            end
            
            -- Удаляем Humanoid
            if cloned:FindFirstChild("Humanoid") then
                cloned.Humanoid:Destroy()
            end
            
            -- Настраиваем части тела с пользовательскими настройками
            for _, bodyPart in ipairs(cloned:GetChildren()) do
                if bodyPart:IsA("BasePart") then
                    bodyPart.CanCollide = false
                    bodyPart.Anchored = true
                    bodyPart.Transparency = chamsAlpha
                    bodyPart.Color = chamsColor
                    bodyPart.Material = Enum.Material[chamsMaterial]
                end
            end
            
            -- Настраиваем голову отдельно с пользовательскими настройками
            if cloned:FindFirstChild("Head") then
                local head = cloned.Head
                head.Transparency = chamsAlpha
                head.Color = chamsColor
                head.Material = Enum.Material[chamsMaterial]
                
                if head:FindFirstChild("face") then
                    head.face:Destroy()
                end
            end
            
            cloned.Parent = workspace
            
            -- Создаем tween для исчезновения
            local tweenInfo = TweenInfo.new(
                2, -- duration
                Enum.EasingStyle.Sine,
                Enum.EasingDirection.InOut,
                0,
                true
            )
            
            for _, bodyPart in ipairs(cloned:GetChildren()) do
                if bodyPart:IsA("BasePart") then
                    local tween = d:Create(bodyPart, tweenInfo, { Transparency = 1 })
                    tween:Play()
                end
            end
            
            -- Удаляем клон через заданное время
            task.delay(2, function()
                if cloned and cloned.Parent then
                    cloned:Destroy()
                end
            end)
        end
        
        -- HitSounds utility functions
        function utility:createSoundsFolder()
            if not isfolder("FentSounds") then
                makefolder("FentSounds")
            end
        end
        
        function utility:downloadHitSound(soundName)
            self:createSoundsFolder()
            
            -- Проверяем, это звук из Nebula или OnChangedCallback
            if soundName:match("^Nebula_") then
                -- Звук из Nebula репозитория
                local actualFileName = soundName:gsub("^Nebula_", "")
                local soundPath = "FentSounds/" .. soundName
                
                -- Проверяем все возможные расширения для Nebula
                local extensions = {".wav", ".mp3", ".ogg"}
                for _, ext in ipairs(extensions) do
                    local fullPath = soundPath .. ext
                    if isfile(fullPath) then
                        return fullPath
                    end
                end
                
                -- Если файл не найден, пытаемся загрузить
                for _, ext in ipairs(extensions) do
                    local fullPath = soundPath .. ext
                    local success, soundData = pcall(function()
                        return game:HttpGet("https://github.com/f1nobe7650/Nebula/raw/refs/heads/main/Sounds/" .. actualFileName .. ext)
                    end)
                    
                    if success and soundData and #soundData > 0 then
                        writefile(fullPath, soundData)
                        return fullPath
                    end
                end
                
                return nil
            else
                -- Звук из OnChangedCallback репозитория
                local soundPath = "FentSounds/" .. soundName .. ".wav"
                
                if isfile(soundPath) then
                    return soundPath
                end
                
                local success, soundData = pcall(function()
                    return game:HttpGet("https://github.com/OnChangedCallback/sounds/raw/main/main/" .. soundName .. ".wav")
                end)
                
                if success and soundData then
                    writefile(soundPath, soundData)
                    return soundPath
                else
                    return nil
                end
            end
        end
        
        function utility:playHitSound()
            local uiLib = _G.FentanylUI
            if not (uiLib and uiLib.Flags and uiLib.Flags["hit_sounds"]) then
                return
            end
            
            local volume = (uiLib.Flags["hit_sounds_volume"]) or 0.5
            local pitch = (uiLib.Flags["hit_sounds_pitch"]) or 1.0
            local soundSelection = (uiLib.Flags["hit_sounds_selection"]) or (availableSounds[1] or "1")
            
            local soundPath = self:downloadHitSound(soundSelection)
            
            if soundPath and isfile(soundPath) then
                local sound = Instance.new("Sound")
                sound.Volume = volume
                sound.PlaybackSpeed = pitch
                
                -- Используем правильный метод для локальных файлов
                local success, customAsset = pcall(function()
                    if getsynasset then
                        return getsynasset(soundPath)
                    elseif getcustomasset then
                        return getcustomasset(soundPath)
                    else
                        return "rbxassetid://6565367558" -- Fallback
                    end
                end)
                
                if success and customAsset then
                    sound.SoundId = customAsset
                    sound.Parent = workspace
                    
                    sound:Play()
                    
                    -- Удаляем звук после проигрывания
                    sound.Ended:Connect(function()
                        sound:Destroy()
                    end)
                end
            end
        end
        
        TargetingFramework.utility = utility
    end
    
    do -- Circle Utility Functions
        local circle_utility = {}
        
        function circle_utility.lerp(a, b, t)
            return a + (b - a) * t
        end
        
        function circle_utility.lerp_color(a, b, t)
            return z(
                circle_utility.lerp(a.R * 255, b.R * 255, t),
                circle_utility.lerp(a.G * 255, b.G * 255, t),
                circle_utility.lerp(a.B * 255, b.B * 255, t)
            )
        end
        
        function circle_utility.custom_gradient(t, time, c1, c2, c3, c4, speed)
            local tt = (t + (time * speed)) % 1
            if tt < 0.25 then
                return circle_utility.lerp_color(c1, c2, tt / 0.25)
            elseif tt < 0.5 then
                return circle_utility.lerp_color(c2, c3, (tt - 0.25) / 0.25)
            elseif tt < 0.75 then
                return circle_utility.lerp_color(c3, c4, (tt - 0.5) / 0.25)
            else
                return circle_utility.lerp_color(c4, c1, (tt - 0.75) / 0.25)
            end
        end
        
        TargetingFramework.circle_utility = circle_utility
    end
    
    do -- Core Framework Functions
        TargetingFramework._hit_listeners = {}
        TargetingFramework._target = {info = nil, listeners = {}}
        TargetingFramework._dd = {
            last_target = nil,
            last_char = nil,
            hum = nil,
            last_health = nil,
            last_max = nil,
            conn = nil,
            hum_conn = nil,
            last_debug_t = 0,
            override_player = nil
        }
        
        function TargetingFramework:GetClosestToMouse()
            local closestPlayer, closestDistance = nil, nil
            for _, player in ipairs(a:GetPlayers()) do
                if player ~= g and self.utility:ValidateClient(player) then
                    -- Проверяем KO check если включен
                    local uiLib = _G.FentanylUI
                    local skipPlayer = false
                    if uiLib and uiLib.Flags and uiLib.Flags["KOCheckEnabled"] then
                        if self.utility:isPlayerKO(player) then
                            -- Пропускаем KO игроков при выборе новой цели
                            skipPlayer = true
                        end
                    end
                    
                    if not skipPlayer then
                        local character = player.Character
                        local targetPart = self.utility:GetPreferredPart(character)
                        if targetPart then
                            local screenPos, onScreen = self.utility:ToScreen(targetPart.Position)
                            if onScreen then
                                local distance = self.utility:GetMouseDistance(screenPos)
                                if not closestDistance or distance < closestDistance then
                                    closestPlayer, closestDistance = player, distance
                                end
                            end
                        end
                    end
                end
            end
            return closestPlayer, closestDistance or math.huge
        end
        
        function TargetingFramework:OnHit(callback)
            if typeof(callback) == "function" then
                p(self._hit_listeners, callback)
            end
        end
        
        function TargetingFramework:OnTargetUpdate(callback)
            if typeof(callback) == "function" then
                p(self._target.listeners, callback)
            end
        end
        
        function TargetingFramework:_emit_hit(targetInfo)
            for _, callback in ipairs(self._hit_listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:GetTargetInfo()
            local targetInfo = self._target.info
            return targetInfo ~= nil, targetInfo
        end
        
        function TargetingFramework:SetTargetInfo(player)
            local targetInfo = nil
            self._dd.override_player = player or nil
            
            if player and player.Character then
                local character = player.Character
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local rootPart = humanoid and humanoid.RootPart or character:FindFirstChild("HumanoidRootPart")
                local health = humanoid and humanoid.Health or nil
                local maxHealth = humanoid and humanoid.MaxHealth or nil
                local cframe = rootPart and rootPart.CFrame or (character.GetPivot and character:GetPivot() or nil)
                local position = rootPart and rootPart.Position or (cframe and cframe.Position or nil)
                
                targetInfo = {
                    isTarget = true,
                    player = player,
                    userId = player.UserId,
                    name = player.Name,
                    displayName = player.DisplayName,
                    character = character,
                    humanoid = humanoid,
                    root = rootPart,
                    cframe = cframe,
                    position = position,
                    health = health,
                    maxHealth = maxHealth,
                    alive = humanoid and humanoid.Health > 0,
                    time = os.clock()
                }
            end
            
            self._target.info = targetInfo
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:ClearTargetInfo()
            self._target.info = nil
            self._dd.override_player = nil
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, nil)
            end
        end
        
        function TargetingFramework:SetCurrentTarget(player)
            self._dd.override_player = player
        end
        
        function TargetingFramework:ClearCurrentTarget()
            self._dd.override_player = nil
        end
        
        function TargetingFramework:GetCurrentTarget()
            return self._dd.override_player or (targeting_state and targeting_state.current or nil)
        end
    end
    
    do -- Target Selection Logic
        local TargetSelector = {}
        
        function TargetSelector:selectTarget()
            if targeting_state.current then
                targeting_state.current = nil
                TargetingFramework:ClearTargetInfo()
                TargetingFramework:ClearCurrentTarget()
            else
                local closestTarget, _distance = TargetingFramework:GetClosestToMouse()
                if closestTarget then
                    -- Дополнительная проверка KO для выбранной цели
                    local uiLib = _G.FentanylUI
                    if uiLib and uiLib.Flags and uiLib.Flags["KOCheckEnabled"] then
                        if TargetingFramework.utility:isPlayerKO(closestTarget) then
                            -- Не выбираем KO игрока
                            return
                        end
                    end
                    
                    targeting_state.current = closestTarget
                    TargetingFramework:SetTargetInfo(closestTarget)
                    TargetingFramework:SetCurrentTarget(closestTarget)
                end
            end
        end
        
        TargetingFramework.selector = TargetSelector
    end
    
    do -- Health Detection System
        local function StartHealthDetection()
            if TargetingFramework._dd.conn then
                TargetingFramework._dd.conn:Disconnect()
                TargetingFramework._dd.conn = nil
            end
            
            TargetingFramework._dd.conn = b.Heartbeat:Connect(function()
                -- Проверяем включен ли таргетинг ИЛИ OnDamage уведомления
                -- Проверяем через _G чтобы избежать ошибок с порядком инициализации
                local uiLib = _G.FentanylUI
                if not uiLib or not uiLib.Flags then
                    return
                end
                
                -- Если ни таргетинг, ни OnDamage не включены, выходим
                local targetingEnabled = uiLib.Flags["TargetingEnabled"]
                local onDamageEnabled = uiLib.Flags["NotifyOnDamage"]
                
                if not targetingEnabled and not onDamageEnabled then
                    return
                end
                
                local dd = TargetingFramework._dd
                local currentTarget = dd.override_player or (targeting_state and targeting_state.current or nil)
                
                -- Если есть OnDamage, но нет цели, пытаемся найти ближайшую
                if not currentTarget and onDamageEnabled then
                    local closestTarget, _distance = TargetingFramework:GetClosestToMouse()
                    if closestTarget then
                        currentTarget = closestTarget
                    end
                end
                
                if currentTarget ~= dd.last_target then
                    dd.last_target = currentTarget
                    dd.last_char = nil
                    dd.hum = nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                end
                
                if not currentTarget then
                    return
                end
                
                local character = currentTarget.Character
                if character ~= dd.last_char or (dd.hum and not dd.hum.Parent) then
                    dd.last_char = character
                    dd.hum = character and character:FindFirstChildOfClass("Humanoid") or nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                    
                    if dd.hum then
                        b.Heartbeat:Wait()
                        dd.hum_conn = dd.hum.HealthChanged:Connect(function(newHealth)
                            local maxHealth = dd.hum and dd.hum.MaxHealth or 0
                            
                            if dd.last_health == nil or dd.last_max == nil or maxHealth ~= dd.last_max then
                                dd.last_health = newHealth
                                dd.last_max = maxHealth
                                return
                            end
                            
                            if newHealth < dd.last_health then
                                local damage = dd.last_health - newHealth
                                
                                local hitInfo = {
                                    player = currentTarget,
                                    damage = damage,
                                    health = newHealth,
                                    maxHealth = maxHealth,
                                    time = os.clock()
                                }
                                
                                TargetingFramework:_emit_hit(hitInfo)
                            end
                            
                            dd.last_health = newHealth
                            dd.last_max = maxHealth
                        end)
                    end
                end
            end)
        end
        
        -- Функция остановки
        function TargetingFramework:StopHealthDetection()
            if self._dd.conn then
                self._dd.conn:Disconnect()
                self._dd.conn = nil
            end
            if self._dd.hum_conn then
                self._dd.hum_conn:Disconnect()
                self._dd.hum_conn = nil
            end
        end
        
        -- Запускаем только если нужно
        TargetingFramework.StartHealthDetection = StartHealthDetection
        
        -- Добавляем метод для проверки статуса
        function TargetingFramework:IsHealthDetectionActive()
            return self._dd.conn ~= nil
        end
    end
    
    _G.TargetingFramework = TargetingFramework
end

do -- Desync Framework
    local desync_vars = {
        Players = a,
        RunService = b,
        StarterGui = game:GetService("StarterGui"),
        newcf = C,
        v3 = B,
        typeof = typeof,
        task = task,
        math = math,
        cam = cam,
        uis = c
    }

    local config = {
        Desync = {
            Enabled = false,
            LogInterval = 2
        }
    }

    local state = {
        enabled = false,
        targetCFrame = nil,
        realCFrame = nil,
        hookInstalled = false,
        logStarted = false,
        followMode = false,
        viz_enabled = false,
        viz_part = nil,
        viz_line = nil,
        viz_conn = nil,
        heartbeatConn = nil
    }

    local desync_utility = {}

    function desync_utility:ValidateClient(player)
        if not player then
            return false
        end
        local character = player.Character
        if not character then
            return false
        end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            return false
        end
        local rootPart = humanoid.RootPart
        return rootPart ~= nil
    end

    function desync_utility:getPlayerParts(player)
        local character = player and player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local rootPart = humanoid and humanoid.RootPart
        return character, humanoid, rootPart
    end

    local function parseCFrame(arg1, arg2, arg3)
        local argType = desync_vars.typeof(arg1)
        if argType == "CFrame" then
            return arg1
        end
        if argType == "Vector3" then
            return desync_vars.newcf(arg1)
        end
        if argType == "table" and arg1[1] and arg1[2] and arg1[3] then
            return desync_vars.newcf(arg1[1], arg1[2], arg1[3])
        end
        if argType == "number" and type(arg2) == "number" and type(arg3) == "number" then
            return desync_vars.newcf(arg1, arg2, arg3)
        end
        return nil
    end

    local function installHook()
        if state.hookInstalled then
            return
        end
        if not hookmetamethod or not newcclosure or not checkcaller then
            state.hookInstalled = true
            return
        end
        local oldIndex
        oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
            if not checkcaller() then
                if key == "CFrame" and state.enabled then
                    local _, _, rootPart = desync_utility:getPlayerParts(g)
                    if rootPart and self == rootPart and state.realCFrame then
                        return state.realCFrame
                    end
                end
            end
            return oldIndex(self, key)
        end))
        state.hookInstalled = true
    end

    local function startDesyncLoop()
        if state.heartbeatConn then
            return
        end
        state.heartbeatConn = desync_vars.RunService.Heartbeat:Connect(function()
            -- Проверяем флаги и отключаем цикл если не нужен
            if not config.Desync.Enabled or not state.enabled then
                if state.heartbeatConn then
                    state.heartbeatConn:Disconnect()
                    state.heartbeatConn = nil
                end
                return
            end
            if not desync_utility:ValidateClient(g) then
                return
            end
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            if not rootPart then
                return
            end
            state.realCFrame = rootPart.CFrame
            local targetCF
            if state.followMode then
                targetCF = rootPart.CFrame
            else
                targetCF = state.targetCFrame or state.realCFrame
            end
            rootPart.CFrame = targetCF
            desync_vars.RunService.RenderStepped:Wait()
            rootPart.CFrame = state.realCFrame
        end)
    end

    local DesyncLibrary = {}
    

    function DesyncLibrary.movedesyncto(arg1, arg2, arg3)
        local targetCF = parseCFrame(arg1, arg2, arg3)
        if not targetCF then
            error("movedesyncto: invalid coordinates")
        end
        state.targetCFrame = targetCF
        state.followMode = false
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        return targetCF
    end

    function DesyncLibrary.checksyncposition()
        local position
        if state.targetCFrame then
            position = state.targetCFrame.Position
        else
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            position = rootPart and rootPart.Position or nil
        end
        return position
    end

    function DesyncLibrary.SynchronizeSyncWithPlayer()
        -- Безопасная проверка без ошибки
        if not desync_utility:ValidateClient(g) then
            return nil -- Просто возвращаем nil вместо ошибки
        end
        state.targetCFrame = nil
        state.followMode = true
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        local _, _, rootPart = desync_utility:getPlayerParts(g)
        return rootPart and rootPart.CFrame or nil
    end

    function DesyncLibrary.StopDesync()
        config.Desync.Enabled = false
        state.enabled = false
        state.targetCFrame = nil
        state.followMode = false
        
        if state.heartbeatConn then
            pcall(function()
                state.heartbeatConn:Disconnect()
            end)
            state.heartbeatConn = nil
        end
    end

    function DesyncLibrary.IsEnabled()
        return state.enabled
    end
    

    pcall(function()
        getgenv().DesyncLibrary = DesyncLibrary
    end)
    _G.DesyncLibrary = DesyncLibrary
end

local K =
    loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/fent.lua/refs/heads/main/library"))()

-- Сохраняем UI библиотеку в _G для доступа из других частей кода
_G.FentanylUI = K

local L =
    K:Window(
    {
        Name = "Fentik.sexyy",
        Size = UDim2.new(0, 700, 0, 670),
        GradientTitle = {
            Enabled = false,
            Start = Color3.fromRGB(255, 255, 255),
            Middle = Color3.fromRGB(255, 255, 255),
            End = Color3.fromRGB(255, 255, 255),
            Speed = 0.1
        }
    }
)
local M = L:Page({Name = "Ragebot", Columns = 2})
local N = L:Page({Name = "Visuals", Columns = 2})
-- local O = L:Page({Name = "Misc", Columns = 2})
-- local P = L:Page({Name = "AntiAim", Columns = 2})

do -- Ragebot Tab
    do -- Targeting Section
        local aP = M:Section({Name = "Targeting", Side = 1})
    local aQ = aP:Toggle({
        Name = "Targeting",
        Default = false,
        Flag = "TargetingEnabled",
        Callback = function(aR)
            if _G.TargetingFramework then
                if aR then
                    -- Включаем health detection при включении таргетинга
                    if _G.TargetingFramework.StartHealthDetection then
                        _G.TargetingFramework.StartHealthDetection()
                    end
                else
                    -- Выключаем health detection и очищаем таргет
                    _G.TargetingFramework:StopHealthDetection()
                    _G.TargetingFramework:ClearTargetInfo()
                    _G.TargetingFramework:ClearCurrentTarget()
                    if _G.targeting_state then
                        _G.targeting_state.current = nil
                    end
                end
            end
        end
    })
    
        local aS = aQ:Keybind({
            Name = "Target Selection",
            Mode = "Toggle",
            Default = Enum.KeyCode.T,
            Flag = "TargetSelectionKey",
            Callback = function(aT)
                if K.Flags["TargetingEnabled"] and _G.TargetingFramework and _G.TargetingFramework.selector then
                    _G.TargetingFramework.selector:selectTarget()
                end
            end
        })
    end
    
    
    do -- Aimbot Section
        local aY = M:Section({Name = "Aimbot", Side = 1})
    local aZ = aY:Toggle({
        Name = "Enabled",
        Default = false,
        Flag = "AimbotEnabled",
        Callback = function(ba)
            -- Callback обрабатывается через aimbot logic
        end
    })
    
    local bb = aY:Textbox({
        Name = "XZ Prediction",
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotXZPrediction",
        Callback = function(bc)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bd = aY:Textbox({
        Name = "Y Prediction", 
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotYPrediction",
        Callback = function(be)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bf = aY:Toggle({
        Name = "ShowAimbot",
        Default = false,
        Flag = "ShowAimbot",
        Callback = function(bg)
            -- Управляем beam visualization
            if _G.BeamVisualization then
                if bg then
                    if _G.BeamVisualization.StartBeamVisualization then
                        _G.BeamVisualization.StartBeamVisualization()
                    end
                else
                    if _G.BeamVisualization.StopBeamVisualization then
                        _G.BeamVisualization.StopBeamVisualization()
                    end
                end
            end
        end
    })
    
        local bh = aY:Dropdown({
            Name = "Resolver Type",
            Items = {"Velocity", "MoveDirection", "CalculateCFrame"},
            Default = "Velocity",
            Flag = "ResolverType",
            Callback = function(bi)
                -- Callback обрабатывается через resolver logic
            end
        })
    end
    
    do -- Gun Section
        local gunSection = M:Section({Name = "Gun", Side = 1})
        
        local _rapidFireToggle = gunSection:Toggle({
            Name = "Rapid Fire",
            Default = false,
            Flag = "RapidFireEnabled",
            Callback = function(enabled)
                if _G.RapidFireFramework then
                    _G.RapidFireFramework.setEnabled(enabled)
                end
            end
        })
        
        local _infinityAmmoToggle = gunSection:Toggle({
            Name = "Infinity Ammo (maypatched)",
            Default = false,
            Flag = "InfinityAmmoEnabled",
            Callback = function(enabled)
                if _G.InfinityAmmoFramework then
                    _G.InfinityAmmoFramework.setEnabled(enabled)
                end
            end
        })
        
        local _infinityRangeToggle = gunSection:Toggle({
            Name = "Infinity Range",
            Default = false,
            Flag = "InfinityRangeEnabled",
            Callback = function(enabled)
                if _G.InfinityRangeFramework then
                    _G.InfinityRangeFramework.setEnabled(enabled)
                end
            end
        })
        
        local _autoReloadToggle = gunSection:Toggle({
            Name = "AutoReload",
            Default = false,
            Flag = "AutoReloadEnabled",
            Callback = function(enabled)
                if _G.AutoReloadFramework then
                    _G.AutoReloadFramework.setEnabled(enabled)
                end
            end
        })
    end
    
    do -- Notify Section
        local aT = M:Section({Name = "Notify", Side = 2})
    local aU = aT:Toggle({
        Name = "OnSelected",
        Default = false,
        Flag = "NotifyOnSelected",
        Callback = function(aV)
            -- Callback будет обработан через targeting framework
        end
    })
    
        local aW = aT:Toggle({
            Name = "OnDamage", 
            Default = false,
            Flag = "NotifyOnDamage",
            Callback = function(aX)
                -- Callback будет обработан через targeting framework
            end
        })
    end
    
    do -- Checks Section
        local checksSection = M:Section({Name = "Checks", Side = 2})
        
        local _koCheckToggle = checksSection:Toggle({
            Name = "KO Check",
            Default = false,
            Flag = "KOCheckEnabled",
            Callback = function(enabled)
                -- Callback будет обработан через targeting framework
            end
        })
    end
    
    do -- Exploits Section
        local exploitsSection = M:Section({Name = "Exploits", Side = 2})
        
        local _forceHitToggle = exploitsSection:Toggle({
            Name = "Magic Bullets",
            Default = false,
            Flag = "ForceHitEnabled",
            Callback = function(enabled)
                if _G.ForceHitFramework then
                    if enabled then
                        _G.ForceHitFramework.start()
                    else
                        _G.ForceHitFramework.stop()
                    end
                end
            end
        })
        
        local _wallbangToggle = exploitsSection:Toggle({
            Name = "Wallbang",
            Default = false,
            Flag = "WallbangEnabled",
            Callback = function(enabled)
                if _G.WallbangFramework then
                    if enabled then
                        _G.WallbangFramework.start()
                    else
                        _G.WallbangFramework.stop()
                    end
                end
            end
        })
        
        local _noSpreadToggle = exploitsSection:Toggle({
            Name = "NoSpread",
            Default = false,
            Flag = "NoSpreadEnabled",
            Callback = function(enabled)
                if _G.NoSpreadFramework then
                    if enabled then
                        _G.NoSpreadFramework.start()
                    else
                        _G.NoSpreadFramework.stop()
                    end
                end
            end
        })
    end
    
    do -- Desync Section
        local desyncSection = M:Section({Name = "Desync", Side = 2})
        local _autoArmorToggle = desyncSection:Toggle({
            Name = "AutoArmor",
            Default = false,
            Flag = "AutoArmorEnabled",
            Callback = function(enabled)
                if _G.AutoArmorFramework then
                    if enabled then
                        _G.AutoArmorFramework.start()
                    else
                        _G.AutoArmorFramework.stop()
                        -- Синхронизируемся при выключении
                        if getgenv().DesyncLibrary then
                            pcall(function()
                                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                            end)
                        end
                    end
                end
            end
        })
        
        local _autoStompToggle = desyncSection:Toggle({
            Name = "Auto Stomp",
            Default = false,
            Flag = "AutoStompEnabled",
            Callback = function(enabled)
                if _G.AutoStompFramework then
                    if enabled then
                        _G.AutoStompFramework.start()
                    else
                        _G.AutoStompFramework.stop()
                    end
                end
            end
        })
        
        desyncSection:Toggle({
            Name = "Hide",
            Default = false,
            Flag = "HideEnabled",
            Callback = function(enabled)
                if _G.HideFramework then
                    if enabled then
                        _G.HideFramework.start()
                    else
                        _G.HideFramework.stop()
                    end
                end
            end
        })
    end
    
    do -- Notification Integration
        if _G.TargetingFramework then
            _G.TargetingFramework:OnTargetUpdate(function(targetInfo)
                if K.Flags["NotifyOnSelected"] then
                    if targetInfo then
                        K:Notification("Target selected: " .. targetInfo.name, 2, z(0, 255, 0))
                    else
                        K:Notification("Target cleared", 2, z(255, 255, 0))
                    end
                end
            end)
            
            _G.TargetingFramework:OnHit(function(hitInfo)
                if K.Flags["NotifyOnDamage"] and hitInfo then
                    local damageText = t("%.1f damage to %s", hitInfo.damage, hitInfo.player.Name)
                    K:Notification(damageText, 2, z(255, 100, 100))
                end
                
                -- Trigger HitChams when damage is detected
                if K.Flags["hit_chams"] and hitInfo and _G.HitChamsFramework then
                    _G.HitChamsFramework:TriggerHitChams(hitInfo.player)
                end
                
                -- Play HitSound when damage is detected
                if K.Flags["hit_sounds"] and hitInfo and _G.TargetingFramework and _G.TargetingFramework.utility then
                    _G.TargetingFramework.utility:playHitSound()
                end
            end)
        end
    end
    
    do -- Aimbot Framework
        local AimbotFramework = {}
        local LastPosition = nil
        local LastUpdateTime = nil
        
        local function GetPredictedPosition(targetPlayer)
            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") then 
                return nil 
            end
            
            local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
            if not targetPart then 
                return nil
            end
            
            if not LastPosition or not LastUpdateTime then
                LastPosition = targetPart.Position
                LastUpdateTime = os.clock()
                return LastPosition
            end
            
            local resolverType = K.Flags["ResolverType"] or "Velocity"
            local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
            local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
            
            if resolverType == "Velocity" then
                return targetPart.Position + B(
                    targetPart.Velocity.X * xzPrediction,
                    targetPart.Velocity.Y * yPrediction,
                    targetPart.Velocity.Z * xzPrediction
                )
            elseif resolverType == "MoveDirection" then
                return targetPart.Position + (targetPlayer.Character.Humanoid.MoveDirection * (xzPrediction * 10))
            elseif resolverType == "CalculateCFrame" then
                if (targetPart.Position - LastPosition).Magnitude < 0.001 then
                    return targetPart.Position
                else
                    local currentTime = os.clock()
                    local deltaTime = currentTime - LastUpdateTime
                    local deltaPosition = targetPart.Position - LastPosition
                    LastUpdateTime, LastPosition = currentTime, targetPart.Position
                    
                    if deltaTime > 0 and deltaPosition.Magnitude > 0.001 then
                        local velocity = deltaPosition / deltaTime
                        return targetPart.Position + velocity * (0.1 * xzPrediction)
                    else
                        return targetPart.Position
                    end
                end
            end
            
            return targetPart.Position
        end
        
        local function CheckAimbot()
            return K.Flags["AimbotEnabled"] and K.Flags["TargetingEnabled"] and _G.targeting_state and _G.targeting_state.current
        end
        
        local originalIndex
        originalIndex = hookmetamethod(game, "__index", function(t, k)
            if t:IsA("Mouse") and (k == "Hit" or k == "Target") and not checkcaller() then
                if CheckAimbot() and _G.targeting_state.current then
                    local targetPlayer = _G.targeting_state.current
                    local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
                    
                    if targetPart then
                        local predictedPos = GetPredictedPosition(targetPlayer) or targetPart.Position
                        local hit = C(predictedPos)
                        return k == "Hit" and hit or targetPart
                    end
                end
            end
            return originalIndex(t, k)
        end)
        
        _G.AimbotFramework = AimbotFramework
    end
    
    do -- Force Hit Framework
        local ForceHitFramework = {
            enabled = false,
            connection = nil,
            shootDelay = 0.1, -- Задержка между выстрелами
            lastShotTime = 0
        }
        
        function ForceHitFramework.start()
            if ForceHitFramework.connection then
                return
            end
            
            ForceHitFramework.enabled = true
            
            ForceHitFramework.connection = E.new_connection(b.Heartbeat, function()
                if not ForceHitFramework.enabled then
                    return
                end
                
                -- Проверяем, есть ли текущая цель
                if not _G.targeting_state or not _G.targeting_state.current then
                    return
                end
                
                local currentTarget = _G.targeting_state.current
                if not currentTarget or not currentTarget.Character then
                    return
                end
                
                -- Проверяем задержку между выстрелами
                local now = os.clock()
                if now - ForceHitFramework.lastShotTime < ForceHitFramework.shootDelay then
                    return
                end
                
                -- Проверяем, есть ли у нас оружие
                local character = g.Character
                if not character then
                    return
                end
                
                local tool = character:FindFirstChildOfClass("Tool")
                if not tool or not tool:FindFirstChild("Handle") then
                    return
                end
                
                -- Проверяем состояние цели
                local utility = _G.TargetingFramework and _G.TargetingFramework.utility
                if not utility then
                    return
                end
                
                local isKO = utility:isPlayerKO(currentTarget)
                local _isGrabbed = utility:isPlayerGrabbed(currentTarget)
                local hasFF = utility:hasForceField(currentTarget)
                
                -- Если цель в невалидном состоянии, пропускаем
                if isKO or hasFF then
                    return
                end
                
                -- Проверяем дистанцию
                local targetHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
                if not targetHRP then
                    return
                end
                
                local myHRP = character:FindFirstChild("HumanoidRootPart")
                if not myHRP then
                    return
                end
                
                local distance = (myHRP.Position - targetHRP.Position).Magnitude
                local maxRange = 5000 -- Максимальная дистанция для Force Hit
                
                if distance > maxRange then
                    return
                end
                
                -- Выполняем Force Hit
                local success = utility.performForceHit(utility, currentTarget)
                if success then
                    ForceHitFramework.lastShotTime = now
                end
            end)
        end
        
        function ForceHitFramework.stop()
            ForceHitFramework.enabled = false
            if ForceHitFramework.connection then
                ForceHitFramework.connection:Disconnect()
                ForceHitFramework.connection = nil
            end
        end
        
        _G.ForceHitFramework = ForceHitFramework
    end
    
    do -- AutoReload Framework
        local AutoReloadFramework = {
            enabled = false,
            connection = nil,
            reloadDelay = 1.0, -- Задержка после перезарядки
            lastReloadTime = 0,
            mainModule = nil
        }
        
        function AutoReloadFramework.start()
            if AutoReloadFramework.connection then
                return
            end
            
            -- Получаем MainModule
            local handler = replicated_storage:FindFirstChild("MainModule")
            if not handler then
                return
            end
            
            local success, module = pcall(function()
                return require(handler)
            end)
            
            if not success or not module then
                return
            end
            
            AutoReloadFramework.mainModule = module
            AutoReloadFramework.enabled = true
            
            AutoReloadFramework.connection = E.new_connection(b.Heartbeat, function()
                if not AutoReloadFramework.enabled then
                    return
                end
                
                -- Проверяем задержку после последней перезарядки
                local now = os.clock()
                if now - AutoReloadFramework.lastReloadTime < AutoReloadFramework.reloadDelay then
                    return
                end
                
                local character = g.Character
                if not character then
                    return
                end
                
                -- Используем новую логику с MainModule.GunHold
                local gun = AutoReloadFramework.mainModule.GunHold(character)
                if not gun or not gun[1] then
                    return
                end
                
                local tool = gun[1]
                local ammo = tool:FindFirstChild("Ammo")
                if not ammo or ammo.Value > 0 then
                    return
                end
                
                -- Перезаряжаем оружие через новый remote
                main_remote:FireServer("Reload", tool)
                AutoReloadFramework.lastReloadTime = now
            end)
        end
        
        function AutoReloadFramework.stop()
            if AutoReloadFramework.connection then
                AutoReloadFramework.connection:Disconnect()
                AutoReloadFramework.connection = nil
            end
            AutoReloadFramework.enabled = false
            AutoReloadFramework.mainModule = nil
        end
        
        function AutoReloadFramework.setEnabled(enabled)
            if enabled then
                AutoReloadFramework.start()
            else
                AutoReloadFramework.stop()
            end
        end
        
        _G.AutoReloadFramework = AutoReloadFramework
    end
    
    do -- Wallbang Framework
        local WallbangFramework = {
            enabled = false,
            originalIgnored = nil,
            mainModule = nil
        }
        
        function WallbangFramework.start()
            if WallbangFramework.enabled then
                return
            end
            
            -- Получаем MainModule
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local handler = replicatedStorage:FindFirstChild("MainModule")
            if not handler then
                print("[Wallbang] MainModule not found")
                return
            end
            
            local success, module = pcall(function()
                return require(handler)
            end)
            
            if not success or not module then
                print("[Wallbang] Failed to require MainModule")
                return
            end
            
            WallbangFramework.mainModule = module
            
            -- Сохраняем оригинальные значения
            if module.Ignored then
                WallbangFramework.originalIgnored = {}
                for i, v in ipairs(module.Ignored) do
                    WallbangFramework.originalIgnored[i] = v
                end
                print("[Wallbang] Original Ignored saved:", #WallbangFramework.originalIgnored, "items")
            else
                WallbangFramework.originalIgnored = nil
                print("[Wallbang] No original Ignored found")
            end
            
            -- Устанавливаем новые значения для Wallbang
            pcall(function()
                module.Ignored = {
                    workspace:WaitForChild("Vehicles"), 
                    workspace:WaitForChild("MAP"), 
                    workspace:WaitForChild("Ignored")
                }
            end)
            
            WallbangFramework.enabled = true
            print("[Wallbang] Framework started - walls will be ignored")
        end
        
        function WallbangFramework.stop()
            if not WallbangFramework.enabled then
                return
            end
            
            -- Восстанавливаем оригинальные значения
            if WallbangFramework.mainModule and WallbangFramework.originalIgnored then
                pcall(function()
                    WallbangFramework.mainModule.Ignored = {}
                    for i, v in ipairs(WallbangFramework.originalIgnored) do
                        WallbangFramework.mainModule.Ignored[i] = v
                    end
                end)
                print("[Wallbang] Original Ignored restored:", #WallbangFramework.originalIgnored, "items")
            elseif WallbangFramework.mainModule then
                -- Если оригинальных значений не было, очищаем
                pcall(function()
                    WallbangFramework.mainModule.Ignored = {}
                end)
                print("[Wallbang] Ignored cleared (no original values)")
            end
            
            WallbangFramework.enabled = false
            WallbangFramework.originalIgnored = nil
            WallbangFramework.mainModule = nil
            print("[Wallbang] Framework stopped - walls restored")
        end
        
        _G.WallbangFramework = WallbangFramework
    end
    
    do -- NoSpread Framework
        local NoSpreadFramework = {
            enabled = false,
            originalMathRandom = nil,
            hookedFunction = nil
        }
        
        function NoSpreadFramework.start()
            if NoSpreadFramework.enabled then
                return
            end
            
            -- Создаем хук для math.random
            local old
            old = hookfunction(math.random, function(...)
                local args = {...}
                
                -- Проверяем, вызывается ли из нашего кода
                if checkcaller() then
                    return old(...)
                end
                
                -- Проверяем аргументы для spread
                if (#args == 0) or 
                   (args[1] == -0.05 and args[2] == 0.05) or 
                   (args[1] == -0.1) or
                   (args[1] == -0.05) then
                    
                    -- Если NoSpread включен, возвращаем минимальный spread (1% от оригинала)
                    local originalResult = old(...)
                    return originalResult * 0.01 -- 1% spread
                end
                
                return old(...)
            end)
            
            NoSpreadFramework.originalMathRandom = old
            
            NoSpreadFramework.enabled = true
            print("[NoSpread] Framework started - bullet spread reduced to 1%")
        end
        
        function NoSpreadFramework.stop()
            if not NoSpreadFramework.enabled then
                return
            end
            
            -- Восстанавливаем оригинальную функцию math.random
            if NoSpreadFramework.originalMathRandom then
                pcall(function()
                    hookfunction(math.random, NoSpreadFramework.originalMathRandom)
                end)
            end
            
            NoSpreadFramework.enabled = false
            NoSpreadFramework.originalMathRandom = nil
            NoSpreadFramework.hookedFunction = nil
            print("[NoSpread] Framework stopped - original bullet spread restored")
        end
        
        _G.NoSpreadFramework = NoSpreadFramework
    end
    
    do -- Infinity Range Framework
        local InfinityRangeFramework = {
            enabled = false,
            connection = nil,
            originalValues = {}
        }
        
        local function findRangeValues(weapon)
            local rangeValues = {}
            
            -- Прямой поиск в оружии
            local range = weapon:FindFirstChild("Range") or 
                         weapon:FindFirstChild("MaxRange") or 
                         weapon:FindFirstChild("Distance") or
                         weapon:FindFirstChild("MaxDistance") or
                         weapon:FindFirstChild("Reach")
            if range then
                p(rangeValues, range)
            end
            
            -- Поиск в Configuration/Settings
            local config = weapon:FindFirstChild("Configuration") or 
                          weapon:FindFirstChild("Settings") or
                          weapon:FindFirstChild("Config") or
                          weapon:FindFirstChild("Stats")
            if config then
                local configRange = config:FindFirstChild("Range") or 
                                   config:FindFirstChild("MaxRange") or
                                   config:FindFirstChild("Distance") or
                                   config:FindFirstChild("MaxDistance") or
                                   config:FindFirstChild("Reach") or
                                   config:FindFirstChild("FireRange")
                if configRange then
                    p(rangeValues, configRange)
                end
            end
            
            -- Поиск в Handle
            local handle = weapon:FindFirstChild("Handle")
            if handle then
                local handleRange = handle:FindFirstChild("Range") or 
                                   handle:FindFirstChild("MaxRange") or
                                   handle:FindFirstChild("Distance")
                if handleRange then
                    p(rangeValues, handleRange)
                end
                
                -- Поиск в Handle/Configuration
                local handleConfig = handle:FindFirstChild("Configuration") or 
                                    handle:FindFirstChild("Settings")
                if handleConfig then
                    local hcRange = handleConfig:FindFirstChild("Range") or 
                                   handleConfig:FindFirstChild("MaxRange") or
                                   handleConfig:FindFirstChild("Distance")
                    if hcRange then
                        p(rangeValues, hcRange)
                    end
                end
            end
            
            -- Поиск в GunScript или аналогичных скриптах
            local gunScript = weapon:FindFirstChild("GunScript") or 
                             weapon:FindFirstChild("WeaponScript") or
                             weapon:FindFirstChild("Script")
            if gunScript then
                local scriptRange = gunScript:FindFirstChild("Range") or 
                                   gunScript:FindFirstChild("MaxRange")
                if scriptRange then
                    p(rangeValues, scriptRange)
                end
            end
            
            return rangeValues
        end
        
        local function updateRange(weapon)
            local rangeValues = findRangeValues(weapon)
            
            for _, rangeValue in ipairs(rangeValues) do
                if rangeValue:IsA("NumberValue") or rangeValue:IsA("IntValue") then
                    -- Сохраняем оригинальное значение если еще не сохранили
                    local key = tostring(weapon) .. "_" .. tostring(rangeValue)
                    if InfinityRangeFramework.enabled then
                        if not InfinityRangeFramework.originalValues[key] then
                            InfinityRangeFramework.originalValues[key] = rangeValue.Value
                        end
                        -- Устанавливаем огромное значение
                        rangeValue.Value = 999999999999999999
                    else
                        -- Восстанавливаем оригинальное значение
                        if InfinityRangeFramework.originalValues[key] then
                            rangeValue.Value = InfinityRangeFramework.originalValues[key]
                        end
                    end
                end
            end
        end
        
        function InfinityRangeFramework.setEnabled(state)
            InfinityRangeFramework.enabled = state
            
            if state and not InfinityRangeFramework.connection then
                InfinityRangeFramework.connection = E.new_connection(b.Heartbeat, function()
                    if not InfinityRangeFramework.enabled then
                        return
                    end
                    
                    -- Ищем оружие в руках
                    local character = g.Character
                    if character then
                        local tool = character:FindFirstChildOfClass("Tool")
                        if tool then
                            pcall(function()
                                updateRange(tool)
                            end)
                        end
                    end
                    
                    -- Ищем оружие в workspace.Players
                    local playersFolder = workspace:FindFirstChild("Players")
                    if playersFolder then
                        local playerFolder = playersFolder:FindFirstChild(g.Name)
                        if playerFolder then
                            for _, child in ipairs(playerFolder:GetChildren()) do
                                local name = child.Name
                                if name:match("%[.+%]") or 
                                   name:match("Gun") or 
                                   name:match("Pistol") or 
                                   name:match("Rifle") or
                                   name:match("Shotgun") or
                                   name:match("Revolver") then
                                    pcall(function()
                                        updateRange(child)
                                    end)
                                end
                            end
                        end
                    end
                end)
            elseif not state then
                -- Восстанавливаем все оригинальные значения
                local character = g.Character
                if character then
                    local tool = character:FindFirstChildOfClass("Tool")
                    if tool then
                        pcall(function()
                            updateRange(tool)
                        end)
                    end
                end
                
                local playersFolder = workspace:FindFirstChild("Players")
                if playersFolder then
                    local playerFolder = playersFolder:FindFirstChild(g.Name)
                    if playerFolder then
                        for _, child in ipairs(playerFolder:GetChildren()) do
                            pcall(function()
                                updateRange(child)
                            end)
                        end
                    end
                end
                
                if InfinityRangeFramework.connection then
                    InfinityRangeFramework.connection:Disconnect()
                    InfinityRangeFramework.connection = nil
                end
                
                -- Очищаем сохраненные значения
                InfinityRangeFramework.originalValues = {}
            end
        end
        
        _G.InfinityRangeFramework = InfinityRangeFramework
    end
    
    do -- Infinity Ammo Framework
        local InfinityAmmoFramework = {
            enabled = false,
            connection = nil
        }
        
        local function updateAmmo()
            -- Работаем только через workspace.Players
            local playersFolder = workspace:FindFirstChild("Players")
            if not playersFolder then return end
            
            local playerFolder = playersFolder:FindFirstChild(g.Name)
            if not playerFolder then return end
            
            -- Проходим по всем объектам в папке игрока
            for _, weapon in ipairs(playerFolder:GetChildren()) do
                local name = weapon.Name
                -- Проверяем типичные паттерны названий оружия
                if name:match("%[.+%]") or -- [Revolver], [Shotgun] и т.д.
                   name:match("Gun") or 
                   name:match("Pistol") or 
                   name:match("Rifle") or
                   name:match("Shotgun") or
                   name:match("Revolver") or
                   name:match("SMG") or
                   name:match("AK") or
                   name:match("Glock") or
                   name:match("Weapon") then
                    
                    -- Ищем патроны в оружии
                    local ammoValue = weapon:FindFirstChild("Ammo") or 
                                     weapon:FindFirstChild("Bullets") or 
                                     weapon:FindFirstChild("Clip") or
                                     weapon:FindFirstChild("CurrentAmmo")
                    
                    local maxAmmoValue = weapon:FindFirstChild("MaxAmmo") or 
                                        weapon:FindFirstChild("MaxBullets") or 
                                        weapon:FindFirstChild("ClipSize") or
                                        weapon:FindFirstChild("MaxClip")
                    
                    -- Если не нашли, ищем в Configuration
                    if not ammoValue then
                        local config = weapon:FindFirstChild("Configuration") or 
                                      weapon:FindFirstChild("Settings") or
                                      weapon:FindFirstChild("Config")
                        if config then
                            ammoValue = config:FindFirstChild("Ammo") or 
                                       config:FindFirstChild("Bullets") or
                                       config:FindFirstChild("CurrentAmmo")
                            maxAmmoValue = maxAmmoValue or config:FindFirstChild("MaxAmmo") or 
                                          config:FindFirstChild("MaxBullets") or
                                          config:FindFirstChild("ClipSize")
                        end
                    end
                    
                    -- Если не нашли, ищем в Handle
                    if not ammoValue then
                        local handle = weapon:FindFirstChild("Handle")
                        if handle then
                            ammoValue = handle:FindFirstChild("Ammo") or 
                                       handle:FindFirstChild("Bullets")
                            maxAmmoValue = maxAmmoValue or handle:FindFirstChild("MaxAmmo") or 
                                          handle:FindFirstChild("MaxBullets")
                        end
                    end
                    
                    -- Обновляем патроны если нашли
                    if ammoValue and maxAmmoValue then
                        if (ammoValue:IsA("NumberValue") or ammoValue:IsA("IntValue")) and
                           (maxAmmoValue:IsA("NumberValue") or maxAmmoValue:IsA("IntValue")) then
                            if ammoValue.Value ~= maxAmmoValue.Value then
                                ammoValue.Value = maxAmmoValue.Value
                            end
                        end
                    elseif ammoValue and not maxAmmoValue then
                        -- Если нет максимального значения, устанавливаем большое число
                        if ammoValue:IsA("NumberValue") or ammoValue:IsA("IntValue") then
                            if ammoValue.Value < 999 then
                                ammoValue.Value = 999
                            end
                        end
                    end
                end
            end
        end
        
        function InfinityAmmoFramework.setEnabled(state)
            InfinityAmmoFramework.enabled = state
            
            if state and not InfinityAmmoFramework.connection then
                InfinityAmmoFramework.connection = E.new_connection(b.Heartbeat, function()
                    if not InfinityAmmoFramework.enabled then
                        return
                    end
                    
                    pcall(updateAmmo)
                end)
            elseif not state and InfinityAmmoFramework.connection then
                InfinityAmmoFramework.connection:Disconnect()
                InfinityAmmoFramework.connection = nil
            end
        end
        
        _G.InfinityAmmoFramework = InfinityAmmoFramework
    end
    
    do -- Rapid Fire Framework
        local RapidFireFramework = {
            enabled = false,
            original = {},
            connection = nil
        }
        
        function RapidFireFramework.setEnabled(state)
            RapidFireFramework.enabled = state
            
            if state and not RapidFireFramework.connection then
                RapidFireFramework.connection = E.new_connection(b.RenderStepped, function()
                    if not RapidFireFramework.enabled then
                        return
                    end
                    
                    local tool = g.Character and g.Character:FindFirstChildOfClass("Tool")
                    if tool and tool:FindFirstChild("GunScript") then
                        for _, connection in ipairs(getconnections(tool.Activated)) do
                            local func = connection.Function
                            if func then
                                local funcInfo = debug.getinfo(func)
                                for i = 1, funcInfo.nups do
                                    local c, _n = debug.getupvalue(func, i)
                                    if type(c) == "number" then
                                        if not RapidFireFramework.original[i] then
                                            RapidFireFramework.original[i] = c
                                        end
                                        debug.setupvalue(func, i, RapidFireFramework.enabled and 0.00000000000000000001 or RapidFireFramework.original[i])
                                    end
                                end
                            end
                        end
                    end
                end)
            elseif not state and RapidFireFramework.connection then
                -- Восстанавливаем оригинальные значения
                local tool = g.Character and g.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("GunScript") then
                    for _, connection in ipairs(getconnections(tool.Activated)) do
                        local func = connection.Function
                        if func then
                            local funcInfo = debug.getinfo(func)
                            for i = 1, funcInfo.nups do
                                local c, _n = debug.getupvalue(func, i)
                                if type(c) == "number" and RapidFireFramework.original[i] then
                                    debug.setupvalue(func, i, RapidFireFramework.original[i])
                                end
                            end
                        end
                    end
                end
                
                if RapidFireFramework.connection then
                    RapidFireFramework.connection:Disconnect()
                    RapidFireFramework.connection = nil
                end
                RapidFireFramework.original = {}
            end
        end
        
        _G.RapidFireFramework = RapidFireFramework
    end
    
    do -- Beam Visualization
        local currentBeam = nil
        local beamConnection = nil
        
        local function CreateBeam()
            if currentBeam then
                currentBeam:Destroy()
                currentBeam = nil
            end
            
            local beam = Instance.new("Beam")
            beam.Color = ColorSequence.new(z(255, 0, 0))
            beam.Transparency = NumberSequence.new(0.3)
            beam.Width0 = 0.08
            beam.Width1 = 0.08
            beam.FaceCamera = true
            
            local attachment0 = Instance.new("Attachment")
            local attachment1 = Instance.new("Attachment")
            
            attachment0.Parent = workspace
            attachment1.Parent = workspace
            
            beam.Attachment0 = attachment0
            beam.Attachment1 = attachment1
            beam.Parent = workspace
            
            currentBeam = {beam = beam, att0 = attachment0, att1 = attachment1}
            return currentBeam
        end
        
        local function UpdateBeam()
            if not K.Flags["ShowAimbot"] or not K.Flags["AimbotEnabled"] or not K.Flags["TargetingEnabled"] then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not _G.targeting_state or not _G.targeting_state.current then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not currentBeam then
                currentBeam = CreateBeam()
            end
            
            -- Проверяем наличие оружия с handle
            local tool = _G.TargetingFramework and _G.TargetingFramework.utility and _G.TargetingFramework.utility:getHeld()
            if not tool or tool == "None" or not tool.Handle then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not tool.Handle then return end
            local origin = tool.Handle.Position
            
            local targetPlayer = _G.targeting_state.current
            local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
            if not targetPart then return end
            
            local function GetPredictedPosition(targetPlayer)
                if not targetPlayer or not targetPlayer.Character then return nil end
                
                local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
                if not targetPart then return nil end
                
                -- Получаем актуальные значения из UI
                local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
                local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
                local velocity = targetPart.Velocity or B(0, 0, 0)
                
                -- Используем логику как в примере кода
                local predicted = targetPart.Position + B(
                    velocity.X * xzPrediction,
                    velocity.Y * yPrediction,
                    velocity.Z * xzPrediction
                )
                
                return predicted
            end
            
            local predictedPos = GetPredictedPosition(targetPlayer)
            currentBeam.att0.WorldPosition = origin
            currentBeam.att1.WorldPosition = predictedPos
        end
        
        -- Инициализация beam connection отложена до включения функции
        local function StartBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
            end
            beamConnection = b.Heartbeat:Connect(UpdateBeam)
        end
        
        local function StopBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
                beamConnection = nil
            end
            if currentBeam then
                currentBeam.beam:Destroy()
                currentBeam.att0:Destroy()
                currentBeam.att1:Destroy()
                currentBeam = nil
            end
        end
        
        _G.BeamVisualization = {
            StartBeamVisualization = StartBeamVisualization,
            StopBeamVisualization = StopBeamVisualization,
            cleanup = function()
                StopBeamVisualization()
            end
        }
    end
    
    do -- Hide Framework
        local HideFramework = {}
        local hideConnection = nil
        local isHiding = false
        local isPaused = false
        local lastHideTime = 0
        local hideInterval = 0.1
        
        local function getRandomVoidPosition()
            local x = h() * 5000 - 1000 -- random от -1000 до 1000
            local y = -100000 -- -math.huge
            local z = h() * 5000 - 1000 -- random от -1000 до 1000
            return B(x, y, z)
        end
        
        function HideFramework.start()
            if isHiding then return end
            
            isHiding = true
            K:Notification("Hide enabled", 2, z(128, 0, 128))
            
            hideConnection = b.Heartbeat:Connect(function()
                if not isHiding then
                    if hideConnection then
                        hideConnection:Disconnect()
                        hideConnection = nil
                    end
                    return
                end
                
                -- Проверяем паузу
                if isPaused then
                    -- Просто выходим на паузе, не синхронизируемся
                    return
                end
                
                -- Проверяем флаг
                if not K.Flags["HideEnabled"] then
                    if hideConnection then
                        hideConnection:Disconnect()
                        hideConnection = nil
                    end
                    isHiding = false
                    return
                end
                
                -- Используем десинк для прятания в войде
                if getgenv().DesyncLibrary then
                    local currentTime = os.clock()
                    if currentTime - lastHideTime >= hideInterval then
                        lastHideTime = currentTime
                        local voidPos = getRandomVoidPosition()
                        getgenv().DesyncLibrary.movedesyncto(voidPos.X, voidPos.Y, voidPos.Z)
                    end
                end
            end)
        end
        
        function HideFramework.stop()
            isHiding = false
            isPaused = false
            
            if hideConnection then
                hideConnection:Disconnect()
                hideConnection = nil
            end
            
            -- Синхронизируемся при остановке
            if getgenv().DesyncLibrary then
                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
            end
            
            K:Notification("Hide disabled", 2, z(255, 0, 0))
        end
        
        function HideFramework.pause()
            isPaused = true
        end
        
        function HideFramework.resume()
            isPaused = false
            -- При возобновлении сразу применяем Hide позицию если фреймворк активен
            if isHiding and getgenv().DesyncLibrary then
                local voidPos = getRandomVoidPosition()
                getgenv().DesyncLibrary.movedesyncto(voidPos.X, voidPos.Y, voidPos.Z)
                print("[Hide] Resumed and applied hide position")
            end
        end
        
        function HideFramework.isEnabled()
            return isHiding
        end
        
        function HideFramework.isPaused()
            return isPaused
        end
        
        _G.HideFramework = HideFramework
    end
    
    do -- Auto Stomp Framework
        local AutoStompFramework = {}
        local stompConnection = nil
        local isStomping = false
        local isPaused = false
        local lastStompTime = 0
        local stompInterval = 0.1
        
        local function isPlayerKO(player)
            if not player or not player.Character then return false end
            
            local bodyEffects = player.Character:FindFirstChild("BodyEffects")
            if not bodyEffects then return false end
            
            local ko = bodyEffects:FindFirstChild("K.O")
            if ko and ko.Value == true then return true end
            
            return false
        end
        
        local function performStomp()
            local args = {"Stomp"}
            local mainRemoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("MainRemotes"):WaitForChild("MainRemoteEvent")
            if mainRemoteEvent then
                mainRemoteEvent:FireServer(unpack(args))
            end
        end
        
        function AutoStompFramework.start()
            if isStomping then return end
            
            isStomping = true
            K:Notification("Auto Stomp enabled", 2, z(0, 255, 0))
            
            -- Простой подход с проверкой паузы
            stompConnection = b.Heartbeat:Connect(function()
                if not isStomping then
                    if stompConnection then
                        stompConnection:Disconnect()
                        stompConnection = nil
                    end
                    return
                end
                
                -- Проверяем паузу
                if isPaused then
                    -- Просто выходим на паузе, не синхронизируемся
                    return
                end
                
                local currentTarget = _G.TargetingFramework:GetCurrentTarget()
                
                -- Проверяем приоритет Hide ТОЛЬКО если нет K.O цели
                -- Если есть K.O цель, AutoStomp имеет приоритет над Hide
                if not currentTarget or not currentTarget.Character or not isPlayerKO(currentTarget) then
                    -- Нет K.O цели - Hide может блокировать AutoStomp
                    if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                        return
                    end
                end
                if not currentTarget then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                        -- Ждем немного после синхронизации, затем возобновляем Hide
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and _G.HideFramework.isPaused() then
                            _G.HideFramework.resume()
                        end
                    end
                    return 
                end
                
                if not currentTarget.Character then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                        -- Ждем немного после синхронизации, затем возобновляем Hide
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and _G.HideFramework.isPaused() then
                            _G.HideFramework.resume()
                        end
                    end
                    return 
                end
                
                if not isPlayerKO(currentTarget) then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                        -- Ждем немного после синхронизации, затем возобновляем Hide
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and _G.HideFramework.isPaused() then
                            _G.HideFramework.resume()
                        end
                    end
                    return 
                end
                
                -- Если дошли до сюда - есть K.O цель, приостанавливаем Hide если он активен
                if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                    _G.HideFramework.pause()
                end
                
                local upperTorso = currentTarget.Character:FindFirstChild("UpperTorso")
                if not upperTorso then return end
                
                -- Используем десинк для стомпа
                if getgenv().DesyncLibrary then
                    local pos = upperTorso.Position
                    getgenv().DesyncLibrary.movedesyncto(pos.X, pos.Y + 1, pos.Z)
                    
                    local currentTime = os.clock()
                    if currentTime - lastStompTime >= stompInterval then
                        lastStompTime = currentTime
                        performStomp()
                    end
                end
            end)
        end
        
        function AutoStompFramework.stop()
            isStomping = false
            isPaused = false
            
            if stompConnection then
                stompConnection:Disconnect()
                stompConnection = nil
            end
            
            -- Синхронизируемся при остановке
            if getgenv().DesyncLibrary then
                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
            end
            
            K:Notification("Auto Stomp disabled", 2, z(255, 0, 0))
        end
        
        function AutoStompFramework.pause()
            isPaused = true
        end
        
        function AutoStompFramework.resume()
            isPaused = false
        end
        
        function AutoStompFramework.isEnabled()
            return isStomping
        end
        
        _G.AutoStompFramework = AutoStompFramework
    end

    do -- AutoArmor Framework
        local AutoArmorFramework = {}
        local armorConnection = nil
        local ARMOR_THRESHOLD = 199
        local isBuying = false
        
        local function GetArmorItem()
            local shop = workspace.Ignored and workspace.Ignored.Shop
            if shop then
                local armorItem = shop:FindFirstChild("[Full Armor] - $1659")
                return armorItem
            end
            return nil
        end
        
        local function BuyArmor()
            if not K.Flags["AutoArmorEnabled"] then 
                return 
            end
            if isBuying then 
                print("[AutoArmor] Already buying, skipping")
                return 
            end
            
            local player = g
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                print("[AutoArmor] No character or HumanoidRootPart")
                return
            end
            
            if not player.Character:FindFirstChild("BodyEffects") or 
               not player.Character.BodyEffects:FindFirstChild("Armor") then 
                print("[AutoArmor] No BodyEffects or Armor")
                return
            end
            
            local armorItem = GetArmorItem()
            if not armorItem then 
                print("[AutoArmor] Armor item not found in shop")
                return 
            end
            
            local currentArmor = player.Character.BodyEffects.Armor.Value
            print("[AutoArmor] Current armor:", currentArmor, "Threshold:", ARMOR_THRESHOLD)
            
            if currentArmor > ARMOR_THRESHOLD then 
                return 
            end
            
            print("[AutoArmor] Starting armor purchase, current armor:", currentArmor)
            isBuying = true
            
            -- ОСТАНАВЛИВАЕМ другие фреймворки если они включены (приоритет AutoArmor)
            local wasStompEnabled = false
            local wasHideEnabled = false
            
            if _G.AutoStompFramework and _G.AutoStompFramework.isEnabled() then
                wasStompEnabled = true
                print("[AutoArmor] Pausing AutoStomp")
                _G.AutoStompFramework.pause()
            end
            
            if _G.HideFramework and _G.HideFramework.isEnabled() then
                wasHideEnabled = true
                print("[AutoArmor] Pausing Hide")
                _G.HideFramework.pause()
            end
            
            -- Используем новый desync фреймворк для покупки
            if getgenv().DesyncLibrary then
                K:Notification("[DEBUG] Buying armor, stomp paused: " .. tostring(wasStompEnabled), 3, z(255, 255, 0))
                print("[AutoArmor] Moving to armor shop with desync")
                
                local success, err = pcall(function()
                    -- Перемещаемся к объекту брони через новый desync API
                    getgenv().DesyncLibrary.movedesyncto(armorItem.Head.CFrame)
                    wait(0.3)
                    
                    print("[AutoArmor] Clicking armor detector")
                    -- Покупаем броню
                    fireclickdetector(armorItem.ClickDetector)
                    wait(0.5)
                    
                    print("[AutoArmor] Syncing with player")
                    -- Синхронизируемся с локальным игроком
                    getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                    
                    -- Проверяем, нужно ли восстановить Hide после синхронизации
                    task.wait(0.1) -- Небольшая задержка после синхронизации
                    if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                        local x = h() * 5000 - 1000
                        local y = -100000
                        local z = h() * 5000 - 1000
                        getgenv().DesyncLibrary.movedesyncto(x, y, z)
                        print("[AutoArmor] Restored Hide position after sync")
                    end
                end)
                
                if not success then
                    print("[AutoArmor] Error during purchase:", err)
                    -- В случае ошибки синхронизируемся с локальным игроком
                    pcall(function()
                        getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        
                        -- Проверяем, нужно ли восстановить Hide после синхронизации
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                            local x = h() * 5000 - 1000
                            local y = -100000
                            local z = h() * 5000 - 1000
                            getgenv().DesyncLibrary.movedesyncto(x, y, z)
                            print("[AutoArmor] Restored Hide position after error sync")
                        end
                    end)
                end
                
                -- Проверяем броню после покупки
                wait(0.2)
                local newArmor = player.Character.BodyEffects.Armor.Value
                print("[AutoArmor] Armor after purchase:", newArmor)
                
                if newArmor >= 200 then
                    K:Notification("[DEBUG] Armor bought: " .. newArmor, 3, z(0, 255, 0))
                else
                    K:Notification("[DEBUG] Armor purchase failed: " .. newArmor, 3, z(255, 0, 0))
                end
            else
                print("[AutoArmor] DesyncLibrary not found!")
            end
            
            -- ВОЗОБНОВЛЯЕМ другие фреймворки если они были включены
            if wasHideEnabled and _G.HideFramework then
                print("[AutoArmor] Resuming Hide")
                _G.HideFramework.resume()
            end
            
            if wasStompEnabled and _G.AutoStompFramework then
                print("[AutoArmor] Resuming AutoStomp")
                _G.AutoStompFramework.resume()
                K:Notification("[DEBUG] Frameworks resumed", 2, z(0, 255, 255))
            end
            
            isBuying = false
            print("[AutoArmor] Purchase cycle completed")
        end
        
        local function StartAutoArmor()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
            
            if K.Flags["AutoArmorEnabled"] then
                print("[AutoArmor] Starting AutoArmor framework")
                local lastCheck = 0
                armorConnection = b.Heartbeat:Connect(function()
                    -- Проверяем флаг каждый кадр
                    if not K.Flags["AutoArmorEnabled"] then
                        if armorConnection then
                            armorConnection:Disconnect()
                            armorConnection = nil
                        end
                        return
                    end
                    
                    local currentTime = os.clock()
                    if currentTime - lastCheck >= 1 then
                        lastCheck = currentTime
                        BuyArmor()
                    end
                end)
            end
        end
        
        AutoArmorFramework.start = StartAutoArmor
        AutoArmorFramework.stop = function()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
        end
        
        -- Обработка смерти игрока
        local function OnCharacterRemoving()
            if getgenv().DesyncLibrary then
                pcall(function()
                    getgenv().DesyncLibrary.StopDesync()
                end)
            end
        end
        
        local function OnCharacterAdded(character)
            if character then
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.Died:Connect(OnCharacterRemoving)
                end
            end
        end
        
        -- Подключаем обработчики смерти
        g.CharacterRemoving:Connect(OnCharacterRemoving)
        g.CharacterAdded:Connect(OnCharacterAdded)
        
        -- Если персонаж уже существует
        if g.Character then
            OnCharacterAdded(g.Character)
        end
        
        _G.AutoArmorFramework = AutoArmorFramework
    end
    
    do -- Circle Framework
        local CircleFramework = {
            enabled = false,
            c1 = z(128, 18, 255),
            c2 = z(255, 0, 128),
            c3 = z(0, 200, 255),
            c4 = z(255, 255, 0),
            speed = 1.0,
            radius = 2,
            sides = 48,
            thickness = 2.5,
            line_trs = 1.0,
            y_offset = 0,
            drawings = {},
            conn = nil,
            current_target = nil
        }
        
        local function ensure_lines()
            if #CircleFramework.drawings == CircleFramework.sides then return end
            for _, ln in ipairs(CircleFramework.drawings) do 
                pcall(function() ln:Remove() end) 
            end
            CircleFramework.drawings = {}
            for _ = 1, CircleFramework.sides do
                local ln = Drawing.new("Line")
                ln.ZIndex = 2
                ln.Thickness = CircleFramework.thickness
                ln.Visible = false
                p(CircleFramework.drawings, ln)
            end
        end
        
        local function set_visible_all(v)
            for _, ln in ipairs(CircleFramework.drawings) do 
                ln.Visible = v 
            end
        end
        
        local function cleanup_circle()
            if CircleFramework.conn then 
                CircleFramework.conn:Disconnect()
                CircleFramework.conn = nil 
            end
            for _, ln in ipairs(CircleFramework.drawings) do 
                pcall(function() ln:Remove() end) 
            end
            CircleFramework.drawings = {}
        end
        
        local function update_circle()
            if not CircleFramework.enabled then
                cleanup_circle()
                return
            end
            
            -- Получаем текущую цель из TargetingFramework
            local target_info = _G.TargetingFramework and _G.TargetingFramework._target and _G.TargetingFramework._target.info
            if not target_info or not target_info.player then
                set_visible_all(false)
                return
            end
            
            local target_player = target_info.player
            local char = target_player.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if not (char and root and hum and hum.Health > 0) then
                set_visible_all(false)
                return
            end
            
            ensure_lines()
            
            local pos = root.Position + B(0, CircleFramework.y_offset, 0)
            local root2d, onScreen = cam:WorldToViewportPoint(root.Position)
            if (not onScreen) or root2d.Z <= 0 then
                set_visible_all(false)
                return
            end
            
            local timeNow = tick()
            local tau = math.pi * 2
            
            for i = 1, CircleFramework.sides do
                local ln = CircleFramework.drawings[i]
                local f1 = (i / CircleFramework.sides)
                local a = f1 * tau
                local b = ((i % CircleFramework.sides) + 1) / CircleFramework.sides * tau
                
                local p1 = pos + B(o(a), 0, n(a)) * CircleFramework.radius
                local p2 = pos + B(o(b), 0, n(b)) * CircleFramework.radius
                
                local a2 = cam:WorldToViewportPoint(p1)
                local b2 = cam:WorldToViewportPoint(p2)
                
                local col = _G.TargetingFramework.circle_utility.custom_gradient(
                    f1, timeNow, 
                    CircleFramework.c1, CircleFramework.c2, 
                    CircleFramework.c3, CircleFramework.c4, 
                    CircleFramework.speed
                )
                
                ln.From = Vector2.new(a2.X, a2.Y)
                ln.To = Vector2.new(b2.X, b2.Y)
                ln.Color = col
                ln.Transparency = CircleFramework.line_trs
                ln.Thickness = CircleFramework.thickness
                ln.Visible = true
            end
        end
        
        function CircleFramework:SetEnabled(v)
            self.enabled = v
            if v then
                if not self.conn then
                    self.conn = E.new_connection(b.RenderStepped, update_circle)
                end
            else
                set_visible_all(false)
                cleanup_circle()
            end
        end
        
        function CircleFramework:SetRadius(r) 
            self.radius = r 
        end
        
        function CircleFramework:SetSides(n) 
            self.sides = math.clamp(n, 8, 256)
            ensure_lines() 
        end
        
        function CircleFramework:SetWidth(w) 
            self.thickness = w 
        end
        
        function CircleFramework:SetAlpha(t) 
            self.line_trs = t 
        end
        
        function CircleFramework:SetColors(c1, c2, c3, c4) 
            self.c1 = c1 or self.c1
            self.c2 = c2 or self.c2
            self.c3 = c3 or self.c3
            self.c4 = c4 or self.c4
        end
        
        function CircleFramework:SetYOffset(y) 
            self.y_offset = y 
        end
        
        _G.CircleFramework = CircleFramework
    end
    
    do -- Snapline Framework
        local SnaplineFramework = {
            enabled = false,
            origin = "center", -- bot, top, center, mouse
            color = z(255, 255, 255),
            outline_color = z(0, 0, 0),
            thickness = 1.5,
            outline_thickness = 3.0,
            transparency = 1.0,
            outline_transparency = 1.0,
            line = nil,
            outline_line = nil,
            conn = nil
        }
        
        local function cleanup_snapline()
            if SnaplineFramework.conn then 
                SnaplineFramework.conn:Disconnect()
                SnaplineFramework.conn = nil 
            end
            if SnaplineFramework.line then 
                pcall(function() SnaplineFramework.line:Remove() end)
                SnaplineFramework.line = nil
            end
            if SnaplineFramework.outline_line then 
                pcall(function() SnaplineFramework.outline_line:Remove() end)
                SnaplineFramework.outline_line = nil
            end
        end
        
        local function get_origin_position()
            local origin_pos
            if SnaplineFramework.origin == "bot" then
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y)
            elseif SnaplineFramework.origin == "top" then
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, 0)
            elseif SnaplineFramework.origin == "center" then
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y / 2)
            elseif SnaplineFramework.origin == "mouse" then
                origin_pos = c:GetMouseLocation()
            else
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y / 2)
            end
            return origin_pos
        end
        
        local function update_snapline()
            if not SnaplineFramework.enabled then
                cleanup_snapline()
                return
            end
            
            -- Получаем текущую цель из TargetingFramework
            local target_info = _G.TargetingFramework and _G.TargetingFramework._target and _G.TargetingFramework._target.info
            if not target_info or not target_info.player then
                if SnaplineFramework.line then
                    SnaplineFramework.line.Visible = false
                end
                if SnaplineFramework.outline_line then
                    SnaplineFramework.outline_line.Visible = false
                end
                return
            end
            
            local target_player = target_info.player
            local char = target_player.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if not (char and root and hum and hum.Health > 0) then
                if SnaplineFramework.line then
                    SnaplineFramework.line.Visible = false
                end
                if SnaplineFramework.outline_line then
                    SnaplineFramework.outline_line.Visible = false
                end
                return
            end
            
            -- Создаем outline линию если её нет
            if not SnaplineFramework.outline_line then
                SnaplineFramework.outline_line = Drawing.new("Line")
                SnaplineFramework.outline_line.ZIndex = 0
            end
            
            -- Создаем основную линию если её нет
            if not SnaplineFramework.line then
                SnaplineFramework.line = Drawing.new("Line")
                SnaplineFramework.line.ZIndex = 1
            end
            
            local target_pos, onScreen = cam:WorldToViewportPoint(root.Position)
            if not onScreen or target_pos.Z <= 0 then
                SnaplineFramework.line.Visible = false
                SnaplineFramework.outline_line.Visible = false
                return
            end
            
            local origin_pos = get_origin_position()
            local target_2d = Vector2.new(target_pos.X, target_pos.Y)
            
            -- Настройка outline линии
            SnaplineFramework.outline_line.From = origin_pos
            SnaplineFramework.outline_line.To = target_2d
            SnaplineFramework.outline_line.Color = SnaplineFramework.outline_color
            SnaplineFramework.outline_line.Thickness = SnaplineFramework.outline_thickness
            SnaplineFramework.outline_line.Transparency = SnaplineFramework.outline_transparency
            SnaplineFramework.outline_line.Visible = true
            
            -- Настройка основной линии
            SnaplineFramework.line.From = origin_pos
            SnaplineFramework.line.To = target_2d
            SnaplineFramework.line.Color = SnaplineFramework.color
            SnaplineFramework.line.Thickness = SnaplineFramework.thickness
            SnaplineFramework.line.Transparency = SnaplineFramework.transparency
            SnaplineFramework.line.Visible = true
        end
        
        function SnaplineFramework:SetEnabled(v)
            self.enabled = v
            if v then
                if not self.conn then
                    self.conn = E.new_connection(b.RenderStepped, update_snapline)
                end
            else
                cleanup_snapline()
            end
        end
        
        function SnaplineFramework:SetOrigin(origin)
            self.origin = origin
        end
        
        function SnaplineFramework:SetColor(color)
            self.color = color
        end
        
        function SnaplineFramework:SetThickness(thickness)
            self.thickness = thickness
        end
        
        function SnaplineFramework:SetTransparency(transparency)
            self.transparency = transparency
        end
        
        function SnaplineFramework:SetOutlineColor(color)
            self.outline_color = color
        end
        
        function SnaplineFramework:SetOutlineThickness(thickness)
            self.outline_thickness = thickness
        end
        
        function SnaplineFramework:SetOutlineTransparency(transparency)
            self.outline_transparency = transparency
        end
        
        _G.SnaplineFramework = SnaplineFramework
    end
    
    do -- HitChams Framework
        local HitChamsFramework = {
            enabled = false
        }
        
        function HitChamsFramework:SetEnabled(value)
            self.enabled = value
        end
        
        function HitChamsFramework:TriggerHitChams(player)
            if not self.enabled then return end
            if _G.TargetingFramework and _G.TargetingFramework.utility then
                _G.TargetingFramework.utility:createHitChams(player)
            end
        end
        
        _G.HitChamsFramework = HitChamsFramework
    end
end -- End Ragebot Tab

do -- Visuals Tab
    do -- Target Section
        local targetSection = N:Section({Name = "Target", Side = 1})
        
        -- Target Highlight структура данных
        local bZ = {
            hl = nil,           -- основной highlight объект
            char_added_conn = nil,     -- соединение CharacterAdded
            char_removing_conn = nil,  -- соединение CharacterRemoving
            died_conn = nil,           -- соединение Died
            bound_player = nil,        -- привязанный игрок
            last_char = nil,           -- последний персонаж
        }
        
        -- Функция создания highlight
        local function c0()
            local c1 = Instance.new("Highlight")
            c1.Name = "RB_HL_32v"
            c1.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            return c1
        end
        
        -- Функция очистки highlight
        local function c8()
            if bZ.hl then
                bZ.hl:Destroy()
                bZ.hl = nil
            end
        end
        
        -- Функция применения highlight
        local function ce(a3) -- a3 = character
            if not a3 or not K.Flags or not K.Flags["target_highlight"] then
                c8() -- cleanup
                return
            end
            
            -- Создаем highlight объект если его нет
            if not bZ.hl then
                bZ.hl = c0()
            end
            
            -- Настраиваем основной highlight
            local c1 = bZ.hl
            c1.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            
            -- Получаем цвета и transparency из флагов (как в других колорпикерах скрипта)
            local fillColor = K.Flags["target_highlight_fill"]
            local fillAlpha = K.Flags["target_highlight_fill_alpha"]
            local outlineColor = K.Flags["target_highlight_outline"]
            local outlineAlpha = K.Flags["target_highlight_outline_alpha"]
            
            -- Применяем Fill Color и Transparency
            c1.FillColor = fillColor or z(255, 255, 0)
            c1.FillTransparency = fillAlpha or 0.5
            
            -- Применяем Outline Color и Transparency
            c1.OutlineColor = outlineColor or z(0, 0, 0)
            c1.OutlineTransparency = outlineAlpha or 0.5
            
            c1.Adornee = a3
            c1.Parent = a3
            c1.Enabled = true
            
            bZ.last_char = a3
        end
        
        -- Функция настройки Died connection
        local function cg(a3) -- a3 = character
            if not a3 then return end
            
            local aA = a3:FindFirstChildOfClass("Humanoid")
            if aA then
                if bZ.died_conn then
                    bZ.died_conn:Disconnect()
                end
                
                -- При смерти - убираем визуальный highlight
                bZ.died_conn = aA.Died:Connect(function()
                    c8() -- cleanup highlights
                end)
            end
        end
        
        -- Ключевая функция привязки к игроку
        local function cj(az) -- az = player
            if not az then return end
            
            -- Отключаем старые соединения
            if bZ.char_added_conn then
                bZ.char_added_conn:Disconnect()
            end
            if bZ.char_removing_conn then
                bZ.char_removing_conn:Disconnect()
            end
            
            bZ.bound_player = az
            
            -- При удалении персонажа - очищаем highlight
            bZ.char_removing_conn = az.CharacterRemoving:Connect(function(ck)
                c8() -- cleanup highlights
            end)
            
            -- ВОТ КЛЮЧЕВАЯ ЛОГИКА - при появлении нового персонажа:
            bZ.char_added_conn = az.CharacterAdded:Connect(function(ck)
                if not ck then return end
                
                b.Heartbeat:Wait()
                
                -- ПРОВЕРЯЕМ - является ли этот игрок текущей целью
                local cl = _G.targeting_state and _G.targeting_state.current and
                    (_G.targeting_state.current == az or 
                     (_G.targeting_state.current.UserId and _G.targeting_state.current.UserId == az.UserId))
                
                -- Если да И включен target_highlight - ВОССТАНАВЛИВАЕМ highlight
                if cl and K.Flags and K.Flags["target_highlight"] then
                    ce(ck)  -- применяем highlight к новому персонажу
                    cg(ck)  -- настраиваем died connection
                end
            end)
            
            -- Если у игрока уже есть персонаж - применяем сразу
            if az.Character then
                ce(az.Character)
                cg(az.Character)
            end
        end
        
        -- Тогл для Target Highlight
        local _targetHighlightToggle = targetSection:Toggle({
            Name = "Highlight",
            Default = false,
            Flag = "target_highlight",
            Callback = function(value)
                if value then
                    -- Если включили highlight и есть текущая цель
                    if _G.TargetingFramework and _G.TargetingFramework._target and _G.TargetingFramework._target.info then
                        local targetInfo = _G.TargetingFramework._target.info
                        if targetInfo.player then
                            cj(targetInfo.player)
                        end
                    end
                else
                    -- Если выключили highlight - очищаем все
                    c8()
                    if bZ.char_added_conn then
                        bZ.char_added_conn:Disconnect()
                        bZ.char_added_conn = nil
                    end
                    if bZ.char_removing_conn then
                        bZ.char_removing_conn:Disconnect()
                        bZ.char_removing_conn = nil
                    end
                    if bZ.died_conn then
                        bZ.died_conn:Disconnect()
                        bZ.died_conn = nil
                    end
                end
            end
        })
        
        -- Колорпикер для Fill Color с поддержкой transparency
        _targetHighlightToggle:Colorpicker({
            Name = "Fill Color",
            Default = z(255, 255, 0),
            Alpha = 0.5, -- Включаем слайдер transparency
            Flag = "target_highlight_fill",
            Callback = function(color, alpha)
                -- Сохраняем цвет и alpha отдельно в флаги (как в других колорпикерах)
                K.Flags["target_highlight_fill"] = color
                K.Flags["target_highlight_fill_alpha"] = alpha
                
                -- Обновляем цвет и transparency если highlight активен
                if bZ.hl and bZ.hl.Parent then
                    bZ.hl.FillColor = color
                    bZ.hl.FillTransparency = alpha or 0.5
                end
                -- Пересоздаем highlight с новыми настройками если есть текущая цель
                if bZ.bound_player and bZ.bound_player.Character then
                    ce(bZ.bound_player.Character)
                end
            end
        })
        
        -- Колорпикер для Outline Color с поддержкой transparency
        _targetHighlightToggle:Colorpicker({
            Name = "Outline Color", 
            Default = z(0, 0, 0),
            Alpha = 0.5, -- Включаем слайдер transparency
            Flag = "target_highlight_outline",
            Callback = function(color, alpha)
                -- Сохраняем цвет и alpha отдельно в флаги (как в других колорпикерах)
                K.Flags["target_highlight_outline"] = color
                K.Flags["target_highlight_outline_alpha"] = alpha
                
                -- Обновляем цвет и transparency если highlight активен
                if bZ.hl and bZ.hl.Parent then
                    bZ.hl.OutlineColor = color
                    bZ.hl.OutlineTransparency = alpha or 0.5
                end
                -- Пересоздаем highlight с новыми настройками если есть текущая цель
                if bZ.bound_player and bZ.bound_player.Character then
                    ce(bZ.bound_player.Character)
                end
            end
        })
        
        -- Подключаемся к изменениям цели
        if _G.TargetingFramework then
            _G.TargetingFramework:OnTargetUpdate(function(targetInfo)
                if K.Flags and K.Flags["target_highlight"] then
                    if targetInfo and targetInfo.player then
                        cj(targetInfo.player)
                    else
                        c8()
                    end
                end
            end)
        end
        
        _G.TargetHighlight = {
            bZ = bZ,
            c0 = c0,
            c8 = c8,
            ce = ce,
            cg = cg,
            cj = cj
        }
        
        -- Circle Toggle
        local _targetCircleToggle = targetSection:Toggle({
            Name = "Circle",
            Default = false,
            Flag = "target_circle",
            Callback = function(value)
                if _G.CircleFramework then
                    _G.CircleFramework:SetEnabled(value)
                end
            end
        })
        
        -- Circle Color 1
        _targetCircleToggle:Colorpicker({
            Name = "Color 1",
            Default = z(128, 18, 255),
            Flag = "circle_color1",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c1 = color
                end
            end
        })
        
        -- Circle Color 2
        _targetCircleToggle:Colorpicker({
            Name = "Color 2",
            Default = z(255, 0, 128),
            Flag = "circle_color2",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c2 = color
                end
            end
        })
        
        -- Circle Color 3
        _targetCircleToggle:Colorpicker({
            Name = "Color 3",
            Default = z(0, 200, 255),
            Flag = "circle_color3",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c3 = color
                end
            end
        })
        
        -- Circle Color 4
        _targetCircleToggle:Colorpicker({
            Name = "Color 4",
            Default = z(255, 255, 0),
            Flag = "circle_color4",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c4 = color
                end
            end
        })
        
        -- Snapline Toggle
        local _targetSnaplineToggle = targetSection:Toggle({
            Name = "Snapline",
            Default = false,
            Flag = "target_snapline",
            Callback = function(value)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetEnabled(value)
                end
            end
        })
        
        -- Snapline Origin Dropdown (размещен сразу после Toggle, как в resolver type)
        local _snaplineOriginDropdown = targetSection:Dropdown({
            Name = "Origin",
            Items = {"Bot", "Top", "Center", "Mouse"},
            Default = "Center",
            Flag = "snapline_origin",
            Callback = function(value)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetOrigin(v(value))
                end
            end
        })
        
        -- Snapline Color
        _targetSnaplineToggle:Colorpicker({
            Name = "Color",
            Default = z(255, 255, 255),
            Alpha = 1.0,
            Flag = "snapline_color",
            Callback = function(color, alpha)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetColor(color)
                    _G.SnaplineFramework:SetTransparency(alpha or 1.0)
                end
            end
        })
        
        -- Snapline Outline Color
        _targetSnaplineToggle:Colorpicker({
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 1.0,
            Flag = "snapline_outline_color",
            Callback = function(color, alpha)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetOutlineColor(color)
                    _G.SnaplineFramework:SetOutlineTransparency(alpha or 1.0)
                end
            end
        })
        
    end
    
    do -- OnTargetDamaged Section
        local onTargetDamagedSection = N:Section({Name = "OnTargetDamaged", Side = 1})
        
        -- Chams Toggle
        local _chamsToggle = onTargetDamagedSection:Toggle({
            Name = "Chams",
            Default = false,
            Flag = "hit_chams",
            Callback = function(value)
                if _G.HitChamsFramework then
                    _G.HitChamsFramework:SetEnabled(value)
                end
            end
        })
        
        -- Chams Color Picker
        _chamsToggle:Colorpicker({
            Name = "Color",
            Default = z(255, 0, 0),
            Alpha = 0.0,
            Flag = "hit_chams_color",
            Callback = function(color, alpha)
                -- Сохраняем цвет и прозрачность в флаги
                K.Flags["hit_chams_color"] = color
                K.Flags["hit_chams_alpha"] = alpha
            end
        })
        
        -- Chams Material Dropdown
        local _chamsMaterialDropdown = onTargetDamagedSection:Dropdown({
            Name = "Material",
            Items = {"Neon", "ForceField", "Glass", "SmoothPlastic", "Plastic", "Metal"},
            Default = "Neon",
            Flag = "hit_chams_material",
            Callback = function(value)
                K.Flags["hit_chams_material"] = value
            end
        })
        
        -- HitSounds Toggle
        local _hitSoundsToggle = onTargetDamagedSection:Toggle({
            Name = "HitSounds",
            Default = false,
            Flag = "hit_sounds",
            Callback = function(value)
                -- Создаем папку для звуков при включении
                if value and _G.TargetingFramework and _G.TargetingFramework.utility then
                    _G.TargetingFramework.utility:createSoundsFolder()
                end
            end
        })
        
        -- HitSounds Selection Dropdown
        local _hitSoundsSelectionDropdown = onTargetDamagedSection:Dropdown({
            Name = "Sound",
            Items = availableSounds,
            Default = availableSounds[1] or "1",
            Flag = "hit_sounds_selection",
            Callback = function(value)
                K.Flags["hit_sounds_selection"] = value
            end
        })
        
        -- HitSounds Volume Slider
        local _hitSoundsVolumeSlider = onTargetDamagedSection:Slider({
            Name = "Volume",
            Min = 0,
            Max = 10,
            Default = 0.5,
            Suffix = "",
            Decimals = 0.01,
            Flag = "hit_sounds_volume",
            Callback = function(value)
                K.Flags["hit_sounds_volume"] = value
            end
        })
        
        -- HitSounds Pitch Slider
        local _hitSoundsPitchSlider = onTargetDamagedSection:Slider({
            Name = "Pitch",
            Min = 0.1,
            Max = 3.0,
            Default = 1.0,
            Suffix = "",
            Decimals = 0.01,
            Flag = "hit_sounds_pitch",
            Callback = function(value)
                K.Flags["hit_sounds_pitch"] = value
            end
        })
        
    end
    
    do -- Stuff Section
        local stuffSection = N:Section({Name = "Stuff", Side = 2})
        
        -- Aura utility functions
        local aura_utility = {}
        local aura_state = {
            enabled = false,
            mode = "Lighting",
            attachment = nil,
            particle_emitter = nil,
            flash_emitter = nil,
            -- FrostBlades elements
            beams = {},
            attachments = {},
            particle_emitters = {},
            cleanup_connections = {}
        }
        
        function aura_utility:cleanup()
            -- Отключаем все соединения
            for _, connection in pairs(aura_state.cleanup_connections) do
                if connection then
                    connection:Disconnect()
                end
            end
            aura_state.cleanup_connections = {}
            
            -- Удаляем Lighting элементы
            if aura_state.particle_emitter then
                aura_state.particle_emitter:Destroy()
                aura_state.particle_emitter = nil
            end
            
            if aura_state.flash_emitter then
                aura_state.flash_emitter:Destroy()
                aura_state.flash_emitter = nil
            end
            
            if aura_state.attachment then
                aura_state.attachment:Destroy()
                aura_state.attachment = nil
            end
            
            -- Удаляем FrostBlades элементы
            for _, beam in pairs(aura_state.beams) do
                if beam then
                    beam:Destroy()
                end
            end
            aura_state.beams = {}
            
            for _, attachment in pairs(aura_state.attachments) do
                if attachment then
                    attachment:Destroy()
                end
            end
            aura_state.attachments = {}
            
            for _, emitter in pairs(aura_state.particle_emitters) do
                if emitter then
                    emitter:Destroy()
                end
            end
            aura_state.particle_emitters = {}
        end
        
        function aura_utility:createAura()
            local localPlayer = g
            if not localPlayer or not localPlayer.Character then
                return
            end
            
            local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                return
            end
            
            -- Очищаем предыдущую ауру
            self:cleanup()
            
            -- Получаем accent color
            local accentColor = K.Flags["ThemeAccentColor"]
            if accentColor and accentColor.Color then
                accentColor = accentColor.Color
            elseif not accentColor then
                accentColor = z(31, 226, 130)
            end
            
            -- Создаем ауру в зависимости от режима
            if aura_state.mode == "Lighting" then
                self:createLightingAura(hrp, accentColor)
            elseif aura_state.mode == "FrostBlades" then
                self:createFrostBladesAura(hrp, accentColor)
            elseif aura_state.mode == "Charge" then
                self:createChargeAura(hrp, accentColor)
            elseif aura_state.mode == "Atomic" then
                self:createAtomicAura(hrp, accentColor)
            end
            
            -- Подключаемся к событиям персонажа
            self:setupCharacterEvents(localPlayer)
        end
        
        function aura_utility:createLightingAura(hrp, accentColor)
            -- Создаем RootAttachment
            local rootAttachment = Instance.new("Attachment")
            rootAttachment.Name = "RootAttachment"
            rootAttachment.Axis = B(1, 0, 0)
            rootAttachment.CFrame = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            rootAttachment.Orientation = B(-0, 0, 0)
            rootAttachment.Position = B(0, 0, 0)
            rootAttachment.SecondaryAxis = B(0, 1, 0)
            rootAttachment.Visible = false
            rootAttachment.Parent = hrp
            
            -- Создаем основной ParticleEmitter
            local particleEmitter = Instance.new("ParticleEmitter")
            particleEmitter.Name = "ParticleEmitter"
            particleEmitter.Acceleration = B(0, 0, 0)
            particleEmitter.Brightness = 1
            particleEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            particleEmitter.Drag = 0
            particleEmitter.EmissionDirection = Enum.NormalId.Top
            particleEmitter.Enabled = true
            particleEmitter.FlipbookFramerate = NumberRange.new(20, 20)
            particleEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid2x2
            particleEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            particleEmitter.FlipbookStartRandom = true
            particleEmitter.Lifetime = NumberRange.new(0.15, 0.15)
            particleEmitter.LightEmission = 1
            particleEmitter.LightInfluence = 0
            particleEmitter.LockedToPart = true
            particleEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
            particleEmitter.Rate = 4
            particleEmitter.RotSpeed = NumberRange.new(0, 0)
            particleEmitter.Rotation = NumberRange.new(-180, 180)
            particleEmitter.Shape = Enum.ParticleEmitterShape.Box
            particleEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            particleEmitter.ShapePartial = 1
            particleEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            particleEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 2)}
            particleEmitter.Speed = NumberRange.new(0.01, 0.01)
            particleEmitter.SpreadAngle = Vector2.new(0, 0)
            particleEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            particleEmitter.Texture = "http://www.roblox.com/asset/?id=12800314277"
            particleEmitter.TimeScale = 1
            particleEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            particleEmitter.VelocityInheritance = 0
            particleEmitter.ZOffset = 2
            particleEmitter.Parent = rootAttachment
            
            -- Создаем Flash ParticleEmitter
            local flashEmitter = Instance.new("ParticleEmitter")
            flashEmitter.Name = "Flash"
            flashEmitter.Acceleration = B(0, 0, 0)
            flashEmitter.Brightness = 1
            flashEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            flashEmitter.Drag = 0
            flashEmitter.EmissionDirection = Enum.NormalId.Top
            flashEmitter.Enabled = true
            flashEmitter.FlipbookFramerate = NumberRange.new(20, 20)
            flashEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
            flashEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            flashEmitter.FlipbookStartRandom = false
            flashEmitter.Lifetime = NumberRange.new(0.3, 0.6)
            flashEmitter.LightEmission = 0
            flashEmitter.LightInfluence = 0
            flashEmitter.LockedToPart = true
            flashEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
            flashEmitter.Rate = 3
            flashEmitter.RotSpeed = NumberRange.new(0, 0)
            flashEmitter.Rotation = NumberRange.new(-360, 360)
            flashEmitter.Shape = Enum.ParticleEmitterShape.Box
            flashEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            flashEmitter.ShapePartial = 1
            flashEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            flashEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 2)}
            flashEmitter.Speed = NumberRange.new(0, 0)
            flashEmitter.SpreadAngle = Vector2.new(-360, 360)
            flashEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            flashEmitter.Texture = "rbxassetid://11372587580"
            flashEmitter.TimeScale = 1
            flashEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            flashEmitter.VelocityInheritance = 0
            flashEmitter.ZOffset = 1
            flashEmitter.Parent = rootAttachment
            
            -- Сохраняем ссылки
            aura_state.attachment = rootAttachment
            aura_state.particle_emitter = particleEmitter
            aura_state.flash_emitter = flashEmitter
        end
        
        function aura_utility:createFrostBladesAura(hrp, accentColor)
            local attachments = {}
            local beams = {}
            local emitters = {}
            
            -- Создаем RootAttachment
            local rootAttachment = Instance.new("Attachment")
            rootAttachment.Name = "RootAttachment"
            rootAttachment.Axis = B(1, 0, 0)
            rootAttachment.CFrame = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            rootAttachment.Orientation = B(-0, 0, 0)
            rootAttachment.Position = B(0, 0, 0)
            rootAttachment.SecondaryAxis = B(0, 1, 0)
            rootAttachment.Visible = false
            rootAttachment.Parent = hrp
            p(attachments, rootAttachment)
            
            -- Создаем bottom attachment
            local bottomAttachment = Instance.new("Attachment")
            bottomAttachment.Name = "bottom"
            bottomAttachment.Axis = B(1, 0, 0)
            bottomAttachment.CFrame = C(0, -3, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            bottomAttachment.Orientation = B(-0, 0, 0)
            bottomAttachment.Position = B(0, -3, 0)
            bottomAttachment.SecondaryAxis = B(0, 1, 0)
            bottomAttachment.Visible = false
            bottomAttachment.Parent = hrp
            p(attachments, bottomAttachment)
            
            -- Создаем whirl ParticleEmitter на bottom
            local whirlEmitter = Instance.new("ParticleEmitter")
            whirlEmitter.Name = "whirl"
            whirlEmitter.Acceleration = B(0, 0, 0)
            whirlEmitter.Brightness = 5.199999809265137
            whirlEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            whirlEmitter.Drag = 0
            whirlEmitter.EmissionDirection = Enum.NormalId.Top
            whirlEmitter.Enabled = true
            whirlEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            whirlEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            whirlEmitter.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            whirlEmitter.FlipbookStartRandom = false
            whirlEmitter.Lifetime = NumberRange.new(2, 2)
            whirlEmitter.LightEmission = 0.15000000596046448
            whirlEmitter.LightInfluence = 0
            whirlEmitter.LockedToPart = true
            whirlEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            whirlEmitter.Rate = 2
            whirlEmitter.RotSpeed = NumberRange.new(400, 400)
            whirlEmitter.Rotation = NumberRange.new(0, 90)
            whirlEmitter.Shape = Enum.ParticleEmitterShape.Box
            whirlEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            whirlEmitter.ShapePartial = 1
            whirlEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            whirlEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 3)}
            whirlEmitter.Speed = NumberRange.new(1.5, 1.5)
            whirlEmitter.SpreadAngle = Vector2.new(5, 5)
            whirlEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            whirlEmitter.Texture = "rbxassetid://9098555411"
            whirlEmitter.TimeScale = 1
            whirlEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.153906, 0), NumberSequenceKeypoint.new(0.847641, 0), NumberSequenceKeypoint.new(1, 1)}
            whirlEmitter.VelocityInheritance = 0
            whirlEmitter.ZOffset = 0
            whirlEmitter.Parent = bottomAttachment
            p(emitters, whirlEmitter)
            
            -- Создаем specs ParticleEmitter на bottom
            local specsEmitter = Instance.new("ParticleEmitter")
            specsEmitter.Name = "specs"
            specsEmitter.Acceleration = B(0, 3, 0)
            specsEmitter.Brightness = 10
            specsEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            specsEmitter.Drag = 0
            specsEmitter.EmissionDirection = Enum.NormalId.Top
            specsEmitter.Enabled = true
            specsEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            specsEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            specsEmitter.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            specsEmitter.FlipbookStartRandom = false
            specsEmitter.Lifetime = NumberRange.new(1.5, 1.8)
            specsEmitter.LightEmission = 1
            specsEmitter.LightInfluence = 0
            specsEmitter.LockedToPart = true
            specsEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
            specsEmitter.Rate = 20
            specsEmitter.RotSpeed = NumberRange.new(1000, 1000)
            specsEmitter.Rotation = NumberRange.new(0, 0)
            specsEmitter.Shape = Enum.ParticleEmitterShape.Box
            specsEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            specsEmitter.ShapePartial = 1
            specsEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            specsEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.1), NumberSequenceKeypoint.new(0.594, 0.1), NumberSequenceKeypoint.new(1, 0)}
            specsEmitter.Speed = NumberRange.new(3, 3)
            specsEmitter.SpreadAngle = Vector2.new(90, 90)
            specsEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            specsEmitter.Texture = "rbxasset://textures/particles/sparkles_main.dds"
            specsEmitter.TimeScale = 1
            specsEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.160866, 1), NumberSequenceKeypoint.new(0.167827, 0), NumberSequenceKeypoint.new(1, 0)}
            specsEmitter.VelocityInheritance = 0
            specsEmitter.ZOffset = 0
            specsEmitter.Parent = bottomAttachment
            p(emitters, specsEmitter)
            
            -- Создаем en attachments (5 штук)
            local enAttachments = {}
            local enPositions = {
                {-3.5, 3.5, -2.5},
                {-4.5, 2, 3},
                {-0.0999984741, 4, 3.19999695},
                {3.89999771, 4.79999971, 2},
                {3.29999924, 2.79999971, -2.19999695}
            }
            
            for i = 1, 5 do
                local pos = enPositions[i]
                local enAttachment = Instance.new("Attachment")
                enAttachment.Name = "en" .. i
                enAttachment.Axis = B(0, 0, -1)
                enAttachment.CFrame = C(pos[1], pos[2], pos[3], 0, 0, 1, 0, 1, -0, -1, 0, 0)
                enAttachment.Orientation = B(-0, 90, 0)
                enAttachment.Position = B(pos[1], pos[2], pos[3])
                enAttachment.SecondaryAxis = B(0, 1, 0)
                enAttachment.Visible = false
                enAttachment.Parent = hrp
                p(attachments, enAttachment)
                enAttachments[i] = enAttachment
            end
            
            -- Создаем st attachments (5 штук)
            local stAttachments = {}
            local stPositions = {
                {-1.49996948, -2.99999428, -0.999954224},
                {-1.5, -3, 1},
                {0.299999237, -3, 1.79999542},
                {2.09999847, -3, 0.399993896},
                {1.29999924, -3, -1.40000916}
            }
            
            for i = 1, 5 do
                local pos = stPositions[i]
                local stAttachment = Instance.new("Attachment")
                stAttachment.Name = "st" .. i
                stAttachment.Axis = B(0, 0, -1)
                stAttachment.CFrame = C(pos[1], pos[2], pos[3], 0, 0, 1, 0, 1, -0, -1, 0, 0)
                stAttachment.Orientation = B(-0, 90, 0)
                stAttachment.Position = B(pos[1], pos[2], pos[3])
                stAttachment.SecondaryAxis = B(0, 1, 0)
                stAttachment.Visible = false
                stAttachment.Parent = hrp
                p(attachments, stAttachment)
                stAttachments[i] = stAttachment
            end
            
            -- Создаем end1 и start1 attachments
            local endAttachment = Instance.new("Attachment")
            endAttachment.Name = "end1"
            endAttachment.Axis = B(0, -1, 0)
            endAttachment.CFrame = C(0, -2.88535929, -3.5, 0, -1, -4.37113883e-08, -1, 0, -0, 0, 4.37113883e-08, -1)
            endAttachment.Orientation = B(-0, -179.99998474121094, -90)
            endAttachment.Position = B(0, -2.885359287261963, -3.5)
            endAttachment.SecondaryAxis = B(-1, -4.371138828673793e-08, 1.5099580252808664e-07)
            endAttachment.Visible = false
            endAttachment.Parent = hrp
            p(attachments, endAttachment)
            
            local startAttachment = Instance.new("Attachment")
            startAttachment.Name = "start1"
            startAttachment.Axis = B(0, -1, 0)
            startAttachment.CFrame = C(0, -2.88535929, 3.5, 0, -1, -4.37113883e-08, -1, 0, -0, 0, 4.37113883e-08, -1)
            startAttachment.Orientation = B(-0, -179.99998474121094, -90)
            startAttachment.Position = B(0, -2.885359287261963, 3.5)
            startAttachment.SecondaryAxis = B(-1, -4.371138828673793e-08, 1.5099580252808664e-07)
            startAttachment.Visible = false
            startAttachment.Parent = hrp
            p(attachments, startAttachment)
            
            -- Создаем blade beams (5 штук)
            for i = 1, 5 do
                local bladeBeam = Instance.new("Beam")
                bladeBeam.Name = "blade" .. i
                bladeBeam.Attachment0 = enAttachments[i]
                bladeBeam.Attachment1 = stAttachments[i]
                bladeBeam.Brightness = 1
                bladeBeam.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, accentColor),
                    ColorSequenceKeypoint.new(1, accentColor)
                }
                bladeBeam.CurveSize0 = 0
                bladeBeam.CurveSize1 = 0
                bladeBeam.Enabled = true
                bladeBeam.FaceCamera = true
                bladeBeam.LightEmission = 1
                bladeBeam.LightInfluence = 1
                bladeBeam.Segments = 10
                bladeBeam.Texture = "rbxassetid://14050932611"
                bladeBeam.TextureLength = 1
                bladeBeam.TextureMode = Enum.TextureMode.Stretch
                bladeBeam.TextureSpeed = 0
                bladeBeam.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
                bladeBeam.Width0 = 0
                bladeBeam.Width1 = 8
                bladeBeam.ZOffset = 0
                bladeBeam.Parent = hrp
                p(beams, bladeBeam)
            end
            
            -- Создаем energy beams (5 штук)
            for i = 1, 5 do
                local energyBeam = Instance.new("Beam")
                energyBeam.Name = "energy" .. i
                energyBeam.Attachment0 = stAttachments[i]
                energyBeam.Attachment1 = enAttachments[i]
                energyBeam.Brightness = 6.534999847412109
                energyBeam.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, accentColor),
                    ColorSequenceKeypoint.new(1, accentColor)
                }
                energyBeam.CurveSize0 = 0
                energyBeam.CurveSize1 = 0
                energyBeam.Enabled = true
                energyBeam.FaceCamera = true
                energyBeam.LightEmission = 1
                energyBeam.LightInfluence = 0
                energyBeam.Segments = 10
                energyBeam.Texture = "http://www.roblox.com/asset/?id=6365212829"
                energyBeam.TextureLength = 10
                energyBeam.TextureMode = Enum.TextureMode.Static
                energyBeam.TextureSpeed = 1
                energyBeam.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.845321, 0.01875), NumberSequenceKeypoint.new(0.887858, 1), NumberSequenceKeypoint.new(1, 1)}
                energyBeam.Width0 = 0.5
                energyBeam.Width1 = 0.5
                energyBeam.ZOffset = 0.10000000149011612
                energyBeam.Parent = hrp
                p(beams, energyBeam)
            end
            
            -- Создаем glow beam
            local glowBeam = Instance.new("Beam")
            glowBeam.Name = "glow"
            glowBeam.Attachment0 = endAttachment
            glowBeam.Attachment1 = startAttachment
            glowBeam.Brightness = 2.265000104904175
            glowBeam.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            glowBeam.CurveSize0 = 0
            glowBeam.CurveSize1 = 0
            glowBeam.Enabled = true
            glowBeam.FaceCamera = false
            glowBeam.LightEmission = 1
            glowBeam.LightInfluence = 0
            glowBeam.Segments = 10
            glowBeam.Texture = "http://www.roblox.com/asset/?id=4464710465"
            glowBeam.TextureLength = 1
            glowBeam.TextureMode = Enum.TextureMode.Stretch
            glowBeam.TextureSpeed = 0
            glowBeam.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 0.5)}
            glowBeam.Width0 = 8
            glowBeam.Width1 = 8
            glowBeam.ZOffset = 0
            glowBeam.Parent = hrp
            p(beams, glowBeam)
            
            -- Сохраняем ссылки
            aura_state.attachments = attachments
            aura_state.beams = beams
            aura_state.particle_emitters = emitters
        end
        
        function aura_utility:createChargeAura(hrp, accentColor)
            local attachments = {}
            local emitters = {}
            
            -- Создаем Main attachment
            local mainAttachment = Instance.new("Attachment")
            mainAttachment.Name = "Main"
            mainAttachment.Axis = B(1, 0, 0)
            mainAttachment.CFrame = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            mainAttachment.Orientation = B(-0, 0, 0)
            mainAttachment.Position = B(0, 0, 0)
            mainAttachment.SecondaryAxis = B(0, 1, 0)
            mainAttachment.Visible = false
            mainAttachment.Parent = hrp
            p(attachments, mainAttachment)
            
            -- Создаем Energy1 ParticleEmitter
            local energy1Emitter = Instance.new("ParticleEmitter")
            energy1Emitter.Name = "Energy1"
            energy1Emitter.Acceleration = B(0, 0, 0)
            energy1Emitter.Brightness = 25
            energy1Emitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            energy1Emitter.Drag = 0
            energy1Emitter.EmissionDirection = Enum.NormalId.Top
            energy1Emitter.Enabled = true
            energy1Emitter.FlipbookFramerate = NumberRange.new(1, 1)
            energy1Emitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
            energy1Emitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            energy1Emitter.FlipbookStartRandom = false
            energy1Emitter.Lifetime = NumberRange.new(0.3, 0.3)
            energy1Emitter.LightEmission = 1
            energy1Emitter.LightInfluence = 0
            energy1Emitter.LockedToPart = true
            energy1Emitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            energy1Emitter.Rate = 20
            energy1Emitter.RotSpeed = NumberRange.new(0, 0)
            energy1Emitter.Rotation = NumberRange.new(-360, 360)
            energy1Emitter.Shape = Enum.ParticleEmitterShape.Box
            energy1Emitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            energy1Emitter.ShapePartial = 1
            energy1Emitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            energy1Emitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 5), NumberSequenceKeypoint.new(1, 5)}
            energy1Emitter.Speed = NumberRange.new(0.001, 0.001)
            energy1Emitter.SpreadAngle = Vector2.new(75, 75)
            energy1Emitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy1Emitter.Texture = "rbxassetid://15041986621"
            energy1Emitter.TimeScale = 1
            energy1Emitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy1Emitter.VelocityInheritance = 0
            energy1Emitter.ZOffset = 1
            energy1Emitter.Parent = mainAttachment
            p(emitters, energy1Emitter)
            
            -- Создаем Energy2 ParticleEmitter
            local energy2Emitter = Instance.new("ParticleEmitter")
            energy2Emitter.Name = "Energy2"
            energy2Emitter.Acceleration = B(0, 0, 0)
            energy2Emitter.Brightness = 25
            energy2Emitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            energy2Emitter.Drag = 0
            energy2Emitter.EmissionDirection = Enum.NormalId.Top
            energy2Emitter.Enabled = true
            energy2Emitter.FlipbookFramerate = NumberRange.new(1, 1)
            energy2Emitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
            energy2Emitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            energy2Emitter.FlipbookStartRandom = false
            energy2Emitter.Lifetime = NumberRange.new(0.3, 0.3)
            energy2Emitter.LightEmission = 1
            energy2Emitter.LightInfluence = 0
            energy2Emitter.LockedToPart = true
            energy2Emitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            energy2Emitter.Rate = 20
            energy2Emitter.RotSpeed = NumberRange.new(0, 0)
            energy2Emitter.Rotation = NumberRange.new(-360, 360)
            energy2Emitter.Shape = Enum.ParticleEmitterShape.Box
            energy2Emitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            energy2Emitter.ShapePartial = 1
            energy2Emitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            energy2Emitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 5), NumberSequenceKeypoint.new(1, 5)}
            energy2Emitter.Speed = NumberRange.new(0.001, 0.001)
            energy2Emitter.SpreadAngle = Vector2.new(75, 75)
            energy2Emitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy2Emitter.Texture = "rbxassetid://15041986460"
            energy2Emitter.TimeScale = 1
            energy2Emitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy2Emitter.VelocityInheritance = 0
            energy2Emitter.ZOffset = 1
            energy2Emitter.Parent = mainAttachment
            p(emitters, energy2Emitter)
            
            -- Сохраняем ссылки
            aura_state.attachments = attachments
            aura_state.beams = {}
            aura_state.particle_emitters = emitters
        end
        
        function aura_utility:createAtomicAura(hrp, accentColor)
            local attachments = {}
            local emitters = {}
            
            -- Создаем Attachment для BlackSwirl
            local atomicAttachment = Instance.new("Attachment")
            atomicAttachment.Name = "AtomicAttachment"
            atomicAttachment.Parent = hrp
            p(attachments, atomicAttachment)
            
            -- Создаем BlackSwirl ParticleEmitter
            local blackSwirl = Instance.new("ParticleEmitter")
            blackSwirl.Name = "BlackSwirl"
            blackSwirl.Acceleration = B(0, 0, 0)
            blackSwirl.Brightness = 1
            blackSwirl.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            blackSwirl.Drag = 0
            blackSwirl.EmissionDirection = Enum.NormalId.Top
            blackSwirl.Enabled = true
            blackSwirl.FlipbookFramerate = NumberRange.new(1, 1)
            blackSwirl.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            blackSwirl.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            blackSwirl.FlipbookStartRandom = false
            blackSwirl.Lifetime = NumberRange.new(3, 3)
            blackSwirl.LightEmission = 1
            blackSwirl.LightInfluence = 0
            blackSwirl.LockedToPart = true
            blackSwirl.Orientation = Enum.ParticleOrientation.VelocityParallel
            blackSwirl.Rate = 5
            blackSwirl.RotSpeed = NumberRange.new(360, 360)
            blackSwirl.Rotation = NumberRange.new(-180, 180)
            blackSwirl.Shape = Enum.ParticleEmitterShape.Box
            blackSwirl.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            blackSwirl.ShapePartial = 1
            blackSwirl.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            blackSwirl.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 4), NumberSequenceKeypoint.new(1, 4)}
            blackSwirl.Speed = NumberRange.new(0.01, 0.01)
            blackSwirl.SpreadAngle = Vector2.new(360, -360)
            blackSwirl.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            blackSwirl.Texture = "rbxassetid://10558425570"
            blackSwirl.TimeScale = 1
            blackSwirl.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            blackSwirl.VelocityInheritance = 0
            blackSwirl.ZOffset = 0.2
            blackSwirl.Parent = atomicAttachment
            p(emitters, blackSwirl)
            
            -- Сохраняем ссылки
            aura_state.attachments = attachments
            aura_state.beams = {}
            aura_state.particle_emitters = emitters
        end
        
        function aura_utility:setupCharacterEvents(localPlayer)
            -- Подключаемся к событию смерти персонажа
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local diedConnection = humanoid.Died:Connect(function()
                    self:cleanup()
                end)
                p(aura_state.cleanup_connections, diedConnection)
            end
            
            -- Подключаемся к событию удаления персонажа
            local charRemovingConnection = localPlayer.CharacterRemoving:Connect(function()
                self:cleanup()
            end)
            p(aura_state.cleanup_connections, charRemovingConnection)
            
            -- Подключаемся к событию появления нового персонажа
            local charAddedConnection = localPlayer.CharacterAdded:Connect(function()
                if aura_state.enabled then
                    -- Ждем пока персонаж полностью загрузится
                    wait(0.1)
                    self:createAura()
                end
            end)
            p(aura_state.cleanup_connections, charAddedConnection)
        end
        
        function aura_utility:setEnabled(enabled)
            aura_state.enabled = enabled
            
            if enabled then
                self:createAura()
            else
                self:cleanup()
            end
        end
        
        function aura_utility:setMode(mode)
            aura_state.mode = mode
            
            -- Если аура включена, пересоздаем ее с новым режимом
            if aura_state.enabled then
                self:createAura()
            end
        end
        
        function aura_utility:updateColor(newColor)
            if aura_state.mode == "Lighting" then
                -- Обновляем цвета для Lighting режима
                if aura_state.particle_emitter then
                    aura_state.particle_emitter.Color = ColorSequence.new{
                        ColorSequenceKeypoint.new(0, newColor),
                        ColorSequenceKeypoint.new(1, newColor)
                    }
                end
                
                if aura_state.flash_emitter then
                    aura_state.flash_emitter.Color = ColorSequence.new{
                        ColorSequenceKeypoint.new(0, newColor),
                        ColorSequenceKeypoint.new(1, newColor)
                    }
                end
            elseif aura_state.mode == "FrostBlades" then
                -- Обновляем цвета для FrostBlades режима
                for _, beam in pairs(aura_state.beams) do
                    if beam then
                        beam.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
                
                for _, emitter in pairs(aura_state.particle_emitters) do
                    if emitter then
                        emitter.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
            elseif aura_state.mode == "Charge" then
                -- Обновляем цвета для Charge режима
                for _, emitter in pairs(aura_state.particle_emitters) do
                    if emitter then
                        emitter.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
            elseif aura_state.mode == "Atomic" then
                -- Обновляем цвета для Atomic режима
                for _, emitter in pairs(aura_state.particle_emitters) do
                    if emitter then
                        emitter.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
            end
        end
        
        -- Aura Toggle
        local _auraToggle = stuffSection:Toggle({
            Name = "Aura",
            Default = false,
            Flag = "aura_enabled",
            Callback = function(value)
                aura_utility:setEnabled(value)
            end
        })
        
        -- Aura Mode Dropdown
        local _auraMode = stuffSection:Dropdown({
            Name = "Aura Mode",
            Items = {"Lighting", "FrostBlades", "Charge", "Atomic"},
            Default = "Lighting",
            Flag = "aura_mode",
            Callback = function(value)
                aura_state.mode = value
                -- Если аура включена, пересоздаем её с новым режимом
                if aura_state.enabled then
                    aura_utility:setEnabled(false)
                    task.wait(0.1)
                    aura_utility:setEnabled(true)
                end
            end
        })
        
        -- Сохраняем в глобальную область для доступа из других частей кода
        _G.AuraUtility = aura_utility
        
        -- Halo (Нимб) система
        local halo_state = {
            enabled = false,
            color = z(255, 225, 0), -- Золотой цвет по умолчанию
            attachment = nil,
            particle_emitter = nil,
            cleanup_connections = {}
        }
        
        local halo_utility = {}
        
        function halo_utility:cleanup()
            -- Удаляем attachment и particle emitter
            if halo_state.attachment then
                halo_state.attachment:Destroy()
                halo_state.attachment = nil
            end
            
            if halo_state.particle_emitter then
                halo_state.particle_emitter:Destroy()
                halo_state.particle_emitter = nil
            end
            
            -- Отключаем все подключения
            for _, connection in pairs(halo_state.cleanup_connections) do
                if connection then
                    connection:Disconnect()
                end
            end
            halo_state.cleanup_connections = {}
        end
        
        function halo_utility:createHalo()
            local localPlayer = g
            if not localPlayer.Character then
                return
            end
            
            local head = localPlayer.Character:FindFirstChild("Head")
            if not head then
                return
            end
            
            -- Очищаем предыдущий нимб
            self:cleanup()
            
            -- Создаем Attachment для нимба
            local haloAttachment = Instance.new("Attachment")
            haloAttachment.Name = "HaloAttachment"
            haloAttachment.Position = B(0, 1.4, 0) -- Позиция над головой
            haloAttachment.Orientation = B(0, 0, 7) -- Наклон на 6 градусов
            haloAttachment.Parent = head
            halo_state.attachment = haloAttachment
            
            -- Создаем ParticleEmitter для нимба
            local haloEmitter = Instance.new("ParticleEmitter")
            haloEmitter.Name = "Halo"
            haloEmitter.Acceleration = B(0, 0, 0)
            haloEmitter.Brightness = 1
            haloEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, halo_state.color),
                ColorSequenceKeypoint.new(1, halo_state.color)
            }
            haloEmitter.Drag = 0
            haloEmitter.EmissionDirection = Enum.NormalId.Top
            haloEmitter.Enabled = true
            haloEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            haloEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            haloEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            haloEmitter.FlipbookStartRandom = false
            haloEmitter.Lifetime = NumberRange.new(1.5, 1.5)
            haloEmitter.LightEmission = 1
            haloEmitter.LightInfluence = 0
            haloEmitter.LockedToPart = true
            haloEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            haloEmitter.Rate = 3
            haloEmitter.RotSpeed = NumberRange.new(-360, -360)
            haloEmitter.Rotation = NumberRange.new(-360, 360)
            haloEmitter.Shape = Enum.ParticleEmitterShape.Box
            haloEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            haloEmitter.ShapePartial = 1
            haloEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            haloEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2.6), NumberSequenceKeypoint.new(1, 2.6)}
            haloEmitter.Speed = NumberRange.new(0.001, 0.001)
            haloEmitter.SpreadAngle = Vector2.new(3, 2)
            haloEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.01), NumberSequenceKeypoint.new(1, 0.01)}
            haloEmitter.Texture = "rbxassetid://7185003058"
            haloEmitter.TimeScale = 1
            haloEmitter.Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.293, 0),
                NumberSequenceKeypoint.new(0.497, 0),
                NumberSequenceKeypoint.new(0.701, 0),
                NumberSequenceKeypoint.new(1, 1)
            }
            haloEmitter.VelocityInheritance = 0
            haloEmitter.ZOffset = 0
            haloEmitter.Parent = haloAttachment
            halo_state.particle_emitter = haloEmitter
            
            -- Подключаемся к событиям персонажа
            self:setupCharacterEvents(localPlayer)
        end
        
        function halo_utility:setupCharacterEvents(localPlayer)
            -- Подключаемся к событию смерти персонажа
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local diedConnection = humanoid.Died:Connect(function()
                    self:cleanup()
                end)
                table.insert(halo_state.cleanup_connections, diedConnection)
            end
            
            -- Подключаемся к событию удаления персонажа
            local charRemovingConnection = localPlayer.CharacterRemoving:Connect(function()
                self:cleanup()
            end)
            table.insert(halo_state.cleanup_connections, charRemovingConnection)
            
            -- Подключаемся к событию появления нового персонажа
            local charAddedConnection = localPlayer.CharacterAdded:Connect(function()
                if halo_state.enabled then
                    -- Ждем пока персонаж полностью загрузится
                    wait(0.1)
                    self:createHalo()
                end
            end)
            table.insert(halo_state.cleanup_connections, charAddedConnection)
        end
        
        function halo_utility:setEnabled(enabled)
            halo_state.enabled = enabled
            
            if enabled then
                self:createHalo()
            else
                self:cleanup()
            end
        end
        
        function halo_utility:updateColor(newColor)
            halo_state.color = newColor
            
            -- Обновляем цвет существующего нимба
            if halo_state.particle_emitter then
                halo_state.particle_emitter.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, newColor),
                    ColorSequenceKeypoint.new(1, newColor)
                }
            end
        end
        
        -- Halo Toggle
        local haloToggle = stuffSection:Toggle({
            Name = "Halo",
            Default = false,
            Flag = "halo_enabled",
            Callback = function(value)
                halo_utility:setEnabled(value)
            end
        })
        
        -- Halo Colorpicker
        haloToggle:Colorpicker({
            Name = "Halo Color",
            Default = z(255, 225, 0), -- Золотой цвет по умолчанию
            Flag = "halo_color",
            Callback = function(value)
                halo_utility:updateColor(value)
            end
        })
        
        -- Сохраняем в глобальную область для доступа из других частей кода
        _G.HaloUtility = halo_utility
        
    end
end -- End Visuals Tab

do -- Watermark & Keybinds
    local Q = K:Watermark("Fentanyl | " .. g.Name .. " | " .. os.date("%y.%m.%d") .. " | Premium")
    local R = K:KeybindList()
    if Q then
        Q:SetVisibility(false)
    end
    if R then
        R:SetVisibility(false)
    end
    _G.Watermark = Q
    _G.KeybindList = R
end
do -- Settings Tab
    local S = L:Page({Name = "Settings", Columns = 2})
    local T = S:Section({Name = "Config", Side = 1})
    local U = ""
    local V = ""
    local _W = {}
    do
        if not isfolder("fentanyl") then
            makefolder("fentanyl")
        end
        if not isfolder("fentanyl/Configs") then
            makefolder("fentanyl/Configs")
        end
    end
    local function X()
        local configList = {}
        if isfolder("fentanyl/Configs") then
            for J, Y in ipairs(listfiles("fentanyl/Configs")) do
                local Z = Y:gsub("\\", "/")
                Z = Z:gsub("fentanyl/Configs/", "")
                p(configList, Z)
            end
        end
        return configList
    end
    local _ =
        T:Listbox(
        {Name = "Select Config", Items = X(), Default = "", Flag = "SelectedConfig", Callback = function(a0)
                U = a0
                print("Selected config:", a0)
            end}
    )
    local a1 =
        T:Textbox(
        {Name = "", Default = "", Placeholder = "Enter config name...", Flag = "ConfigName", Callback = function(a0)
                V = a0
            end}
    )
    local a2 =
        T:Button(
        {Name = "Create Config", Callback = function()
                if V and V ~= "" then
                    local a3 = V:gsub("%.json$", "") .. ".json"
                    local a4 = "fentanyl/Configs/" .. a3
                    if not isfile(a4) then
                        local a5 = K:GetConfig()
                        writefile(a4, a5)
                        K:Notification("Config created: " .. a3, 3, z(0, 255, 0))
                        _:Refresh(X())
                    else
                        K:Notification("Config already exists: " .. a3, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a6 =
        T:Button(
        {Name = "Save Config", Callback = function()
                local a3
                if U and U ~= "" then
                    a3 = U
                elseif V and V ~= "" then
                    a3 = V:gsub("%.json$", "") .. ".json"
                end
                if a3 then
                    local a4 = "fentanyl/Configs/" .. a3
                    local a5 = K:GetConfig()
                    writefile(a4, a5)
                    K:Notification("Config saved: " .. a3, 3, z(0, 255, 0))
                    _:Refresh(X())
                else
                    K:Notification("Please select or enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a7 =
        T:Button(
        {Name = "Load Config", Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    if isfile(a4) then
                        local a5 = readfile(a4)
                        K:LoadConfig(a5)
                        K:Notification("Config loaded: " .. U, 3, z(0, 255, 0))
                    else
                        K:Notification("Config not found: " .. U, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a8 =
        T:Button(
        {Name = "Delete Config", Risky = true, Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    print("Trying to delete config at path:", a4)
                    print("File exists:", isfile(a4))
                    if isfile(a4) then
                        delfile(a4)
                        K:Notification("Config deleted: " .. U, 3, z(0, 255, 0))
                        _:Refresh(X())
                        U = ""
                    else
                        K:Notification("Config not found: " .. a4, 5, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a9 =
        T:Button(
        {Name = "Refresh Config List", Callback = function()
                _:Refresh(X())
                K:Notification("Config list refreshed", 2, z(0, 255, 0))
            end}
    )
    local aa = S:Section({Name = "Theming", Side = 2})
    local ab = aa:Label("Accent Color", "Left")
    local ac =
        ab:Colorpicker(
        {
            Name = "Accent Color",
            Default = z(31, 226, 130),
            Alpha = 1,
            Flag = "ThemeAccentColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Accent", ad)
                if L.GradientTitle and L.GradientTitle.Enabled then
                    L.GradientTitle.Start = ad
                    L.GradientTitle.Middle = ad
                    L.GradientTitle.End = ad
                end
                
                -- Обновляем цвет ауры если она активна
                if _G.AuraUtility then
                    _G.AuraUtility:updateColor(ad)
                end
            end
        }
    )
    local af = aa:Label("Window Background", "Left")
    local ag =
        af:Colorpicker(
        {
            Name = "Window Background",
            Default = z(43, 43, 43),
            Alpha = 1,
            Flag = "ThemeWindowBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Window Background", ad)
            end
        }
    )
    local ah = aa:Label("Text Color", "Left")
    local ai =
        ah:Colorpicker(
        {
            Name = "Text Color",
            Default = z(180, 180, 180),
            Alpha = 1,
            Flag = "ThemeTextColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Text", ad)
            end
        }
    )
    local aj = aa:Label("Section Background", "Left")
    local ak =
        aj:Colorpicker(
        {
            Name = "Section Background",
            Default = z(19, 19, 19),
            Alpha = 1,
            Flag = "ThemeSectionBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Section Background", ad)
            end
        }
    )
    local al = aa:Label("Element Color", "Left")
    local am =
        al:Colorpicker(
        {
            Name = "Element Color",
            Default = z(63, 63, 63),
            Alpha = 1,
            Flag = "ThemeElementColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Element", ad)
            end
        }
    )
    local an = aa:Label("Border Color", "Left")
    local ao =
        an:Colorpicker(
        {
            Name = "Border Color",
            Default = z(68, 68, 68),
            Alpha = 1,
            Flag = "ThemeBorderColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Border", ad)
            end
        }
    )
    local ap = aa:Label("Outline Color", "Left")
    local aq =
        ap:Colorpicker(
        {
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 1,
            Flag = "ThemeOutlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Outline", ad)
            end
        }
    )
    local ar = aa:Label("Dark Liner", "Left")
    local as =
        ar:Colorpicker(
        {Name = "Dark Liner", Default = z(56, 56, 56), Alpha = 1, Flag = "ThemeDarkLiner", Callback = function(ad, ae)
                K:ChangeTheme("Dark Liner", ad)
            end}
    )
    local at = aa:Label("Risky Color", "Left")
    local au =
        at:Colorpicker(
        {
            Name = "Risky Color",
            Default = z(255, 50, 50),
            Alpha = 1,
            Flag = "ThemeRiskyColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Risky", ad)
            end
        }
    )
    local av = aa:Label("Inline Color", "Left")
    local aw =
        av:Colorpicker(
        {
            Name = "Inline Color",
            Default = z(12, 12, 12),
            Alpha = 1,
            Flag = "ThemeInlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Inline", ad)
            end
        }
    )
    local ax = S:Section({Name = "HUD", Side = 2})
    local ay =
        ax:Toggle(
        {Name = "Keybinds", Default = false, Flag = "HUDKeybinds", Callback = function(a0)
                if _G.KeybindList then
                    _G.KeybindList:SetVisibility(a0)
                end
            end}
    )
    local az =
        ax:Toggle(
        {Name = "Watermark", Default = false, Flag = "HUDWatermark", Callback = function(a0)
                if _G.Watermark then
                    _G.Watermark:SetVisibility(a0)
                end
            end}
    )
    local aA = ax:Label("GUI", "Left")
    local aB =
        aA:Keybind(
        {
            Name = "Toggle GUI",
            Mode = "Toggle",
            Default = Enum.KeyCode.Insert,
            Flag = "GUIToggleKey",
            Callback = function(aC)
                if L and L.SetOpen then
                    L:SetOpen(not L.IsOpen)
                end
            end
        }
    )
    do
        local aD = L.SetOpen
        L.SetOpen = function(self, aE)
            aD(self, aE)
            if aB and aB.Toggled ~= self.IsOpen then
                aB.Toggled = self.IsOpen
                if aB.KeybindListItem then
                    aB.KeybindListItem:SetStatus(self.IsOpen)
                end
            end
        end
    end
    do
        local aF = S:Section({Name = "Server", Side = 2})
        local aG =
            aF:Button(
            {Name = "Copy GameID", Callback = function()
                    setclipboard(tostring(game.GameId))
                    K:Notification("GameID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aH =
            aF:Button(
            {Name = "Copy JobID", Callback = function()
                    setclipboard(game.JobId)
                    K:Notification("JobID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aI =
            aF:Button(
            {
                Name = "Copy Join Script",
                Callback = function()
                    local aJ =
                        'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                    setclipboard(aJ)
                    K:Notification("Join script copied to clipboard", 2, z(0, 255, 0))
                end
            }
        )
        local aK =
            aF:Button(
            {Name = "Rejoin Game", Callback = function()
                    D:TeleportToPlaceInstance(game.PlaceId, game.JobId, g)
                end}
        )
        local aL =
            aF:Button(
            {
                Name = "Join New Server",
                Callback = function()
                    local aM, aN =
                        pcall(
                        function()
                            return e:JSONDecode(
                                game:HttpGetAsync(
                                    "https://games.roblox.com/v1/games/" ..
                                        game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                                )
                            )
                        end
                    )
                    if aM and aN and aN.data and #aN.data > 0 then
                        local aO = aN.data[h(1, #aN.data)]
                        D:TeleportToPlaceInstance(game.PlaceId, aO.id)
                    else
                        K:Notification("Failed to get server list", 3, z(255, 0, 0))
                    end
                end
            }
        )
    end
end
K:Notification("Script loaded, press Insert to toggle GUI", 4, z(0, 255, 0))
