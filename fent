loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))() -- ac bypass dont touch or remove
local game = game
local workspace = workspace
local a = game:GetService("Players")
local b = game:GetService("RunService")
local c = game:GetService("UserInputService")
local d = game:GetService("TweenService")
local e = game:GetService("HttpService")
local f = game:GetService("Lighting")
local g = a.LocalPlayer
local h, i = math.random, math.huge
local j, k = math.floor, math.ceil
local l, m = math.abs, math.sqrt
local n, o = math.sin, math.cos
local p, q = table.insert, table.remove
local r, s = table.sort, table.concat
local t, u = string.format, string.match
local v, w = string.lower, string.upper
local x, y = string.sub, string.gsub
local ipairs = ipairs
local type, tostring = type, tostring
local typeof = typeof
local pcall, xpcall = pcall, xpcall
local loadstring = loadstring
local setmetatable = setmetatable
local getmetatable = getmetatable
local z = Color3.fromRGB
local A = UDim2.new
local B = Vector3.new
local C = CFrame.new
local replicated_storage = game:GetService("ReplicatedStorage")
local main_remote = replicated_storage.MainRemotes:WaitForChild("MainRemoteEvent")
local isfolder = isfolder
local isfile = isfile
local listfiles = listfiles
local writefile = writefile
local readfile = readfile
local delfile = delfile
local makefolder = makefolder
local setclipboard = setclipboard
local D = game:GetService("TeleportService")
local cam = workspace.CurrentCamera
local Vector2 = Vector2
local Instance = Instance
local ColorSequence = ColorSequence
local ColorSequenceKeypoint = ColorSequenceKeypoint
local NumberSequence = NumberSequence
local NumberSequenceKeypoint = NumberSequenceKeypoint
local NumberRange = NumberRange
local Enum = Enum
local hookmetamethod = hookmetamethod
local checkcaller = checkcaller
local newcclosure = newcclosure
local getgenv = getgenv
local task = task or {}
local wait = wait or function(t) return task.wait(t) end
local fireclickdetector = fireclickdetector
local getconnections = getconnections
local debug = debug

repeat wait() until game:IsLoaded()

-- Предварительная загрузка звуков с таймаутом
local availableSounds = {}
local soundsLoaded = false

local function createSoundsFolder()
    if not isfolder("FentSounds") then
        makefolder("FentSounds")
    end
end

local function downloadSoundWithTimeout(fileName, downloadUrl, timeout)
    local soundPath = "FentSounds/" .. fileName
    
    if isfile(soundPath) then
        return true
    end
    
    local startTime = tick()
    local success = false
    
    spawn(function()
        local downloadSuccess, soundData = pcall(function()
            return game:HttpGet(downloadUrl)
        end)
        
        if downloadSuccess and soundData then
            writefile(soundPath, soundData)
            success = true
        end
    end)
    
    -- Ждем загрузки с таймаутом
    while (tick() - startTime) < timeout and not success do
        wait(0.1)
    end
    
    return success
end

local function fetchAndDownloadSounds()
    createSoundsFolder()
    local sounds = {}
    local totalSounds = 0
    local loadedSounds = 0
    
    print("[Fentanyl] Загрузка списка звуков из репозиториев...")
    
    -- Источник 1: OnChangedCallback/sounds
    local success1, response1 = pcall(function()
        return game:HttpGet("https://api.github.com/repos/OnChangedCallback/sounds/contents/main")
    end)
    
    if success1 then
        local jsonSuccess1, data1 = pcall(function()
            return game:GetService("HttpService"):JSONDecode(response1)
        end)
        
        if jsonSuccess1 and type(data1) == "table" then
            for _, file in ipairs(data1) do
                if file.name and file.name:match("%.wav$") then
                    local fileName = file.name:gsub("%.wav$", "")
                    table.insert(sounds, {
                        name = fileName, 
                        url = file.download_url, 
                        fullName = file.name,
                        source = "OnChangedCallback"
                    })
                    totalSounds = totalSounds + 1
                end
            end
        end
    end
    
    -- Источник 2: f1nobe7650/Nebula
    local success2, response2 = pcall(function()
        return game:HttpGet("https://api.github.com/repos/f1nobe7650/Nebula/contents/Sounds")
    end)
    
    if success2 then
        local jsonSuccess2, data2 = pcall(function()
            return game:GetService("HttpService"):JSONDecode(response2)
        end)
        
        if jsonSuccess2 and type(data2) == "table" then
            for _, file in ipairs(data2) do
                if file.name and (file.name:match("%.wav$") or file.name:match("%.mp3$") or file.name:match("%.ogg$")) then
                    local fileName = file.name:gsub("%.%w+$", "")
                    -- Добавляем префикс для различения источников
                    table.insert(sounds, {
                        name = "Nebula_" .. fileName, 
                        url = "https://github.com/f1nobe7650/Nebula/raw/refs/heads/main/Sounds/" .. file.name, 
                        fullName = "Nebula_" .. file.name,
                        source = "Nebula"
                    })
                    totalSounds = totalSounds + 1
                end
            end
        end
    end
    
    print("[Fentanyl] Найдено " .. totalSounds .. " звуков из " .. (success1 and "OnChangedCallback" or "") .. (success1 and success2 and " + " or "") .. (success2 and "Nebula" or "") .. ". Начинаю загрузку...")
    
    -- Загружаем каждый звук с таймаутом 10 секунд
    for i, sound in ipairs(sounds) do
        print("[Fentanyl] Загрузка " .. i .. "/" .. totalSounds .. ": " .. sound.name .. " (" .. sound.source .. ")")
        
        local downloaded = downloadSoundWithTimeout(sound.fullName, sound.url, 10)
        
        if downloaded then
            loadedSounds = loadedSounds + 1
            print("[Fentanyl] ✓ Загружен: " .. sound.name)
        else
            print("[Fentanyl] ✗ Пропущен (таймаут): " .. sound.name)
        end
    end
    
    -- Оставляем только загруженные звуки
    local finalSounds = {}
    for _, sound in ipairs(sounds) do
        if isfile("FentSounds/" .. sound.fullName) then
            table.insert(finalSounds, sound.name)
        end
    end
    
    -- Fallback если оба API недоступны
    if #finalSounds == 0 then
        print("[Fentanyl] API недоступны, используем fallback звуки")
        for i = 1, 20 do
            table.insert(finalSounds, tostring(i))
        end
    end
    
    print("[Fentanyl] Загрузка звуков завершена: " .. loadedSounds .. "/" .. totalSounds)
    return finalSounds
end

-- Загружаем звуки и ждем завершения
spawn(function()
    availableSounds = fetchAndDownloadSounds()
    soundsLoaded = true
    print("[Fentanyl] Все звуки обработаны, можно инициализировать UI")
end)

-- Ждем завершения загрузки звуков
print("[Fentanyl] Ожидание загрузки звуков...")
while not soundsLoaded do
    wait(0.5)
end

-- Circle rendering variables
local tick = tick
local Drawing = Drawing
local E = {}
local F = {}
do
    function E.new_connection(G, H)
        local I = G:Connect(H)
        p(F, I)
        return I
    end
    function E.disconnect_all()
        for J, I in ipairs(F) do
            if I then
                I:Disconnect()
            end
        end
        F = {}
    end
end

do -- Targeting Framework
    local targeting_state = {current = nil}
    pcall(function()
        _G.targeting_state = targeting_state
    end)
    
    local TargetingFramework = {}
    
    do -- Utility Functions
        local utility = {}
        
        function utility:ValidateClient(player)
            if not player then
                return false
            end
            local character = player.Character
            if not character then
                return false
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                return false
            end
            return humanoid.RootPart ~= nil
        end
        
        function utility:GetPreferredPart(character)
            return character and 
                (character:FindFirstChild("HumanoidRootPart") or 
                 character:FindFirstChild("Head") or 
                 character:FindFirstChild("UpperTorso") or
                 character:FindFirstChild("Torso")) or nil
        end
        
        function utility:ToScreen(position)
            local screenPos, onScreen = cam:WorldToViewportPoint(position)
            return Vector2.new(screenPos.X, screenPos.Y), onScreen
        end
        
        function utility:GetMouseLocation()
            return c:GetMouseLocation()
        end
        
        function utility:GetMouseDistance(screenPos)
            return (utility:GetMouseLocation() - screenPos).Magnitude
        end
        
        function utility:getHeld()
            local character = g.Character
            if not character then return "None" end
            local tool = character:FindFirstChildOfClass("Tool")
            return tool or "None"
        end
        
        function utility:GetOrigin()
            local Tool = utility:getHeld()
            return (Tool ~= "None" and Tool.Handle and Tool.Handle.Position) or cam.CFrame.Position
        end
        
        -- Force Hit utility functions
        function utility:isPlayerKO(player)
            if not player or not player.Character then return false end
            
            -- Проверяем K.O статус через BodyEffects
            local success, isKO = pcall(function()
                local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
                if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                    local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                    if koEffect and koEffect:FindFirstChild("Value") then
                        return koEffect.Value.Value == true
                    end
                end
                return false
            end)
            
            if success then
                return isKO
            end
            
            -- Fallback к проверке здоровья если BodyEffects недоступны
            local humanoid = player.Character:FindFirstChild("Humanoid")
            return humanoid and humanoid.Health <= 0
        end
        
        function utility:isPlayerGrabbed(player)
            if not player or not player.Character then return false end
            -- Проверяем, схвачен ли игрок
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                return humanoid.PlatformStand or false
            end
            return false
        end
        
        function utility:hasForceField(player)
            if not player or not player.Character then return false end
            return player.Character:FindFirstChildOfClass("ForceField") ~= nil
        end
        
        function utility:performForceHit(targetPlayer)
            if not targetPlayer or not targetPlayer.Character then 
                return false 
            end
            
            -- Проверяем K.O статус цели перед выстрелом
            if self:isPlayerKO(targetPlayer) then
                return false
            end
            
            local character = g.Character
            if not character then 
                return false 
            end
            
            local tool = character:FindFirstChildOfClass("Tool")
            if not tool or not tool:FindFirstChild("Handle") then 
                return false 
            end
            
            local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local targetHead = targetPlayer.Character:FindFirstChild("Head")
            if not targetHRP or not targetHead then 
                return false 
            end
            
            -- Получаем RemoteEvent оружия
            local toolRemote = tool:FindFirstChild("RemoteEvent")
            if not toolRemote then
                return false
            end
            
            -- Получаем MainRemoteEvent
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local mainRemotes = replicatedStorage:FindFirstChild("MainRemotes")
            if not mainRemotes then
                return false
            end
            
            local mainRemoteEvent = mainRemotes:FindFirstChild("MainRemoteEvent")
            if not mainRemoteEvent then
                return false
            end
            
            -- Выполняем последовательность выстрела как в оригинальном скрипте
            local origin = tool.Handle.Position
            
            -- 1. Сначала отправляем "Shoot" через RemoteEvent оружия
            local success1 = pcall(function()
                toolRemote:FireServer("Shoot")
            end)
            if not success1 then
                return false
            end
            
            -- 2. Отправляем основной выстрел через MainRemoteEvent
            local success2 = pcall(function()
                mainRemoteEvent:FireServer(
                    "ShootGun",
                    tool.Handle,
                    origin,
                    targetHRP.Position,
                    targetHead,
                    B(0, 0, -1) -- Vector3.zAxis как в оригинале
                )
            end)
            if not success2 then
                return false
            end
            
            -- 3. Завершаем выстрел
            local success3 = pcall(function()
                toolRemote:FireServer()
            end)
            if not success3 then
                return false
            end
            
            return success2
        end
        
        -- HitChams utility functions
        function utility:createHitChams(player)
            if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            -- Получаем настройки цвета, прозрачности и материала из UI
            local uiLib = _G.FentanylUI
            local chamsColor = (uiLib and uiLib.Flags and uiLib.Flags["hit_chams_color"]) or z(255, 0, 0)
            local chamsAlpha = (uiLib and uiLib.Flags and uiLib.Flags["hit_chams_alpha"]) or 0.0
            local chamsMaterial = (uiLib and uiLib.Flags and uiLib.Flags["hit_chams_material"]) or "Neon"
            
            player.Character.Archivable = true
            local cloned = player.Character:Clone()
            cloned.Name = "HitChams_Clone"
            
            local bodyParts = {
                "Head", "UpperTorso", "LowerTorso",
                "LeftUpperArm", "LeftLowerArm", "LeftHand",
                "RightUpperArm", "RightLowerArm", "RightHand",
                "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
                "RightUpperLeg", "RightLowerLeg", "RightFoot"
            }
            
            -- Удаляем ненужные части
            for _, part in ipairs(cloned:GetChildren()) do
                if part:IsA("BasePart") then
                    local partValid = false
                    for _, validPart in ipairs(bodyParts) do
                        if part.Name == validPart then
                            partValid = true
                            break
                        end
                    end
                    
                    if not partValid then
                        part:Destroy()
                    end
                elseif part:IsA("Accessory") or part:IsA("Tool") or part.Name == "face" or 
                       part:IsA("Shirt") or part:IsA("Pants") or part:IsA("Hat") then
                    part:Destroy()
                end
            end
            
            -- Удаляем Humanoid
            if cloned:FindFirstChild("Humanoid") then
                cloned.Humanoid:Destroy()
            end
            
            -- Настраиваем части тела с пользовательскими настройками
            for _, bodyPart in ipairs(cloned:GetChildren()) do
                if bodyPart:IsA("BasePart") then
                    bodyPart.CanCollide = false
                    bodyPart.Anchored = true
                    bodyPart.Transparency = chamsAlpha
                    bodyPart.Color = chamsColor
                    bodyPart.Material = Enum.Material[chamsMaterial]
                end
            end
            
            -- Настраиваем голову отдельно с пользовательскими настройками
            if cloned:FindFirstChild("Head") then
                local head = cloned.Head
                head.Transparency = chamsAlpha
                head.Color = chamsColor
                head.Material = Enum.Material[chamsMaterial]
                
                if head:FindFirstChild("face") then
                    head.face:Destroy()
                end
            end
            
            cloned.Parent = workspace
            
            -- Создаем tween для исчезновения
            local tweenInfo = TweenInfo.new(
                2, -- duration
                Enum.EasingStyle.Sine,
                Enum.EasingDirection.InOut,
                0,
                true
            )
            
            for _, bodyPart in ipairs(cloned:GetChildren()) do
                if bodyPart:IsA("BasePart") then
                    local tween = d:Create(bodyPart, tweenInfo, { Transparency = 1 })
                    tween:Play()
                end
            end
            
            -- Удаляем клон через заданное время
            task.delay(2, function()
                if cloned and cloned.Parent then
                    cloned:Destroy()
                end
            end)
        end
        
        -- HitSounds utility functions
        function utility:createSoundsFolder()
            if not isfolder("FentSounds") then
                makefolder("FentSounds")
            end
        end
        
        function utility:downloadHitSound(soundName)
            self:createSoundsFolder()
            
            -- Проверяем, это звук из Nebula или OnChangedCallback
            if soundName:match("^Nebula_") then
                -- Звук из Nebula репозитория
                local actualFileName = soundName:gsub("^Nebula_", "")
                local soundPath = "FentSounds/" .. soundName
                
                -- Проверяем все возможные расширения для Nebula
                local extensions = {".wav", ".mp3", ".ogg"}
                for _, ext in ipairs(extensions) do
                    local fullPath = soundPath .. ext
                    if isfile(fullPath) then
                        return fullPath
                    end
                end
                
                -- Если файл не найден, пытаемся загрузить
                for _, ext in ipairs(extensions) do
                    local fullPath = soundPath .. ext
                    local success, soundData = pcall(function()
                        return game:HttpGet("https://github.com/f1nobe7650/Nebula/raw/refs/heads/main/Sounds/" .. actualFileName .. ext)
                    end)
                    
                    if success and soundData and #soundData > 0 then
                        writefile(fullPath, soundData)
                        return fullPath
                    end
                end
                
                return nil
            else
                -- Звук из OnChangedCallback репозитория
                local soundPath = "FentSounds/" .. soundName .. ".wav"
                
                if isfile(soundPath) then
                    return soundPath
                end
                
                local success, soundData = pcall(function()
                    return game:HttpGet("https://github.com/OnChangedCallback/sounds/raw/main/main/" .. soundName .. ".wav")
                end)
                
                if success and soundData then
                    writefile(soundPath, soundData)
                    return soundPath
                else
                    return nil
                end
            end
        end
        
        function utility:playHitSound()
            local uiLib = _G.FentanylUI
            if not (uiLib and uiLib.Flags and uiLib.Flags["hit_sounds"]) then
                return
            end
            
            local volume = (uiLib.Flags["hit_sounds_volume"]) or 0.5
            local pitch = (uiLib.Flags["hit_sounds_pitch"]) or 1.0
            local soundSelection = (uiLib.Flags["hit_sounds_selection"]) or (availableSounds[1] or "1")
            
            local soundPath = self:downloadHitSound(soundSelection)
            
            if soundPath and isfile(soundPath) then
                local sound = Instance.new("Sound")
                sound.Volume = volume
                sound.PlaybackSpeed = pitch
                
                -- Используем правильный метод для локальных файлов
                local success, customAsset = pcall(function()
                    if getsynasset then
                        return getsynasset(soundPath)
                    elseif getcustomasset then
                        return getcustomasset(soundPath)
                    else
                        return "rbxassetid://6565367558" -- Fallback
                    end
                end)
                
                if success and customAsset then
                    sound.SoundId = customAsset
                    sound.Parent = workspace
                    
                    sound:Play()
                    
                    -- Удаляем звук после проигрывания
                    sound.Ended:Connect(function()
                        sound:Destroy()
                    end)
                end
            end
        end
        
        TargetingFramework.utility = utility
    end
    
    do -- Circle Utility Functions
        local circle_utility = {}
        
        function circle_utility.lerp(a, b, t)
            return a + (b - a) * t
        end
        
        function circle_utility.lerp_color(a, b, t)
            return z(
                circle_utility.lerp(a.R * 255, b.R * 255, t),
                circle_utility.lerp(a.G * 255, b.G * 255, t),
                circle_utility.lerp(a.B * 255, b.B * 255, t)
            )
        end
        
        function circle_utility.custom_gradient(t, time, c1, c2, c3, c4, speed)
            local tt = (t + (time * speed)) % 1
            if tt < 0.25 then
                return circle_utility.lerp_color(c1, c2, tt / 0.25)
            elseif tt < 0.5 then
                return circle_utility.lerp_color(c2, c3, (tt - 0.25) / 0.25)
            elseif tt < 0.75 then
                return circle_utility.lerp_color(c3, c4, (tt - 0.5) / 0.25)
            else
                return circle_utility.lerp_color(c4, c1, (tt - 0.75) / 0.25)
            end
        end
        
        TargetingFramework.circle_utility = circle_utility
    end
    
    do -- Core Framework Functions
        TargetingFramework._hit_listeners = {}
        TargetingFramework._target = {info = nil, listeners = {}}
        TargetingFramework._dd = {
            last_target = nil,
            last_char = nil,
            hum = nil,
            last_health = nil,
            last_max = nil,
            conn = nil,
            hum_conn = nil,
            last_debug_t = 0,
            override_player = nil
        }
        
        function TargetingFramework:GetClosestToMouse()
            local closestPlayer, closestDistance = nil, nil
            for _, player in ipairs(a:GetPlayers()) do
                if player ~= g and self.utility:ValidateClient(player) then
                    -- Проверяем KO check если включен
                    local uiLib = _G.FentanylUI
                    local skipPlayer = false
                    if uiLib and uiLib.Flags and uiLib.Flags["KOCheckEnabled"] then
                        if self.utility:isPlayerKO(player) then
                            -- Пропускаем KO игроков при выборе новой цели
                            skipPlayer = true
                        end
                    end
                    
                    if not skipPlayer then
                        local character = player.Character
                        local targetPart = self.utility:GetPreferredPart(character)
                        if targetPart then
                            local screenPos, onScreen = self.utility:ToScreen(targetPart.Position)
                            if onScreen then
                                local distance = self.utility:GetMouseDistance(screenPos)
                                if not closestDistance or distance < closestDistance then
                                    closestPlayer, closestDistance = player, distance
                                end
                            end
                        end
                    end
                end
            end
            return closestPlayer, closestDistance or math.huge
        end
        
        function TargetingFramework:OnHit(callback)
            if typeof(callback) == "function" then
                p(self._hit_listeners, callback)
            end
        end
        
        function TargetingFramework:OnTargetUpdate(callback)
            if typeof(callback) == "function" then
                p(self._target.listeners, callback)
            end
        end
        
        function TargetingFramework:_emit_hit(targetInfo)
            for _, callback in ipairs(self._hit_listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:GetTargetInfo()
            local targetInfo = self._target.info
            return targetInfo ~= nil, targetInfo
        end
        
        function TargetingFramework:SetTargetInfo(player)
            local targetInfo = nil
            self._dd.override_player = player or nil
            
            if player and player.Character then
                local character = player.Character
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local rootPart = humanoid and humanoid.RootPart or character:FindFirstChild("HumanoidRootPart")
                local health = humanoid and humanoid.Health or nil
                local maxHealth = humanoid and humanoid.MaxHealth or nil
                local cframe = rootPart and rootPart.CFrame or (character.GetPivot and character:GetPivot() or nil)
                local position = rootPart and rootPart.Position or (cframe and cframe.Position or nil)
                
                targetInfo = {
                    isTarget = true,
                    player = player,
                    userId = player.UserId,
                    name = player.Name,
                    displayName = player.DisplayName,
                    character = character,
                    humanoid = humanoid,
                    root = rootPart,
                    cframe = cframe,
                    position = position,
                    health = health,
                    maxHealth = maxHealth,
                    alive = humanoid and humanoid.Health > 0,
                    time = os.clock()
                }
            end
            
            self._target.info = targetInfo
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:ClearTargetInfo()
            self._target.info = nil
            self._dd.override_player = nil
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, nil)
            end
        end
        
        function TargetingFramework:SetCurrentTarget(player)
            self._dd.override_player = player
        end
        
        function TargetingFramework:ClearCurrentTarget()
            self._dd.override_player = nil
        end
        
        function TargetingFramework:GetCurrentTarget()
            return self._dd.override_player or (targeting_state and targeting_state.current or nil)
        end
    end
    
    do -- Target Selection Logic
        local TargetSelector = {}
        
        function TargetSelector:selectTarget()
            if targeting_state.current then
                targeting_state.current = nil
                TargetingFramework:ClearTargetInfo()
                TargetingFramework:ClearCurrentTarget()
            else
                local closestTarget, _distance = TargetingFramework:GetClosestToMouse()
                if closestTarget then
                    -- Дополнительная проверка KO для выбранной цели
                    local uiLib = _G.FentanylUI
                    if uiLib and uiLib.Flags and uiLib.Flags["KOCheckEnabled"] then
                        if TargetingFramework.utility:isPlayerKO(closestTarget) then
                            -- Не выбираем KO игрока
                            return
                        end
                    end
                    
                    targeting_state.current = closestTarget
                    TargetingFramework:SetTargetInfo(closestTarget)
                    TargetingFramework:SetCurrentTarget(closestTarget)
                end
            end
        end
        
        TargetingFramework.selector = TargetSelector
    end
    
    do -- Health Detection System
        local function StartHealthDetection()
            if TargetingFramework._dd.conn then
                TargetingFramework._dd.conn:Disconnect()
                TargetingFramework._dd.conn = nil
            end
            
            TargetingFramework._dd.conn = b.Heartbeat:Connect(function()
                -- Проверяем включен ли таргетинг ИЛИ OnDamage уведомления
                -- Проверяем через _G чтобы избежать ошибок с порядком инициализации
                local uiLib = _G.FentanylUI
                if not uiLib or not uiLib.Flags then
                    return
                end
                
                -- Если ни таргетинг, ни OnDamage не включены, выходим
                local targetingEnabled = uiLib.Flags["TargetingEnabled"]
                local onDamageEnabled = uiLib.Flags["NotifyOnDamage"]
                
                if not targetingEnabled and not onDamageEnabled then
                    return
                end
                
                local dd = TargetingFramework._dd
                local currentTarget = dd.override_player or (targeting_state and targeting_state.current or nil)
                
                -- Если есть OnDamage, но нет цели, пытаемся найти ближайшую
                if not currentTarget and onDamageEnabled then
                    local closestTarget, _distance = TargetingFramework:GetClosestToMouse()
                    if closestTarget then
                        currentTarget = closestTarget
                    end
                end
                
                if currentTarget ~= dd.last_target then
                    dd.last_target = currentTarget
                    dd.last_char = nil
                    dd.hum = nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                end
                
                if not currentTarget then
                    return
                end
                
                local character = currentTarget.Character
                if character ~= dd.last_char or (dd.hum and not dd.hum.Parent) then
                    dd.last_char = character
                    dd.hum = character and character:FindFirstChildOfClass("Humanoid") or nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                    
                    if dd.hum then
                        b.Heartbeat:Wait()
                        dd.hum_conn = dd.hum.HealthChanged:Connect(function(newHealth)
                            local maxHealth = dd.hum and dd.hum.MaxHealth or 0
                            
                            if dd.last_health == nil or dd.last_max == nil or maxHealth ~= dd.last_max then
                                dd.last_health = newHealth
                                dd.last_max = maxHealth
                                return
                            end
                            
                            if newHealth < dd.last_health then
                                local damage = dd.last_health - newHealth
                                
                                local hitInfo = {
                                    player = currentTarget,
                                    damage = damage,
                                    health = newHealth,
                                    maxHealth = maxHealth,
                                    time = os.clock()
                                }
                                
                                TargetingFramework:_emit_hit(hitInfo)
                            end
                            
                            dd.last_health = newHealth
                            dd.last_max = maxHealth
                        end)
                    end
                end
            end)
        end
        
        -- Функция остановки
        function TargetingFramework:StopHealthDetection()
            if self._dd.conn then
                self._dd.conn:Disconnect()
                self._dd.conn = nil
            end
            if self._dd.hum_conn then
                self._dd.hum_conn:Disconnect()
                self._dd.hum_conn = nil
            end
        end
        
        -- Запускаем только если нужно
        TargetingFramework.StartHealthDetection = StartHealthDetection
        
        -- Добавляем метод для проверки статуса
        function TargetingFramework:IsHealthDetectionActive()
            return self._dd.conn ~= nil
        end
    end
    
    _G.TargetingFramework = TargetingFramework
end

do -- Desync Framework
    local desync_vars = {
        Players = a,
        RunService = b,
        StarterGui = game:GetService("StarterGui"),
        newcf = C,
        v3 = B,
        typeof = typeof,
        task = task,
        math = math,
        cam = cam,
        uis = c
    }

    local config = {
        Desync = {
            Enabled = false,
            LogInterval = 2
        }
    }

    local state = {
        enabled = false,
        targetCFrame = nil,
        realCFrame = nil,
        hookInstalled = false,
        logStarted = false,
        followMode = false,
        viz_enabled = false,
        viz_part = nil,
        viz_line = nil,
        viz_conn = nil,
        heartbeatConn = nil
    }

    local desync_utility = {}

    function desync_utility:ValidateClient(player)
        if not player then
            return false
        end
        local character = player.Character
        if not character then
            return false
        end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            return false
        end
        local rootPart = humanoid.RootPart
        return rootPart ~= nil
    end

    function desync_utility:getPlayerParts(player)
        local character = player and player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local rootPart = humanoid and humanoid.RootPart
        return character, humanoid, rootPart
    end

    local function parseCFrame(arg1, arg2, arg3)
        local argType = desync_vars.typeof(arg1)
        if argType == "CFrame" then
            return arg1
        end
        if argType == "Vector3" then
            return desync_vars.newcf(arg1)
        end
        if argType == "table" and arg1[1] and arg1[2] and arg1[3] then
            return desync_vars.newcf(arg1[1], arg1[2], arg1[3])
        end
        if argType == "number" and type(arg2) == "number" and type(arg3) == "number" then
            return desync_vars.newcf(arg1, arg2, arg3)
        end
        return nil
    end

    local function installHook()
        if state.hookInstalled then
            return
        end
        if not hookmetamethod or not newcclosure or not checkcaller then
            state.hookInstalled = true
            return
        end
        local oldIndex
        oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
            if not checkcaller() then
                if key == "CFrame" and state.enabled then
                    local _, _, rootPart = desync_utility:getPlayerParts(g)
                    if rootPart and self == rootPart and state.realCFrame then
                        return state.realCFrame
                    end
                end
            end
            return oldIndex(self, key)
        end))
        state.hookInstalled = true
    end

    local function startDesyncLoop()
        if state.heartbeatConn then
            return
        end
        state.heartbeatConn = desync_vars.RunService.Heartbeat:Connect(function()
            -- Проверяем флаги и отключаем цикл если не нужен
            if not config.Desync.Enabled or not state.enabled then
                if state.heartbeatConn then
                    state.heartbeatConn:Disconnect()
                    state.heartbeatConn = nil
                end
                return
            end
            if not desync_utility:ValidateClient(g) then
                return
            end
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            if not rootPart then
                return
            end
            state.realCFrame = rootPart.CFrame
            local targetCF
            if state.followMode then
                targetCF = rootPart.CFrame
            else
                targetCF = state.targetCFrame or state.realCFrame
            end
            rootPart.CFrame = targetCF
            desync_vars.RunService.RenderStepped:Wait()
            rootPart.CFrame = state.realCFrame
        end)
    end

    local DesyncLibrary = {}
    

    function DesyncLibrary.movedesyncto(arg1, arg2, arg3)
        local targetCF = parseCFrame(arg1, arg2, arg3)
        if not targetCF then
            error("movedesyncto: invalid coordinates")
        end
        state.targetCFrame = targetCF
        state.followMode = false
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        return targetCF
    end

    function DesyncLibrary.checksyncposition()
        local position
        if state.targetCFrame then
            position = state.targetCFrame.Position
        else
            local _, _, rootPart = desync_utility:getPlayerParts(g)
            position = rootPart and rootPart.Position or nil
        end
        return position
    end

    function DesyncLibrary.SynchronizeSyncWithPlayer()
        -- Безопасная проверка без ошибки
        if not desync_utility:ValidateClient(g) then
            return nil -- Просто возвращаем nil вместо ошибки
        end
        state.targetCFrame = nil
        state.followMode = true
        config.Desync.Enabled = true
        state.enabled = true
        installHook()
        startDesyncLoop()
        local _, _, rootPart = desync_utility:getPlayerParts(g)
        return rootPart and rootPart.CFrame or nil
    end

    function DesyncLibrary.StopDesync()
        config.Desync.Enabled = false
        state.enabled = false
        state.targetCFrame = nil
        state.followMode = false
        
        if state.heartbeatConn then
            pcall(function()
                state.heartbeatConn:Disconnect()
            end)
            state.heartbeatConn = nil
        end
    end

    function DesyncLibrary.IsEnabled()
        return state.enabled
    end
    

    pcall(function()
        getgenv().DesyncLibrary = DesyncLibrary
    end)
    _G.DesyncLibrary = DesyncLibrary
end

local K =
    loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/fent.lua/refs/heads/main/lalala"))()

-- Сохраняем UI библиотеку в _G для доступа из других частей кода
_G.FentanylUI = K

local L =
    K:Window(
    {
        Name = "Fentik.sexyy",
        Size = UDim2.new(0, 700, 0, 670),
        GradientTitle = {
            Enabled = false,
            Start = Color3.fromRGB(255, 255, 255),
            Middle = Color3.fromRGB(255, 255, 255),
            End = Color3.fromRGB(255, 255, 255),
            Speed = 0.1
        }
    }
)
local M = L:Page({Name = "Ragebot", Columns = 2})
local N = L:Page({Name = "Visuals", Columns = 2})
local ESP_Page = L:Page({Name = "ESP", Columns = 2})
local MiscPage = L:Page({Name = "Misc", Columns = 2})
-- local P = L:Page({Name = "AntiAim", Columns = 2})

do -- Ragebot Tab
    do -- Targeting Section
        local aP = M:Section({Name = "Targeting", Side = 1})
    local aQ = aP:Toggle({
        Name = "Targeting",
        Default = false,
        Flag = "TargetingEnabled",
        Callback = function(aR)
            if _G.TargetingFramework then
                if aR then
                    -- Включаем health detection при включении таргетинга
                    if _G.TargetingFramework.StartHealthDetection then
                        _G.TargetingFramework.StartHealthDetection()
                    end
                else
                    -- Выключаем health detection и очищаем таргет
                    _G.TargetingFramework:StopHealthDetection()
                    _G.TargetingFramework:ClearTargetInfo()
                    _G.TargetingFramework:ClearCurrentTarget()
                    if _G.targeting_state then
                        _G.targeting_state.current = nil
                    end
                end
            end
        end
    })
    
        local aS = aQ:Keybind({
            Name = "Target Selection",
            Mode = "Toggle",
            Default = Enum.KeyCode.T,
            Flag = "TargetSelectionKey",
            Callback = function(aT)
                if K.Flags["TargetingEnabled"] and _G.TargetingFramework and _G.TargetingFramework.selector then
                    _G.TargetingFramework.selector:selectTarget()
                end
            end
        })
    end
    
    
    do -- Aimbot Section
        local aY = M:Section({Name = "Aimbot", Side = 1})
    local aZ = aY:Toggle({
        Name = "Enabled",
        Default = false,
        Flag = "AimbotEnabled",
        Callback = function(ba)
            -- Callback обрабатывается через aimbot logic
        end
    })
    
    local bb = aY:Textbox({
        Name = "XZ Prediction",
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotXZPrediction",
        Callback = function(bc)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bd = aY:Textbox({
        Name = "Y Prediction", 
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotYPrediction",
        Callback = function(be)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bf = aY:Toggle({
        Name = "ShowAimbot",
        Default = false,
        Flag = "ShowAimbot",
        Callback = function(bg)
            -- Управляем beam visualization
            if _G.BeamVisualization then
                if bg then
                    if _G.BeamVisualization.StartBeamVisualization then
                        _G.BeamVisualization.StartBeamVisualization()
                    end
                else
                    if _G.BeamVisualization.StopBeamVisualization then
                        _G.BeamVisualization.StopBeamVisualization()
                    end
                end
            end
        end
    })
    
        local bh = aY:Dropdown({
            Name = "Resolver Type",
            Items = {"Velocity", "MoveDirection", "CalculateCFrame"},
            Default = "Velocity",
            Flag = "ResolverType",
            Callback = function(bi)
                -- Callback обрабатывается через resolver logic
            end
        })
    end
    
    do -- Gun Section
        local gunSection = M:Section({Name = "Gun", Side = 1})
        
        local _rapidFireToggle = gunSection:Toggle({
            Name = "Rapid Fire",
            Default = false,
            Flag = "RapidFireEnabled",
            Callback = function(enabled)
                if _G.RapidFireFramework then
                    _G.RapidFireFramework.setEnabled(enabled)
                end
            end
        })
        
        local _infinityAmmoToggle = gunSection:Toggle({
            Name = "Infinity Ammo (maypatched)",
            Default = false,
            Flag = "InfinityAmmoEnabled",
            Callback = function(enabled)
                if _G.InfinityAmmoFramework then
                    _G.InfinityAmmoFramework.setEnabled(enabled)
                end
            end
        })
        
        local _infinityRangeToggle = gunSection:Toggle({
            Name = "Infinity Range",
            Default = false,
            Flag = "InfinityRangeEnabled",
            Callback = function(enabled)
                if _G.InfinityRangeFramework then
                    _G.InfinityRangeFramework.setEnabled(enabled)
                end
            end
        })
        
        local _autoReloadToggle = gunSection:Toggle({
            Name = "AutoReload",
            Default = false,
            Flag = "AutoReloadEnabled",
            Callback = function(enabled)
                if _G.AutoReloadFramework then
                    _G.AutoReloadFramework.setEnabled(enabled)
                end
            end
        })
    end
    
    do -- Notify Section
        local aT = M:Section({Name = "Notify", Side = 2})
    local aU = aT:Toggle({
        Name = "OnSelected",
        Default = false,
        Flag = "NotifyOnSelected",
        Callback = function(aV)
            -- Callback будет обработан через targeting framework
        end
    })
    
        local aW = aT:Toggle({
            Name = "OnDamage", 
            Default = false,
            Flag = "NotifyOnDamage",
            Callback = function(aX)
                -- Callback будет обработан через targeting framework
            end
        })
    end
    
    do -- Checks Section
        local checksSection = M:Section({Name = "Checks", Side = 2})
        
        local _koCheckToggle = checksSection:Toggle({
            Name = "KO Check",
            Default = false,
            Flag = "KOCheckEnabled",
            Callback = function(enabled)
                -- Callback будет обработан через targeting framework
            end
        })
    end
    
    do -- Exploits Section
        local exploitsSection = M:Section({Name = "Exploits", Side = 2})
        
        local _forceHitToggle = exploitsSection:Toggle({
            Name = "Magic Bullets",
            Default = false,
            Flag = "ForceHitEnabled",
            Callback = function(enabled)
                if _G.ForceHitFramework then
                    if enabled then
                        _G.ForceHitFramework.start()
                    else
                        _G.ForceHitFramework.stop()
                    end
                end
            end
        })
        
        local _wallbangToggle = exploitsSection:Toggle({
            Name = "Wallbang",
            Default = false,
            Flag = "WallbangEnabled",
            Callback = function(enabled)
                if _G.WallbangFramework then
                    if enabled then
                        _G.WallbangFramework.start()
                    else
                        _G.WallbangFramework.stop()
                    end
                end
            end
        })
        
        local _noSpreadToggle = exploitsSection:Toggle({
            Name = "NoSpread",
            Default = false,
            Flag = "NoSpreadEnabled",
            Callback = function(enabled)
                if _G.NoSpreadFramework then
                    if enabled then
                        _G.NoSpreadFramework.start()
                    else
                        _G.NoSpreadFramework.stop()
                    end
                end
            end
        })
    end
    
    do -- Desync Section
        local desyncSection = M:Section({Name = "Desync", Side = 2})
        local _autoArmorToggle = desyncSection:Toggle({
            Name = "AutoArmor",
            Default = false,
            Flag = "AutoArmorEnabled",
            Callback = function(enabled)
                if _G.AutoArmorFramework then
                    if enabled then
                        _G.AutoArmorFramework.start()
                    else
                        _G.AutoArmorFramework.stop()
                        -- Синхронизируемся при выключении
                        if getgenv().DesyncLibrary then
                            pcall(function()
                                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                            end)
                        end
                    end
                end
            end
        })
        
        local _autoStompToggle = desyncSection:Toggle({
            Name = "Auto Stomp",
            Default = false,
            Flag = "AutoStompEnabled",
            Callback = function(enabled)
                if _G.AutoStompFramework then
                    if enabled then
                        _G.AutoStompFramework.start()
                    else
                        _G.AutoStompFramework.stop()
                    end
                end
            end
        })
        
        desyncSection:Toggle({
            Name = "Hide",
            Default = false,
            Flag = "HideEnabled",
            Callback = function(enabled)
                if _G.HideFramework then
                    if enabled then
                        _G.HideFramework.start()
                    else
                        _G.HideFramework.stop()
                    end
                end
            end
        })
    end
    
    do -- Notification Integration
        if _G.TargetingFramework then
            _G.TargetingFramework:OnTargetUpdate(function(targetInfo)
                if K.Flags["NotifyOnSelected"] then
                    if targetInfo then
                        K:Notification("Target selected: " .. targetInfo.name, 2, z(0, 255, 0))
                    else
                        K:Notification("Target cleared", 2, z(255, 255, 0))
                    end
                end
            end)
            
            _G.TargetingFramework:OnHit(function(hitInfo)
                if K.Flags["NotifyOnDamage"] and hitInfo then
                    local damageText = t("%.1f damage to %s", hitInfo.damage, hitInfo.player.Name)
                    K:Notification(damageText, 2, z(255, 100, 100))
                end
                
                -- Trigger HitChams when damage is detected
                if K.Flags["hit_chams"] and hitInfo and _G.HitChamsFramework then
                    _G.HitChamsFramework:TriggerHitChams(hitInfo.player)
                end
                
                -- Play HitSound when damage is detected
                if K.Flags["hit_sounds"] and hitInfo and _G.TargetingFramework and _G.TargetingFramework.utility then
                    _G.TargetingFramework.utility:playHitSound()
                end
            end)
        end
    end
    
    do -- Aimbot Framework
        local AimbotFramework = {}
        local LastPosition = nil
        local LastUpdateTime = nil
        
        local function GetPredictedPosition(targetPlayer)
            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") then 
                return nil 
            end
            
            local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
            if not targetPart then 
                return nil
            end
            
            if not LastPosition or not LastUpdateTime then
                LastPosition = targetPart.Position
                LastUpdateTime = os.clock()
                return LastPosition
            end
            
            local resolverType = K.Flags["ResolverType"] or "Velocity"
            local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
            local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
            
            if resolverType == "Velocity" then
                return targetPart.Position + B(
                    targetPart.Velocity.X * xzPrediction,
                    targetPart.Velocity.Y * yPrediction,
                    targetPart.Velocity.Z * xzPrediction
                )
            elseif resolverType == "MoveDirection" then
                return targetPart.Position + (targetPlayer.Character.Humanoid.MoveDirection * (xzPrediction * 10))
            elseif resolverType == "CalculateCFrame" then
                if (targetPart.Position - LastPosition).Magnitude < 0.001 then
                    return targetPart.Position
                else
                    local currentTime = os.clock()
                    local deltaTime = currentTime - LastUpdateTime
                    local deltaPosition = targetPart.Position - LastPosition
                    LastUpdateTime, LastPosition = currentTime, targetPart.Position
                    
                    if deltaTime > 0 and deltaPosition.Magnitude > 0.001 then
                        local velocity = deltaPosition / deltaTime
                        return targetPart.Position + velocity * (0.1 * xzPrediction)
                    else
                        return targetPart.Position
                    end
                end
            end
            
            return targetPart.Position
        end
        
        local function CheckAimbot()
            return K.Flags["AimbotEnabled"] and K.Flags["TargetingEnabled"] and _G.targeting_state and _G.targeting_state.current
        end
        
        local originalIndex
        originalIndex = hookmetamethod(game, "__index", function(t, k)
            if t:IsA("Mouse") and (k == "Hit" or k == "Target") and not checkcaller() then
                if CheckAimbot() and _G.targeting_state.current then
                    local targetPlayer = _G.targeting_state.current
                    local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
                    
                    if targetPart then
                        local predictedPos = GetPredictedPosition(targetPlayer) or targetPart.Position
                        local hit = C(predictedPos)
                        return k == "Hit" and hit or targetPart
                    end
                end
            end
            return originalIndex(t, k)
        end)
        
        _G.AimbotFramework = AimbotFramework
    end
    
    do -- Force Hit Framework
        local ForceHitFramework = {
            enabled = false,
            connection = nil,
            shootDelay = 0.1, -- Задержка между выстрелами
            lastShotTime = 0
        }
        
        function ForceHitFramework.start()
            if ForceHitFramework.connection then
                return
            end
            
            ForceHitFramework.enabled = true
            
            ForceHitFramework.connection = E.new_connection(b.Heartbeat, function()
                if not ForceHitFramework.enabled then
                    return
                end
                
                -- Проверяем, есть ли текущая цель
                if not _G.targeting_state or not _G.targeting_state.current then
                    return
                end
                
                local currentTarget = _G.targeting_state.current
                if not currentTarget or not currentTarget.Character then
                    return
                end
                
                -- Проверяем задержку между выстрелами
                local now = os.clock()
                if now - ForceHitFramework.lastShotTime < ForceHitFramework.shootDelay then
                    return
                end
                
                -- Проверяем, есть ли у нас оружие
                local character = g.Character
                if not character then
                    return
                end
                
                local tool = character:FindFirstChildOfClass("Tool")
                if not tool or not tool:FindFirstChild("Handle") then
                    return
                end
                
                -- Проверяем состояние цели
                local utility = _G.TargetingFramework and _G.TargetingFramework.utility
                if not utility then
                    return
                end
                
                local isKO = utility:isPlayerKO(currentTarget)
                local _isGrabbed = utility:isPlayerGrabbed(currentTarget)
                local hasFF = utility:hasForceField(currentTarget)
                
                -- Если цель в невалидном состоянии, пропускаем
                if isKO or hasFF then
                    return
                end
                
                -- Проверяем дистанцию
                local targetHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
                if not targetHRP then
                    return
                end
                
                local myHRP = character:FindFirstChild("HumanoidRootPart")
                if not myHRP then
                    return
                end
                
                local distance = (myHRP.Position - targetHRP.Position).Magnitude
                local maxRange = 5000 -- Максимальная дистанция для Force Hit
                
                if distance > maxRange then
                    return
                end
                
                -- Выполняем Force Hit
                local success = utility.performForceHit(utility, currentTarget)
                if success then
                    ForceHitFramework.lastShotTime = now
                end
            end)
        end
        
        function ForceHitFramework.stop()
            ForceHitFramework.enabled = false
            if ForceHitFramework.connection then
                ForceHitFramework.connection:Disconnect()
                ForceHitFramework.connection = nil
            end
        end
        
        _G.ForceHitFramework = ForceHitFramework
    end
    
    do -- AutoReload Framework
        local AutoReloadFramework = {
            enabled = false,
            connection = nil,
            reloadDelay = 1.0, -- Задержка после перезарядки
            lastReloadTime = 0,
            mainModule = nil
        }
        
        function AutoReloadFramework.start()
            if AutoReloadFramework.connection then
                return
            end
            
            -- Получаем MainModule
            local handler = replicated_storage:FindFirstChild("MainModule")
            if not handler then
                return
            end
            
            local success, module = pcall(function()
                return require(handler)
            end)
            
            if not success or not module then
                return
            end
            
            AutoReloadFramework.mainModule = module
            AutoReloadFramework.enabled = true
            
            AutoReloadFramework.connection = E.new_connection(b.Heartbeat, function()
                if not AutoReloadFramework.enabled then
                    return
                end
                
                -- Проверяем задержку после последней перезарядки
                local now = os.clock()
                if now - AutoReloadFramework.lastReloadTime < AutoReloadFramework.reloadDelay then
                    return
                end
                
                local character = g.Character
                if not character then
                    return
                end
                
                -- Используем новую логику с MainModule.GunHold
                local gun = AutoReloadFramework.mainModule.GunHold(character)
                if not gun or not gun[1] then
                    return
                end
                
                local tool = gun[1]
                local ammo = tool:FindFirstChild("Ammo")
                if not ammo or ammo.Value > 0 then
                    return
                end
                
                -- Перезаряжаем оружие через новый remote
                main_remote:FireServer("Reload", tool)
                AutoReloadFramework.lastReloadTime = now
            end)
        end
        
        function AutoReloadFramework.stop()
            if AutoReloadFramework.connection then
                AutoReloadFramework.connection:Disconnect()
                AutoReloadFramework.connection = nil
            end
            AutoReloadFramework.enabled = false
            AutoReloadFramework.mainModule = nil
        end
        
        function AutoReloadFramework.setEnabled(enabled)
            if enabled then
                AutoReloadFramework.start()
            else
                AutoReloadFramework.stop()
            end
        end
        
        _G.AutoReloadFramework = AutoReloadFramework
    end
    
    do -- Wallbang Framework
        local WallbangFramework = {
            enabled = false,
            originalIgnored = nil,
            mainModule = nil
        }
        
        function WallbangFramework.start()
            if WallbangFramework.enabled then
                return
            end
            
            -- Получаем MainModule
            local replicatedStorage = game:GetService("ReplicatedStorage")
            local handler = replicatedStorage:FindFirstChild("MainModule")
            if not handler then
                print("[Wallbang] MainModule not found")
                return
            end
            
            local success, module = pcall(function()
                return require(handler)
            end)
            
            if not success or not module then
                print("[Wallbang] Failed to require MainModule")
                return
            end
            
            WallbangFramework.mainModule = module
            
            -- Сохраняем оригинальные значения
            if module.Ignored then
                WallbangFramework.originalIgnored = {}
                for i, v in ipairs(module.Ignored) do
                    WallbangFramework.originalIgnored[i] = v
                end
                print("[Wallbang] Original Ignored saved:", #WallbangFramework.originalIgnored, "items")
            else
                WallbangFramework.originalIgnored = nil
                print("[Wallbang] No original Ignored found")
            end
            
            -- Устанавливаем новые значения для Wallbang
            pcall(function()
                module.Ignored = {
                    workspace:WaitForChild("Vehicles"), 
                    workspace:WaitForChild("MAP"), 
                    workspace:WaitForChild("Ignored")
                }
            end)
            
            WallbangFramework.enabled = true
            print("[Wallbang] Framework started - walls will be ignored")
        end
        
        function WallbangFramework.stop()
            if not WallbangFramework.enabled then
                return
            end
            
            -- Восстанавливаем оригинальные значения
            if WallbangFramework.mainModule and WallbangFramework.originalIgnored then
                pcall(function()
                    WallbangFramework.mainModule.Ignored = {}
                    for i, v in ipairs(WallbangFramework.originalIgnored) do
                        WallbangFramework.mainModule.Ignored[i] = v
                    end
                end)
                print("[Wallbang] Original Ignored restored:", #WallbangFramework.originalIgnored, "items")
            elseif WallbangFramework.mainModule then
                -- Если оригинальных значений не было, очищаем
                pcall(function()
                    WallbangFramework.mainModule.Ignored = {}
                end)
                print("[Wallbang] Ignored cleared (no original values)")
            end
            
            WallbangFramework.enabled = false
            WallbangFramework.originalIgnored = nil
            WallbangFramework.mainModule = nil
            print("[Wallbang] Framework stopped - walls restored")
        end
        
        _G.WallbangFramework = WallbangFramework
    end
    
    do -- NoSpread Framework
        local NoSpreadFramework = {
            enabled = false,
            originalMathRandom = nil,
            hookedFunction = nil
        }
        
        function NoSpreadFramework.start()
            if NoSpreadFramework.enabled then
                return
            end
            
            -- Создаем хук для math.random
            local old
            old = hookfunction(math.random, function(...)
                local args = {...}
                
                -- Проверяем, вызывается ли из нашего кода
                if checkcaller() then
                    return old(...)
                end
                
                -- Проверяем аргументы для spread
                if (#args == 0) or 
                   (args[1] == -0.05 and args[2] == 0.05) or 
                   (args[1] == -0.1) or
                   (args[1] == -0.05) then
                    
                    -- Если NoSpread включен, возвращаем минимальный spread (1% от оригинала)
                    local originalResult = old(...)
                    return originalResult * 0.01 -- 1% spread
                end
                
                return old(...)
            end)
            
            NoSpreadFramework.originalMathRandom = old
            
            NoSpreadFramework.enabled = true
            print("[NoSpread] Framework started - bullet spread reduced to 1%")
        end
        
        function NoSpreadFramework.stop()
            if not NoSpreadFramework.enabled then
                return
            end
            
            -- Восстанавливаем оригинальную функцию math.random
            if NoSpreadFramework.originalMathRandom then
                pcall(function()
                    hookfunction(math.random, NoSpreadFramework.originalMathRandom)
                end)
            end
            
            NoSpreadFramework.enabled = false
            NoSpreadFramework.originalMathRandom = nil
            NoSpreadFramework.hookedFunction = nil
            print("[NoSpread] Framework stopped - original bullet spread restored")
        end
        
        _G.NoSpreadFramework = NoSpreadFramework
    end
    
    do -- Infinity Range Framework
        local InfinityRangeFramework = {
            enabled = false,
            connection = nil,
            originalValues = {}
        }
        
        local function findRangeValues(weapon)
            local rangeValues = {}
            
            -- Прямой поиск в оружии
            local range = weapon:FindFirstChild("Range") or 
                         weapon:FindFirstChild("MaxRange") or 
                         weapon:FindFirstChild("Distance") or
                         weapon:FindFirstChild("MaxDistance") or
                         weapon:FindFirstChild("Reach")
            if range then
                p(rangeValues, range)
            end
            
            -- Поиск в Configuration/Settings
            local config = weapon:FindFirstChild("Configuration") or 
                          weapon:FindFirstChild("Settings") or
                          weapon:FindFirstChild("Config") or
                          weapon:FindFirstChild("Stats")
            if config then
                local configRange = config:FindFirstChild("Range") or 
                                   config:FindFirstChild("MaxRange") or
                                   config:FindFirstChild("Distance") or
                                   config:FindFirstChild("MaxDistance") or
                                   config:FindFirstChild("Reach") or
                                   config:FindFirstChild("FireRange")
                if configRange then
                    p(rangeValues, configRange)
                end
            end
            
            -- Поиск в Handle
            local handle = weapon:FindFirstChild("Handle")
            if handle then
                local handleRange = handle:FindFirstChild("Range") or 
                                   handle:FindFirstChild("MaxRange") or
                                   handle:FindFirstChild("Distance")
                if handleRange then
                    p(rangeValues, handleRange)
                end
                
                -- Поиск в Handle/Configuration
                local handleConfig = handle:FindFirstChild("Configuration") or 
                                    handle:FindFirstChild("Settings")
                if handleConfig then
                    local hcRange = handleConfig:FindFirstChild("Range") or 
                                   handleConfig:FindFirstChild("MaxRange") or
                                   handleConfig:FindFirstChild("Distance")
                    if hcRange then
                        p(rangeValues, hcRange)
                    end
                end
            end
            
            -- Поиск в GunScript или аналогичных скриптах
            local gunScript = weapon:FindFirstChild("GunScript") or 
                             weapon:FindFirstChild("WeaponScript") or
                             weapon:FindFirstChild("Script")
            if gunScript then
                local scriptRange = gunScript:FindFirstChild("Range") or 
                                   gunScript:FindFirstChild("MaxRange")
                if scriptRange then
                    p(rangeValues, scriptRange)
                end
            end
            
            return rangeValues
        end
        
        local function updateRange(weapon)
            local rangeValues = findRangeValues(weapon)
            
            for _, rangeValue in ipairs(rangeValues) do
                if rangeValue:IsA("NumberValue") or rangeValue:IsA("IntValue") then
                    -- Сохраняем оригинальное значение если еще не сохранили
                    local key = tostring(weapon) .. "_" .. tostring(rangeValue)
                    if InfinityRangeFramework.enabled then
                        if not InfinityRangeFramework.originalValues[key] then
                            InfinityRangeFramework.originalValues[key] = rangeValue.Value
                        end
                        -- Устанавливаем огромное значение
                        rangeValue.Value = 999999999999999999
                    else
                        -- Восстанавливаем оригинальное значение
                        if InfinityRangeFramework.originalValues[key] then
                            rangeValue.Value = InfinityRangeFramework.originalValues[key]
                        end
                    end
                end
            end
        end
        
        function InfinityRangeFramework.setEnabled(state)
            InfinityRangeFramework.enabled = state
            
            if state and not InfinityRangeFramework.connection then
                InfinityRangeFramework.connection = E.new_connection(b.Heartbeat, function()
                    if not InfinityRangeFramework.enabled then
                        return
                    end
                    
                    -- Ищем оружие в руках
                    local character = g.Character
                    if character then
                        local tool = character:FindFirstChildOfClass("Tool")
                        if tool then
                            pcall(function()
                                updateRange(tool)
                            end)
                        end
                    end
                    
                    -- Ищем оружие в workspace.Players
                    local playersFolder = workspace:FindFirstChild("Players")
                    if playersFolder then
                        local playerFolder = playersFolder:FindFirstChild(g.Name)
                        if playerFolder then
                            for _, child in ipairs(playerFolder:GetChildren()) do
                                local name = child.Name
                                if name:match("%[.+%]") or 
                                   name:match("Gun") or 
                                   name:match("Pistol") or 
                                   name:match("Rifle") or
                                   name:match("Shotgun") or
                                   name:match("Revolver") then
                                    pcall(function()
                                        updateRange(child)
                                    end)
                                end
                            end
                        end
                    end
                end)
            elseif not state then
                -- Восстанавливаем все оригинальные значения
                local character = g.Character
                if character then
                    local tool = character:FindFirstChildOfClass("Tool")
                    if tool then
                        pcall(function()
                            updateRange(tool)
                        end)
                    end
                end
                
                local playersFolder = workspace:FindFirstChild("Players")
                if playersFolder then
                    local playerFolder = playersFolder:FindFirstChild(g.Name)
                    if playerFolder then
                        for _, child in ipairs(playerFolder:GetChildren()) do
                            pcall(function()
                                updateRange(child)
                            end)
                        end
                    end
                end
                
                if InfinityRangeFramework.connection then
                    InfinityRangeFramework.connection:Disconnect()
                    InfinityRangeFramework.connection = nil
                end
                
                -- Очищаем сохраненные значения
                InfinityRangeFramework.originalValues = {}
            end
        end
        
        _G.InfinityRangeFramework = InfinityRangeFramework
    end
    
    do -- Infinity Ammo Framework
        local InfinityAmmoFramework = {
            enabled = false,
            connection = nil
        }
        
        local function updateAmmo()
            -- Работаем только через workspace.Players
            local playersFolder = workspace:FindFirstChild("Players")
            if not playersFolder then return end
            
            local playerFolder = playersFolder:FindFirstChild(g.Name)
            if not playerFolder then return end
            
            -- Проходим по всем объектам в папке игрока
            for _, weapon in ipairs(playerFolder:GetChildren()) do
                local name = weapon.Name
                -- Проверяем типичные паттерны названий оружия
                if name:match("%[.+%]") or -- [Revolver], [Shotgun] и т.д.
                   name:match("Gun") or 
                   name:match("Pistol") or 
                   name:match("Rifle") or
                   name:match("Shotgun") or
                   name:match("Revolver") or
                   name:match("SMG") or
                   name:match("AK") or
                   name:match("Glock") or
                   name:match("Weapon") then
                    
                    -- Ищем патроны в оружии
                    local ammoValue = weapon:FindFirstChild("Ammo") or 
                                     weapon:FindFirstChild("Bullets") or 
                                     weapon:FindFirstChild("Clip") or
                                     weapon:FindFirstChild("CurrentAmmo")
                    
                    local maxAmmoValue = weapon:FindFirstChild("MaxAmmo") or 
                                        weapon:FindFirstChild("MaxBullets") or 
                                        weapon:FindFirstChild("ClipSize") or
                                        weapon:FindFirstChild("MaxClip")
                    
                    -- Если не нашли, ищем в Configuration
                    if not ammoValue then
                        local config = weapon:FindFirstChild("Configuration") or 
                                      weapon:FindFirstChild("Settings") or
                                      weapon:FindFirstChild("Config")
                        if config then
                            ammoValue = config:FindFirstChild("Ammo") or 
                                       config:FindFirstChild("Bullets") or
                                       config:FindFirstChild("CurrentAmmo")
                            maxAmmoValue = maxAmmoValue or config:FindFirstChild("MaxAmmo") or 
                                          config:FindFirstChild("MaxBullets") or
                                          config:FindFirstChild("ClipSize")
                        end
                    end
                    
                    -- Если не нашли, ищем в Handle
                    if not ammoValue then
                        local handle = weapon:FindFirstChild("Handle")
                        if handle then
                            ammoValue = handle:FindFirstChild("Ammo") or 
                                       handle:FindFirstChild("Bullets")
                            maxAmmoValue = maxAmmoValue or handle:FindFirstChild("MaxAmmo") or 
                                          handle:FindFirstChild("MaxBullets")
                        end
                    end
                    
                    -- Обновляем патроны если нашли
                    if ammoValue and maxAmmoValue then
                        if (ammoValue:IsA("NumberValue") or ammoValue:IsA("IntValue")) and
                           (maxAmmoValue:IsA("NumberValue") or maxAmmoValue:IsA("IntValue")) then
                            if ammoValue.Value ~= maxAmmoValue.Value then
                                ammoValue.Value = maxAmmoValue.Value
                            end
                        end
                    elseif ammoValue and not maxAmmoValue then
                        -- Если нет максимального значения, устанавливаем большое число
                        if ammoValue:IsA("NumberValue") or ammoValue:IsA("IntValue") then
                            if ammoValue.Value < 999 then
                                ammoValue.Value = 999
                            end
                        end
                    end
                end
            end
        end
        
        function InfinityAmmoFramework.setEnabled(state)
            InfinityAmmoFramework.enabled = state
            
            if state and not InfinityAmmoFramework.connection then
                InfinityAmmoFramework.connection = E.new_connection(b.Heartbeat, function()
                    if not InfinityAmmoFramework.enabled then
                        return
                    end
                    
                    pcall(updateAmmo)
                end)
            elseif not state and InfinityAmmoFramework.connection then
                InfinityAmmoFramework.connection:Disconnect()
                InfinityAmmoFramework.connection = nil
            end
        end
        
        _G.InfinityAmmoFramework = InfinityAmmoFramework
    end
    
    do -- Rapid Fire Framework
        local RapidFireFramework = {
            enabled = false,
            original = {},
            connection = nil
        }
        
        function RapidFireFramework.setEnabled(state)
            RapidFireFramework.enabled = state
            
            if state and not RapidFireFramework.connection then
                RapidFireFramework.connection = E.new_connection(b.RenderStepped, function()
                    if not RapidFireFramework.enabled then
                        return
                    end
                    
                    local tool = g.Character and g.Character:FindFirstChildOfClass("Tool")
                    if tool and tool:FindFirstChild("GunScript") then
                        for _, connection in ipairs(getconnections(tool.Activated)) do
                            local func = connection.Function
                            if func then
                                local funcInfo = debug.getinfo(func)
                                for i = 1, funcInfo.nups do
                                    local c, _n = debug.getupvalue(func, i)
                                    if type(c) == "number" then
                                        if not RapidFireFramework.original[i] then
                                            RapidFireFramework.original[i] = c
                                        end
                                        debug.setupvalue(func, i, RapidFireFramework.enabled and 0.00000000000000000001 or RapidFireFramework.original[i])
                                    end
                                end
                            end
                        end
                    end
                end)
            elseif not state and RapidFireFramework.connection then
                -- Восстанавливаем оригинальные значения
                local tool = g.Character and g.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("GunScript") then
                    for _, connection in ipairs(getconnections(tool.Activated)) do
                        local func = connection.Function
                        if func then
                            local funcInfo = debug.getinfo(func)
                            for i = 1, funcInfo.nups do
                                local c, _n = debug.getupvalue(func, i)
                                if type(c) == "number" and RapidFireFramework.original[i] then
                                    debug.setupvalue(func, i, RapidFireFramework.original[i])
                                end
                            end
                        end
                    end
                end
                
                if RapidFireFramework.connection then
                    RapidFireFramework.connection:Disconnect()
                    RapidFireFramework.connection = nil
                end
                RapidFireFramework.original = {}
            end
        end
        
        _G.RapidFireFramework = RapidFireFramework
    end
    
    do -- Beam Visualization
        local currentBeam = nil
        local beamConnection = nil
        
        local function CreateBeam()
            if currentBeam then
                currentBeam:Destroy()
                currentBeam = nil
            end
            
            local beam = Instance.new("Beam")
            beam.Color = ColorSequence.new(z(255, 0, 0))
            beam.Transparency = NumberSequence.new(0.3)
            beam.Width0 = 0.08
            beam.Width1 = 0.08
            beam.FaceCamera = true
            
            local attachment0 = Instance.new("Attachment")
            local attachment1 = Instance.new("Attachment")
            
            attachment0.Parent = workspace
            attachment1.Parent = workspace
            
            beam.Attachment0 = attachment0
            beam.Attachment1 = attachment1
            beam.Parent = workspace
            
            currentBeam = {beam = beam, att0 = attachment0, att1 = attachment1}
            return currentBeam
        end
        
        local function UpdateBeam()
            if not K.Flags["ShowAimbot"] or not K.Flags["AimbotEnabled"] or not K.Flags["TargetingEnabled"] then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not _G.targeting_state or not _G.targeting_state.current then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not currentBeam then
                currentBeam = CreateBeam()
            end
            
            -- Проверяем наличие оружия с handle
            local tool = _G.TargetingFramework and _G.TargetingFramework.utility and _G.TargetingFramework.utility:getHeld()
            if not tool or tool == "None" or not tool.Handle then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not tool.Handle then return end
            local origin = tool.Handle.Position
            
            local targetPlayer = _G.targeting_state.current
            local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
            if not targetPart then return end
            
            local function GetPredictedPosition(targetPlayer)
                if not targetPlayer or not targetPlayer.Character then return nil end
                
                local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
                if not targetPart then return nil end
                
                -- Получаем актуальные значения из UI
                local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
                local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
                local velocity = targetPart.Velocity or B(0, 0, 0)
                
                -- Используем логику как в примере кода
                local predicted = targetPart.Position + B(
                    velocity.X * xzPrediction,
                    velocity.Y * yPrediction,
                    velocity.Z * xzPrediction
                )
                
                return predicted
            end
            
            local predictedPos = GetPredictedPosition(targetPlayer)
            currentBeam.att0.WorldPosition = origin
            currentBeam.att1.WorldPosition = predictedPos
        end
        
        -- Инициализация beam connection отложена до включения функции
        local function StartBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
            end
            beamConnection = b.Heartbeat:Connect(UpdateBeam)
        end
        
        local function StopBeamVisualization()
            if beamConnection then
                beamConnection:Disconnect()
                beamConnection = nil
            end
            if currentBeam then
                currentBeam.beam:Destroy()
                currentBeam.att0:Destroy()
                currentBeam.att1:Destroy()
                currentBeam = nil
            end
        end
        
        _G.BeamVisualization = {
            StartBeamVisualization = StartBeamVisualization,
            StopBeamVisualization = StopBeamVisualization,
            cleanup = function()
                StopBeamVisualization()
            end
        }
    end
    
    do -- Hide Framework
        local HideFramework = {}
        local hideConnection = nil
        local isHiding = false
        local isPaused = false
        local lastHideTime = 0
        local hideInterval = 0.1
        
        local function getRandomVoidPosition()
            local x = h() * 5000 - 1000 -- random от -1000 до 1000
            local y = -100000 -- -math.huge
            local z = h() * 5000 - 1000 -- random от -1000 до 1000
            return B(x, y, z)
        end
        
        function HideFramework.start()
            if isHiding then return end
            
            isHiding = true
            K:Notification("Hide enabled", 2, z(128, 0, 128))
            
            hideConnection = b.Heartbeat:Connect(function()
                if not isHiding then
                    if hideConnection then
                        hideConnection:Disconnect()
                        hideConnection = nil
                    end
                    return
                end
                
                -- Проверяем паузу
                if isPaused then
                    -- Просто выходим на паузе, не синхронизируемся
                    return
                end
                
                -- Проверяем флаг
                if not K.Flags["HideEnabled"] then
                    if hideConnection then
                        hideConnection:Disconnect()
                        hideConnection = nil
                    end
                    isHiding = false
                    return
                end
                
                -- Используем десинк для прятания в войде
                if getgenv().DesyncLibrary then
                    local currentTime = os.clock()
                    if currentTime - lastHideTime >= hideInterval then
                        lastHideTime = currentTime
                        local voidPos = getRandomVoidPosition()
                        getgenv().DesyncLibrary.movedesyncto(voidPos.X, voidPos.Y, voidPos.Z)
                    end
                end
            end)
        end
        
        function HideFramework.stop()
            isHiding = false
            isPaused = false
            
            if hideConnection then
                hideConnection:Disconnect()
                hideConnection = nil
            end
            
            -- Синхронизируемся при остановке
            if getgenv().DesyncLibrary then
                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
            end
            
            K:Notification("Hide disabled", 2, z(255, 0, 0))
        end
        
        function HideFramework.pause()
            isPaused = true
        end
        
        function HideFramework.resume()
            isPaused = false
            -- При возобновлении сразу применяем Hide позицию если фреймворк активен
            if isHiding and getgenv().DesyncLibrary then
                local voidPos = getRandomVoidPosition()
                getgenv().DesyncLibrary.movedesyncto(voidPos.X, voidPos.Y, voidPos.Z)
                print("[Hide] Resumed and applied hide position")
            end
        end
        
        function HideFramework.isEnabled()
            return isHiding
        end
        
        function HideFramework.isPaused()
            return isPaused
        end
        
        _G.HideFramework = HideFramework
    end
    
    do -- Auto Stomp Framework
        local AutoStompFramework = {}
        local stompConnection = nil
        local isStomping = false
        local isPaused = false
        local lastStompTime = 0
        local stompInterval = 0.1
        
        local function isPlayerKO(player)
            if not player or not player.Character then return false end
            
            local bodyEffects = player.Character:FindFirstChild("BodyEffects")
            if not bodyEffects then return false end
            
            local ko = bodyEffects:FindFirstChild("K.O")
            if ko and ko.Value == true then return true end
            
            return false
        end
        
        local function performStomp()
            local args = {"Stomp"}
            local mainRemoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("MainRemotes"):WaitForChild("MainRemoteEvent")
            if mainRemoteEvent then
                mainRemoteEvent:FireServer(unpack(args))
            end
        end
        
        function AutoStompFramework.start()
            if isStomping then return end
            
            isStomping = true
            K:Notification("Auto Stomp enabled", 2, z(0, 255, 0))
            
            -- Простой подход с проверкой паузы
            stompConnection = b.Heartbeat:Connect(function()
                if not isStomping then
                    if stompConnection then
                        stompConnection:Disconnect()
                        stompConnection = nil
                    end
                    return
                end
                
                -- Проверяем паузу
                if isPaused then
                    -- Просто выходим на паузе, не синхронизируемся
                    return
                end
                
                local currentTarget = _G.TargetingFramework:GetCurrentTarget()
                
                -- Проверяем приоритет Hide ТОЛЬКО если нет K.O цели
                -- Если есть K.O цель, AutoStomp имеет приоритет над Hide
                if not currentTarget or not currentTarget.Character or not isPlayerKO(currentTarget) then
                    -- Нет K.O цели - Hide может блокировать AutoStomp
                    if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                        return
                    end
                end
                if not currentTarget then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                        -- Ждем немного после синхронизации, затем возобновляем Hide
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and _G.HideFramework.isPaused() then
                            _G.HideFramework.resume()
                        end
                    end
                    return 
                end
                
                if not currentTarget.Character then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                        -- Ждем немного после синхронизации, затем возобновляем Hide
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and _G.HideFramework.isPaused() then
                            _G.HideFramework.resume()
                        end
                    end
                    return 
                end
                
                if not isPlayerKO(currentTarget) then 
                    -- Синхронизируемся только если НЕ на паузе (чтобы не мешать AutoArmor)
                    if not isPaused and getgenv().DesyncLibrary then
                        pcall(function()
                            getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        end)
                        -- Ждем немного после синхронизации, затем возобновляем Hide
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and _G.HideFramework.isPaused() then
                            _G.HideFramework.resume()
                        end
                    end
                    return 
                end
                
                -- Если дошли до сюда - есть K.O цель, приостанавливаем Hide если он активен
                if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                    _G.HideFramework.pause()
                end
                
                local upperTorso = currentTarget.Character:FindFirstChild("UpperTorso")
                if not upperTorso then return end
                
                -- Используем десинк для стомпа
                if getgenv().DesyncLibrary then
                    local pos = upperTorso.Position
                    getgenv().DesyncLibrary.movedesyncto(pos.X, pos.Y + 1, pos.Z)
                    
                    local currentTime = os.clock()
                    if currentTime - lastStompTime >= stompInterval then
                        lastStompTime = currentTime
                        performStomp()
                    end
                end
            end)
        end
        
        function AutoStompFramework.stop()
            isStomping = false
            isPaused = false
            
            if stompConnection then
                stompConnection:Disconnect()
                stompConnection = nil
            end
            
            -- Синхронизируемся при остановке
            if getgenv().DesyncLibrary then
                getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
            end
            
            K:Notification("Auto Stomp disabled", 2, z(255, 0, 0))
        end
        
        function AutoStompFramework.pause()
            isPaused = true
        end
        
        function AutoStompFramework.resume()
            isPaused = false
        end
        
        function AutoStompFramework.isEnabled()
            return isStomping
        end
        
        _G.AutoStompFramework = AutoStompFramework
    end

    do -- AutoArmor Framework
        local AutoArmorFramework = {}
        local armorConnection = nil
        local ARMOR_THRESHOLD = 199
        local isBuying = false
        
        local function GetArmorItem()
            local shop = workspace.Ignored and workspace.Ignored.Shop
            if shop then
                local armorItem = shop:FindFirstChild("[Full Armor] - $1659")
                return armorItem
            end
            return nil
        end
        
        local function BuyArmor()
            if not K.Flags["AutoArmorEnabled"] then 
                return 
            end
            if isBuying then 
                print("[AutoArmor] Already buying, skipping")
                return 
            end
            
            local player = g
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                print("[AutoArmor] No character or HumanoidRootPart")
                return
            end
            
            local bodyEffects = player.Character:FindFirstChild("BodyEffects")
            if not bodyEffects then 
                print("[AutoArmor] No BodyEffects found")
                return
            end
            
            local armorValue = bodyEffects:FindFirstChild("Armor")
            if not armorValue then 
                print("[AutoArmor] No Armor value found in BodyEffects")
                return
            end
            
            local armorItem = GetArmorItem()
            if not armorItem then 
                print("[AutoArmor] Armor item not found in shop")
                return 
            end
            
            local currentArmor = armorValue.Value
            print("[AutoArmor] Current armor:", currentArmor, "Threshold:", ARMOR_THRESHOLD)
            
            if currentArmor > ARMOR_THRESHOLD then 
                return 
            end
            
            print("[AutoArmor] Starting armor purchase, current armor:", currentArmor)
            isBuying = true
            
            -- ОСТАНАВЛИВАЕМ другие фреймворки если они включены (приоритет AutoArmor)
            local wasStompEnabled = false
            local wasHideEnabled = false
            
            if _G.AutoStompFramework and _G.AutoStompFramework.isEnabled() then
                wasStompEnabled = true
                print("[AutoArmor] Pausing AutoStomp")
                _G.AutoStompFramework.pause()
            end
            
            if _G.HideFramework and _G.HideFramework.isEnabled() then
                wasHideEnabled = true
                print("[AutoArmor] Pausing Hide")
                _G.HideFramework.pause()
            end
            
            -- Используем новый desync фреймворк для покупки
            if getgenv().DesyncLibrary then
                K:Notification("[DEBUG] Buying armor, stomp paused: " .. tostring(wasStompEnabled), 3, z(255, 255, 0))
                print("[AutoArmor] Moving to armor shop with desync")
                
                local success, err = pcall(function()
                    -- Перемещаемся к объекту брони через новый desync API
                    getgenv().DesyncLibrary.movedesyncto(armorItem.Head.CFrame)
                    wait(0.3)
                    
                    print("[AutoArmor] Clicking armor detector")
                    -- Покупаем броню
                    fireclickdetector(armorItem.ClickDetector)
                    wait(0.5)
                    
                    print("[AutoArmor] Syncing with player")
                    -- Синхронизируемся с локальным игроком
                    getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                    
                    -- Проверяем, нужно ли восстановить Hide после синхронизации
                    task.wait(0.1) -- Небольшая задержка после синхронизации
                    if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                        local x = h() * 5000 - 1000
                        local y = -100000
                        local z = h() * 5000 - 1000
                        getgenv().DesyncLibrary.movedesyncto(x, y, z)
                        print("[AutoArmor] Restored Hide position after sync")
                    end
                end)
                
                if not success then
                    print("[AutoArmor] Error during purchase:", err)
                    -- В случае ошибки синхронизируемся с локальным игроком
                    pcall(function()
                        getgenv().DesyncLibrary.SynchronizeSyncWithPlayer()
                        
                        -- Проверяем, нужно ли восстановить Hide после синхронизации
                        task.wait(0.1)
                        if _G.HideFramework and _G.HideFramework.isEnabled() and not _G.HideFramework.isPaused() then
                            local x = h() * 5000 - 1000
                            local y = -100000
                            local z = h() * 5000 - 1000
                            getgenv().DesyncLibrary.movedesyncto(x, y, z)
                            print("[AutoArmor] Restored Hide position after error sync")
                        end
                    end)
                end
                
                -- Проверяем броню после покупки
                wait(0.2)
                local bodyEffectsAfter = player.Character:FindFirstChild("BodyEffects")
                if bodyEffectsAfter and bodyEffectsAfter:FindFirstChild("Armor") then
                    local newArmor = bodyEffectsAfter.Armor.Value
                print("[AutoArmor] Armor after purchase:", newArmor)
                
                    if newArmor >= 200 then
                        K:Notification("[DEBUG] Armor bought: " .. newArmor, 3, z(0, 255, 0))
                    else
                        K:Notification("[DEBUG] Armor purchase failed: " .. newArmor, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("[DEBUG] Cannot check armor after purchase", 3, z(255, 255, 0))
                end
            else
                print("[AutoArmor] DesyncLibrary not found!")
            end
            
            -- ВОЗОБНОВЛЯЕМ другие фреймворки если они были включены
            if wasHideEnabled and _G.HideFramework then
                print("[AutoArmor] Resuming Hide")
                _G.HideFramework.resume()
            end
            
            if wasStompEnabled and _G.AutoStompFramework then
                print("[AutoArmor] Resuming AutoStomp")
                _G.AutoStompFramework.resume()
                K:Notification("[DEBUG] Frameworks resumed", 2, z(0, 255, 255))
            end
            
            isBuying = false
            print("[AutoArmor] Purchase cycle completed")
        end
        
        local function StartAutoArmor()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
            
            if K.Flags["AutoArmorEnabled"] then
                print("[AutoArmor] Starting AutoArmor framework")
                local lastCheck = 0
                armorConnection = b.Heartbeat:Connect(function()
                    -- Проверяем флаг каждый кадр
                    if not K.Flags["AutoArmorEnabled"] then
                        if armorConnection then
                            armorConnection:Disconnect()
                            armorConnection = nil
                        end
                        return
                    end
                    
                    local currentTime = os.clock()
                    if currentTime - lastCheck >= 1 then
                        lastCheck = currentTime
                        BuyArmor()
                    end
                end)
            end
        end
        
        AutoArmorFramework.start = StartAutoArmor
        AutoArmorFramework.stop = function()
            if armorConnection then
                armorConnection:Disconnect()
                armorConnection = nil
            end
        end
        
        -- Обработка смерти игрока
        local function OnCharacterRemoving()
            if getgenv().DesyncLibrary then
                pcall(function()
                    getgenv().DesyncLibrary.StopDesync()
                end)
            end
        end
        
        local function OnCharacterAdded(character)
            if character then
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.Died:Connect(OnCharacterRemoving)
                end
            end
        end
        
        -- Подключаем обработчики смерти
        g.CharacterRemoving:Connect(OnCharacterRemoving)
        g.CharacterAdded:Connect(OnCharacterAdded)
        
        -- Если персонаж уже существует
        if g.Character then
            OnCharacterAdded(g.Character)
        end
        
        _G.AutoArmorFramework = AutoArmorFramework
    end
    
    do -- Circle Framework
        local CircleFramework = {
            enabled = false,
            c1 = z(128, 18, 255),
            c2 = z(255, 0, 128),
            c3 = z(0, 200, 255),
            c4 = z(255, 255, 0),
            speed = 1.0,
            radius = 2,
            sides = 48,
            thickness = 2.5,
            line_trs = 1.0,
            y_offset = 0,
            drawings = {},
            conn = nil,
            current_target = nil
        }
        
        local function ensure_lines()
            if #CircleFramework.drawings == CircleFramework.sides then return end
            for _, ln in ipairs(CircleFramework.drawings) do 
                pcall(function() ln:Remove() end) 
            end
            CircleFramework.drawings = {}
            for _ = 1, CircleFramework.sides do
                local ln = Drawing.new("Line")
                ln.ZIndex = 2
                ln.Thickness = CircleFramework.thickness
                ln.Visible = false
                p(CircleFramework.drawings, ln)
            end
        end
        
        local function set_visible_all(v)
            for _, ln in ipairs(CircleFramework.drawings) do 
                ln.Visible = v 
            end
        end
        
        local function cleanup_circle()
            if CircleFramework.conn then 
                CircleFramework.conn:Disconnect()
                CircleFramework.conn = nil 
            end
            for _, ln in ipairs(CircleFramework.drawings) do 
                pcall(function() ln:Remove() end) 
            end
            CircleFramework.drawings = {}
        end
        
        local function update_circle()
            if not CircleFramework.enabled then
                cleanup_circle()
                return
            end
            
            -- Получаем текущую цель из TargetingFramework
            local target_info = _G.TargetingFramework and _G.TargetingFramework._target and _G.TargetingFramework._target.info
            if not target_info or not target_info.player then
                set_visible_all(false)
                return
            end
            
            local target_player = target_info.player
            local char = target_player.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if not (char and root and hum and hum.Health > 0) then
                set_visible_all(false)
                return
            end
            
            ensure_lines()
            
            local pos = root.Position + B(0, CircleFramework.y_offset, 0)
            local root2d, onScreen = cam:WorldToViewportPoint(root.Position)
            if (not onScreen) or root2d.Z <= 0 then
                set_visible_all(false)
                return
            end
            
            local timeNow = tick()
            local tau = math.pi * 2
            
            for i = 1, CircleFramework.sides do
                local ln = CircleFramework.drawings[i]
                local f1 = (i / CircleFramework.sides)
                local a = f1 * tau
                local b = ((i % CircleFramework.sides) + 1) / CircleFramework.sides * tau
                
                local p1 = pos + B(o(a), 0, n(a)) * CircleFramework.radius
                local p2 = pos + B(o(b), 0, n(b)) * CircleFramework.radius
                
                local a2 = cam:WorldToViewportPoint(p1)
                local b2 = cam:WorldToViewportPoint(p2)
                
                local col = _G.TargetingFramework.circle_utility.custom_gradient(
                    f1, timeNow, 
                    CircleFramework.c1, CircleFramework.c2, 
                    CircleFramework.c3, CircleFramework.c4, 
                    CircleFramework.speed
                )
                
                ln.From = Vector2.new(a2.X, a2.Y)
                ln.To = Vector2.new(b2.X, b2.Y)
                ln.Color = col
                ln.Transparency = CircleFramework.line_trs
                ln.Thickness = CircleFramework.thickness
                ln.Visible = true
            end
        end
        
        function CircleFramework:SetEnabled(v)
            self.enabled = v
            if v then
                if not self.conn then
                    self.conn = E.new_connection(b.RenderStepped, update_circle)
                end
            else
                set_visible_all(false)
                cleanup_circle()
            end
        end
        
        function CircleFramework:SetRadius(r) 
            self.radius = r 
        end
        
        function CircleFramework:SetSides(n) 
            self.sides = math.clamp(n, 8, 256)
            ensure_lines() 
        end
        
        function CircleFramework:SetWidth(w) 
            self.thickness = w 
        end
        
        function CircleFramework:SetAlpha(t) 
            self.line_trs = t 
        end
        
        function CircleFramework:SetColors(c1, c2, c3, c4) 
            self.c1 = c1 or self.c1
            self.c2 = c2 or self.c2
            self.c3 = c3 or self.c3
            self.c4 = c4 or self.c4
        end
        
        function CircleFramework:SetYOffset(y) 
            self.y_offset = y 
        end
        
        _G.CircleFramework = CircleFramework
    end
    
    do -- Snapline Framework
        local SnaplineFramework = {
            enabled = false,
            origin = "center", -- bot, top, center, mouse
            color = z(255, 255, 255),
            outline_color = z(0, 0, 0),
            thickness = 1.5,
            outline_thickness = 3.0,
            transparency = 1.0,
            outline_transparency = 1.0,
            line = nil,
            outline_line = nil,
            conn = nil
        }
        
        local function cleanup_snapline()
            if SnaplineFramework.conn then 
                SnaplineFramework.conn:Disconnect()
                SnaplineFramework.conn = nil 
            end
            if SnaplineFramework.line then 
                pcall(function() SnaplineFramework.line:Remove() end)
                SnaplineFramework.line = nil
            end
            if SnaplineFramework.outline_line then 
                pcall(function() SnaplineFramework.outline_line:Remove() end)
                SnaplineFramework.outline_line = nil
            end
        end
        
        local function get_origin_position()
            local origin_pos
            if SnaplineFramework.origin == "bot" then
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y)
            elseif SnaplineFramework.origin == "top" then
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, 0)
            elseif SnaplineFramework.origin == "center" then
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y / 2)
            elseif SnaplineFramework.origin == "mouse" then
                origin_pos = c:GetMouseLocation()
            else
                origin_pos = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y / 2)
            end
            return origin_pos
        end
        
        local function update_snapline()
            if not SnaplineFramework.enabled then
                cleanup_snapline()
                return
            end
            
            -- Получаем текущую цель из TargetingFramework
            local target_info = _G.TargetingFramework and _G.TargetingFramework._target and _G.TargetingFramework._target.info
            if not target_info or not target_info.player then
                if SnaplineFramework.line then
                    SnaplineFramework.line.Visible = false
                end
                if SnaplineFramework.outline_line then
                    SnaplineFramework.outline_line.Visible = false
                end
                return
            end
            
            local target_player = target_info.player
            local char = target_player.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if not (char and root and hum and hum.Health > 0) then
                if SnaplineFramework.line then
                    SnaplineFramework.line.Visible = false
                end
                if SnaplineFramework.outline_line then
                    SnaplineFramework.outline_line.Visible = false
                end
                return
            end
            
            -- Создаем outline линию если её нет
            if not SnaplineFramework.outline_line then
                SnaplineFramework.outline_line = Drawing.new("Line")
                SnaplineFramework.outline_line.ZIndex = 0
            end
            
            -- Создаем основную линию если её нет
            if not SnaplineFramework.line then
                SnaplineFramework.line = Drawing.new("Line")
                SnaplineFramework.line.ZIndex = 1
            end
            
            local target_pos, onScreen = cam:WorldToViewportPoint(root.Position)
            if not onScreen or target_pos.Z <= 0 then
                SnaplineFramework.line.Visible = false
                SnaplineFramework.outline_line.Visible = false
                return
            end
            
            local origin_pos = get_origin_position()
            local target_2d = Vector2.new(target_pos.X, target_pos.Y)
            
            -- Настройка outline линии
            SnaplineFramework.outline_line.From = origin_pos
            SnaplineFramework.outline_line.To = target_2d
            SnaplineFramework.outline_line.Color = SnaplineFramework.outline_color
            SnaplineFramework.outline_line.Thickness = SnaplineFramework.outline_thickness
            SnaplineFramework.outline_line.Transparency = SnaplineFramework.outline_transparency
            SnaplineFramework.outline_line.Visible = true
            
            -- Настройка основной линии
            SnaplineFramework.line.From = origin_pos
            SnaplineFramework.line.To = target_2d
            SnaplineFramework.line.Color = SnaplineFramework.color
            SnaplineFramework.line.Thickness = SnaplineFramework.thickness
            SnaplineFramework.line.Transparency = SnaplineFramework.transparency
            SnaplineFramework.line.Visible = true
        end
        
        function SnaplineFramework:SetEnabled(v)
            self.enabled = v
            if v then
                if not self.conn then
                    self.conn = E.new_connection(b.RenderStepped, update_snapline)
                end
            else
                cleanup_snapline()
            end
        end
        
        function SnaplineFramework:SetOrigin(origin)
            self.origin = origin
        end
        
        function SnaplineFramework:SetColor(color)
            self.color = color
        end
        
        function SnaplineFramework:SetThickness(thickness)
            self.thickness = thickness
        end
        
        function SnaplineFramework:SetTransparency(transparency)
            self.transparency = transparency
        end
        
        function SnaplineFramework:SetOutlineColor(color)
            self.outline_color = color
        end
        
        function SnaplineFramework:SetOutlineThickness(thickness)
            self.outline_thickness = thickness
        end
        
        function SnaplineFramework:SetOutlineTransparency(transparency)
            self.outline_transparency = transparency
        end
        
        _G.SnaplineFramework = SnaplineFramework
    end
    
    do -- HitChams Framework
        local HitChamsFramework = {
            enabled = false
        }
        
        function HitChamsFramework:SetEnabled(value)
            self.enabled = value
        end
        
        function HitChamsFramework:TriggerHitChams(player)
            if not self.enabled then return end
            if _G.TargetingFramework and _G.TargetingFramework.utility then
                _G.TargetingFramework.utility:createHitChams(player)
            end
        end
        
        _G.HitChamsFramework = HitChamsFramework
    end
end -- End Ragebot Tab

do -- Visuals Tab
    do -- Target Section
        local targetSection = N:Section({Name = "Target", Side = 1})
        
        -- Target Highlight структура данных
        local bZ = {
            hl = nil,           -- основной highlight объект
            char_added_conn = nil,     -- соединение CharacterAdded
            char_removing_conn = nil,  -- соединение CharacterRemoving
            died_conn = nil,           -- соединение Died
            bound_player = nil,        -- привязанный игрок
            last_char = nil,           -- последний персонаж
        }
        
        -- Функция создания highlight
        local function c0()
            local c1 = Instance.new("Highlight")
            c1.Name = "RB_HL_32v"
            c1.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            return c1
        end
        
        -- Функция очистки highlight
        local function c8()
            if bZ.hl then
                bZ.hl:Destroy()
                bZ.hl = nil
            end
        end
        
        -- Функция применения highlight
        local function ce(a3) -- a3 = character
            if not a3 or not K.Flags or not K.Flags["target_highlight"] then
                c8() -- cleanup
                return
            end
            
            -- Создаем highlight объект если его нет
            if not bZ.hl then
                bZ.hl = c0()
            end
            
            -- Настраиваем основной highlight
            local c1 = bZ.hl
            c1.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            
            -- Получаем цвета и transparency из флагов (как в других колорпикерах скрипта)
            local fillColor = K.Flags["target_highlight_fill"]
            local fillAlpha = K.Flags["target_highlight_fill_alpha"]
            local outlineColor = K.Flags["target_highlight_outline"]
            local outlineAlpha = K.Flags["target_highlight_outline_alpha"]
            
            -- Применяем Fill Color и Transparency
            c1.FillColor = fillColor or z(255, 255, 0)
            c1.FillTransparency = fillAlpha or 0.5
            
            -- Применяем Outline Color и Transparency
            c1.OutlineColor = outlineColor or z(0, 0, 0)
            c1.OutlineTransparency = outlineAlpha or 0.5
            
            c1.Adornee = a3
            c1.Parent = a3
            c1.Enabled = true
            
            bZ.last_char = a3
        end
        
        -- Функция настройки Died connection
        local function cg(a3) -- a3 = character
            if not a3 then return end
            
            local aA = a3:FindFirstChildOfClass("Humanoid")
            if aA then
                if bZ.died_conn then
                    bZ.died_conn:Disconnect()
                end
                
                -- При смерти - убираем визуальный highlight
                bZ.died_conn = aA.Died:Connect(function()
                    c8() -- cleanup highlights
                end)
            end
        end
        
        -- Ключевая функция привязки к игроку
        local function cj(az) -- az = player
            if not az then return end
            
            -- Отключаем старые соединения
            if bZ.char_added_conn then
                bZ.char_added_conn:Disconnect()
            end
            if bZ.char_removing_conn then
                bZ.char_removing_conn:Disconnect()
            end
            
            bZ.bound_player = az
            
            -- При удалении персонажа - очищаем highlight
            bZ.char_removing_conn = az.CharacterRemoving:Connect(function(ck)
                c8() -- cleanup highlights
            end)
            
            -- ВОТ КЛЮЧЕВАЯ ЛОГИКА - при появлении нового персонажа:
            bZ.char_added_conn = az.CharacterAdded:Connect(function(ck)
                if not ck then return end
                
                b.Heartbeat:Wait()
                
                -- ПРОВЕРЯЕМ - является ли этот игрок текущей целью
                local cl = _G.targeting_state and _G.targeting_state.current and
                    (_G.targeting_state.current == az or 
                     (_G.targeting_state.current.UserId and _G.targeting_state.current.UserId == az.UserId))
                
                -- Если да И включен target_highlight - ВОССТАНАВЛИВАЕМ highlight
                if cl and K.Flags and K.Flags["target_highlight"] then
                    ce(ck)  -- применяем highlight к новому персонажу
                    cg(ck)  -- настраиваем died connection
                end
            end)
            
            -- Если у игрока уже есть персонаж - применяем сразу
            if az.Character then
                ce(az.Character)
                cg(az.Character)
            end
        end
        
        -- Тогл для Target Highlight
        local _targetHighlightToggle = targetSection:Toggle({
            Name = "Highlight",
            Default = false,
            Flag = "target_highlight",
            Callback = function(value)
                if value then
                    -- Если включили highlight и есть текущая цель
                    if _G.TargetingFramework and _G.TargetingFramework._target and _G.TargetingFramework._target.info then
                        local targetInfo = _G.TargetingFramework._target.info
                        if targetInfo.player then
                            cj(targetInfo.player)
                        end
                    end
                else
                    -- Если выключили highlight - очищаем все
                    c8()
                    if bZ.char_added_conn then
                        bZ.char_added_conn:Disconnect()
                        bZ.char_added_conn = nil
                    end
                    if bZ.char_removing_conn then
                        bZ.char_removing_conn:Disconnect()
                        bZ.char_removing_conn = nil
                    end
                    if bZ.died_conn then
                        bZ.died_conn:Disconnect()
                        bZ.died_conn = nil
                    end
                end
            end
        })
        
        -- Колорпикер для Fill Color с поддержкой transparency
        _targetHighlightToggle:Colorpicker({
            Name = "Fill Color",
            Default = z(255, 255, 0),
            Alpha = 0.5, -- Включаем слайдер transparency
            Flag = "target_highlight_fill",
            Callback = function(color, alpha)
                -- Сохраняем цвет и alpha отдельно в флаги (как в других колорпикерах)
                K.Flags["target_highlight_fill"] = color
                K.Flags["target_highlight_fill_alpha"] = alpha
                
                -- Обновляем цвет и transparency если highlight активен
                if bZ.hl and bZ.hl.Parent then
                    bZ.hl.FillColor = color
                    bZ.hl.FillTransparency = alpha or 0.5
                end
                -- Пересоздаем highlight с новыми настройками если есть текущая цель
                if bZ.bound_player and bZ.bound_player.Character then
                    ce(bZ.bound_player.Character)
                end
            end
        })
        
        -- Колорпикер для Outline Color с поддержкой transparency
        _targetHighlightToggle:Colorpicker({
            Name = "Outline Color", 
            Default = z(0, 0, 0),
            Alpha = 0.5, -- Включаем слайдер transparency
            Flag = "target_highlight_outline",
            Callback = function(color, alpha)
                -- Сохраняем цвет и alpha отдельно в флаги (как в других колорпикерах)
                K.Flags["target_highlight_outline"] = color
                K.Flags["target_highlight_outline_alpha"] = alpha
                
                -- Обновляем цвет и transparency если highlight активен
                if bZ.hl and bZ.hl.Parent then
                    bZ.hl.OutlineColor = color
                    bZ.hl.OutlineTransparency = alpha or 0.5
                end
                -- Пересоздаем highlight с новыми настройками если есть текущая цель
                if bZ.bound_player and bZ.bound_player.Character then
                    ce(bZ.bound_player.Character)
                end
            end
        })
        
        -- Подключаемся к изменениям цели
        if _G.TargetingFramework then
            _G.TargetingFramework:OnTargetUpdate(function(targetInfo)
                if K.Flags and K.Flags["target_highlight"] then
                    if targetInfo and targetInfo.player then
                        cj(targetInfo.player)
                    else
                        c8()
                    end
                end
            end)
        end
        
        _G.TargetHighlight = {
            bZ = bZ,
            c0 = c0,
            c8 = c8,
            ce = ce,
            cg = cg,
            cj = cj
        }
        
        -- Circle Toggle
        local _targetCircleToggle = targetSection:Toggle({
            Name = "Circle",
            Default = false,
            Flag = "target_circle",
            Callback = function(value)
                if _G.CircleFramework then
                    _G.CircleFramework:SetEnabled(value)
                end
            end
        })
        
        -- Circle Color 1
        _targetCircleToggle:Colorpicker({
            Name = "Color 1",
            Default = z(128, 18, 255),
            Flag = "circle_color1",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c1 = color
                end
            end
        })
        
        -- Circle Color 2
        _targetCircleToggle:Colorpicker({
            Name = "Color 2",
            Default = z(255, 0, 128),
            Flag = "circle_color2",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c2 = color
                end
            end
        })
        
        -- Circle Color 3
        _targetCircleToggle:Colorpicker({
            Name = "Color 3",
            Default = z(0, 200, 255),
            Flag = "circle_color3",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c3 = color
                end
            end
        })
        
        -- Circle Color 4
        _targetCircleToggle:Colorpicker({
            Name = "Color 4",
            Default = z(255, 255, 0),
            Flag = "circle_color4",
            Callback = function(color)
                if _G.CircleFramework then
                    _G.CircleFramework.c4 = color
                end
            end
        })
        
        -- Snapline Toggle
        local _targetSnaplineToggle = targetSection:Toggle({
            Name = "Snapline",
            Default = false,
            Flag = "target_snapline",
            Callback = function(value)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetEnabled(value)
                end
            end
        })
        
        -- Snapline Origin Dropdown (размещен сразу после Toggle, как в resolver type)
        local _snaplineOriginDropdown = targetSection:Dropdown({
            Name = "Origin",
            Items = {"Bot", "Top", "Center", "Mouse"},
            Default = "Center",
            Flag = "snapline_origin",
            Callback = function(value)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetOrigin(v(value))
                end
            end
        })
        
        -- Snapline Color
        _targetSnaplineToggle:Colorpicker({
            Name = "Color",
            Default = z(255, 255, 255),
            Alpha = 1.0,
            Flag = "snapline_color",
            Callback = function(color, alpha)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetColor(color)
                    _G.SnaplineFramework:SetTransparency(alpha or 1.0)
                end
            end
        })
        
        -- Snapline Outline Color
        _targetSnaplineToggle:Colorpicker({
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 1.0,
            Flag = "snapline_outline_color",
            Callback = function(color, alpha)
                if _G.SnaplineFramework then
                    _G.SnaplineFramework:SetOutlineColor(color)
                    _G.SnaplineFramework:SetOutlineTransparency(alpha or 1.0)
                end
            end
        })
        
    end
    
    do -- OnTargetDamaged Section
        local onTargetDamagedSection = N:Section({Name = "OnTargetDamaged", Side = 1})
        
        -- Chams Toggle
        local _chamsToggle = onTargetDamagedSection:Toggle({
            Name = "Chams",
            Default = false,
            Flag = "hit_chams",
            Callback = function(value)
                if _G.HitChamsFramework then
                    _G.HitChamsFramework:SetEnabled(value)
                end
            end
        })
        
        -- Chams Color Picker
        _chamsToggle:Colorpicker({
            Name = "Color",
            Default = z(255, 0, 0),
            Alpha = 0.0,
            Flag = "hit_chams_color",
            Callback = function(color, alpha)
                -- Сохраняем цвет и прозрачность в флаги
                K.Flags["hit_chams_color"] = color
                K.Flags["hit_chams_alpha"] = alpha
            end
        })
        
        -- Chams Material Dropdown
        local _chamsMaterialDropdown = onTargetDamagedSection:Dropdown({
            Name = "Material",
            Items = {"Neon", "ForceField", "Glass", "SmoothPlastic", "Plastic", "Metal"},
            Default = "Neon",
            Flag = "hit_chams_material",
            Callback = function(value)
                K.Flags["hit_chams_material"] = value
            end
        })
        
        -- HitSounds Toggle
        local _hitSoundsToggle = onTargetDamagedSection:Toggle({
            Name = "HitSounds",
            Default = false,
            Flag = "hit_sounds",
            Callback = function(value)
                -- Создаем папку для звуков при включении
                if value and _G.TargetingFramework and _G.TargetingFramework.utility then
                    _G.TargetingFramework.utility:createSoundsFolder()
                end
            end
        })
        
        -- HitSounds Selection Dropdown
        local _hitSoundsSelectionDropdown = onTargetDamagedSection:Dropdown({
            Name = "Sound",
            Items = availableSounds,
            Default = availableSounds[1] or "1",
            Flag = "hit_sounds_selection",
            Callback = function(value)
                K.Flags["hit_sounds_selection"] = value
            end
        })
        
        -- HitSounds Volume Slider
        local _hitSoundsVolumeSlider = onTargetDamagedSection:Slider({
            Name = "Volume",
            Min = 0,
            Max = 10,
            Default = 0.5,
            Suffix = "",
            Decimals = 0.01,
            Flag = "hit_sounds_volume",
            Callback = function(value)
                K.Flags["hit_sounds_volume"] = value
            end
        })
        
        -- HitSounds Pitch Slider
        local _hitSoundsPitchSlider = onTargetDamagedSection:Slider({
            Name = "Pitch",
            Min = 0.1,
            Max = 3.0,
            Default = 1.0,
            Suffix = "",
            Decimals = 0.01,
            Flag = "hit_sounds_pitch",
            Callback = function(value)
                K.Flags["hit_sounds_pitch"] = value
            end
        })
        
    end
    
    do -- Local Section
        local localSection = N:Section({Name = "Local", Side = 1})
        
        -- Local Highlight и SelfMaterial структура данных
        local localHighlightData = {
            hl = nil,
            char_added_conn = nil,
            char_removing_conn = nil,
            died_conn = nil,
            original_materials = {},  -- хранение оригинальных материалов
            original_colors = {},      -- хранение оригинальных цветов
            selfMaterialConnection = nil,
            selfMaterialChildConn = nil,
            appearanceConn = nil  -- добавляем поле для CharacterAppearanceLoaded
        }
        
        -- R15 части тела для проверки
        local R15Parts = {
            ["Head"] = true,
            ["UpperTorso"] = true, ["LowerTorso"] = true,
            ["LeftUpperArm"] = true, ["LeftLowerArm"] = true, ["LeftHand"] = true,
            ["RightUpperArm"] = true, ["RightLowerArm"] = true, ["RightHand"] = true,
            ["LeftUpperLeg"] = true, ["LeftLowerLeg"] = true, ["LeftFoot"] = true,
            ["RightUpperLeg"] = true, ["RightLowerLeg"] = true, ["RightFoot"] = true,
            ["HumanoidRootPart"] = true
        }
        
        -- Функция создания local highlight
        local function createLocalHighlight()
            local highlight = Instance.new("Highlight")
            highlight.Name = "LOCAL_HL_32v"
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            return highlight
        end
        
        -- Функция применения ForceField материала (логика из anotherscript)
        local function ApplyForceFieldBody(character)
            if not character then return end
            
            local selfColor = K.Flags["self_material_color"] or z(255, 255, 255)
            local selfTransparency = K.Flags["self_material_transparency"] or 0
            
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") and R15Parts[part.Name] then
                    -- Сохраняем оригинальный цвет перед изменением
                    if not localHighlightData.original_colors[part.Name] then
                        localHighlightData.original_colors[part.Name] = part.Color
                    end
                    if not localHighlightData.original_materials[part.Name] then
                        localHighlightData.original_materials[part.Name] = part.Material
                    end
                    
                    -- Применяем ForceField материал и цвет всегда
                    part.Material = Enum.Material.ForceField
                    part.Color = selfColor
                    -- Не меняем прозрачность HumanoidRootPart
                    if part.Name ~= "HumanoidRootPart" then
                        part.Transparency = selfTransparency
                    end
                end
            end
        end
        
        -- Функция скрытия одежды
        local function HideClothes(character)
            if not character then return end
            local folder = character:FindFirstChild("SimpleBotHiddenClothes")
            if not folder then
                folder = Instance.new("Folder")
                folder.Name = "SimpleBotHiddenClothes"
                folder.Parent = character
            end
            
            for _, obj in pairs(character:GetChildren()) do
                if obj:IsA("Shirt") or obj:IsA("Pants") or obj:IsA("ShirtGraphic") then
                    obj.Parent = folder
                end
            end
        end
        
        -- Функция восстановления одежды
        local function RestoreClothes(character)
            if not character then return end
            local folder = character:FindFirstChild("SimpleBotHiddenClothes")
            if folder then
                for _, obj in pairs(folder:GetChildren()) do
                    obj.Parent = character
                end
                folder:Destroy()
            end
        end
        
        -- Функция включения Self Material
        local function EnableSelfMaterial()
            if not K.Flags["self_material"] then return end
            if not g.Character then return end
            
            -- Очищаем сохраненные цвета при новом включении
            localHighlightData.original_colors = {}
            localHighlightData.original_materials = {}
            
            ApplyForceFieldBody(g.Character)
            HideClothes(g.Character)
            
            -- ChildAdded для новых частей
            if not localHighlightData.selfMaterialChildConn then
                localHighlightData.selfMaterialChildConn = g.Character.ChildAdded:Connect(function(obj)
                    if obj:IsA("BasePart") and R15Parts[obj.Name] then
                        if K.Flags["self_material"] then
                            -- Сохраняем оригинальный цвет новой части
                            if not localHighlightData.original_colors[obj.Name] then
                                localHighlightData.original_colors[obj.Name] = obj.Color
                            end
                            if not localHighlightData.original_materials[obj.Name] then
                                localHighlightData.original_materials[obj.Name] = obj.Material
                            end
                            
                            obj.Material = Enum.Material.ForceField
                            obj.Color = K.Flags["self_material_color"] or z(255, 255, 255)
                            if obj.Name ~= "HumanoidRootPart" then
                                obj.Transparency = K.Flags["self_material_transparency"] or 0
                            end
                        end
                    end
                end)
            end
            
            -- Обработчик респавна
            if not localHighlightData.selfMaterialConnection then
                localHighlightData.selfMaterialConnection = g.CharacterAdded:Connect(function(character)
                    -- Очищаем сохраненные данные при респавне
                    localHighlightData.original_colors = {}
                    localHighlightData.original_materials = {}
                    
                    -- Функция применения Self Material с задержками
                    local function applyWithDelay()
                        if K.Flags["self_material"] and character and g and g.Character == character then
                            ApplyForceFieldBody(character)
                            HideClothes(character)
                        end
                    end
                    
                    -- Применяем несколько раз с задержками для гарантии
                    task.delay(0.5, applyWithDelay)
                    task.delay(1.0, applyWithDelay)
                    task.delay(1.5, applyWithDelay)
                    
                    -- Обработчик CharacterAppearanceLoaded для применения после загрузки внешности
                    if localHighlightData.appearanceConn then
                        localHighlightData.appearanceConn:Disconnect()
                        localHighlightData.appearanceConn = nil
                    end
                    
                    localHighlightData.appearanceConn = g.CharacterAppearanceLoaded:Connect(function(loadedChar)
                        if loadedChar ~= character then return end
                        task.delay(0.2, applyWithDelay)
                    end)
                    
                    -- Переподключаем ChildAdded
                    if localHighlightData.selfMaterialChildConn then 
                        localHighlightData.selfMaterialChildConn:Disconnect() 
                    end
                    localHighlightData.selfMaterialChildConn = character.ChildAdded:Connect(function(obj)
                        if obj:IsA("BasePart") and R15Parts[obj.Name] then
                            if K.Flags["self_material"] then
                                -- Сохраняем оригинальный цвет новой части
                                if not localHighlightData.original_colors[obj.Name] then
                                    localHighlightData.original_colors[obj.Name] = obj.Color
                                end
                                if not localHighlightData.original_materials[obj.Name] then
                                    localHighlightData.original_materials[obj.Name] = obj.Material
                                end
                                
                                obj.Material = Enum.Material.ForceField
                                obj.Color = K.Flags["self_material_color"] or z(255, 255, 255)
                                if obj.Name ~= "HumanoidRootPart" then
                                    obj.Transparency = K.Flags["self_material_transparency"] or 0
                                end
                            end
                        end
                    end)
                end)
            end
        end
        
        -- Функция отключения Self Material
        local function DisableSelfMaterial()
            if localHighlightData.selfMaterialConnection then 
                localHighlightData.selfMaterialConnection:Disconnect() 
                localHighlightData.selfMaterialConnection = nil 
            end
            if localHighlightData.selfMaterialChildConn then 
                localHighlightData.selfMaterialChildConn:Disconnect() 
                localHighlightData.selfMaterialChildConn = nil 
            end
            if localHighlightData.appearanceConn then
                localHighlightData.appearanceConn:Disconnect()
                localHighlightData.appearanceConn = nil
            end
            
            if g.Character then
                RestoreClothes(g.Character)
                for _, part in pairs(g.Character:GetChildren()) do
                    if part:IsA("BasePart") and R15Parts[part.Name] then
                        part.Material = Enum.Material.Plastic
                        -- Восстанавливаем оригинальный цвет или используем стандартный
                        if localHighlightData.original_colors[part.Name] then
                            part.Color = localHighlightData.original_colors[part.Name]
                        else
                            -- Стандартные цвета для частей тела Roblox
                            if part.Name:find("Hand") or part.Name:find("Foot") or part.Name == "Head" then
                                part.Color = z(255, 204, 153)  -- Цвет кожи
                            else
                                part.Color = z(255, 204, 153)  -- Цвет кожи для всех частей
                            end
                        end
                        -- Восстанавливаем прозрачность
                        if part.Name ~= "HumanoidRootPart" then
                            part.Transparency = 0
                        end
                    end
                end
            end
        end
        
        -- Функция очистки local highlight
        local function cleanupLocalHighlight()
            if localHighlightData.hl then
                localHighlightData.hl:Destroy()
                localHighlightData.hl = nil
            end
        end
        
        -- Функция применения local highlight
        local function applyLocalHighlight(character)
            if not character or not K.Flags or not K.Flags["local_highlight"] then
                cleanupLocalHighlight()
                return
            end
            
            -- Создаем highlight объект если его нет
            if not localHighlightData.hl then
                localHighlightData.hl = createLocalHighlight()
            end
            
            local highlight = localHighlightData.hl
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            
            -- Получаем цвета и transparency из флагов
            local fillColor = K.Flags["local_highlight_fill"]
            local fillAlpha = K.Flags["local_highlight_fill_alpha"]
            local outlineColor = K.Flags["local_highlight_outline"]
            local outlineAlpha = K.Flags["local_highlight_outline_alpha"]
            
            -- Применяем Fill Color и Transparency
            highlight.FillColor = fillColor or z(255, 255, 0)
            highlight.FillTransparency = fillAlpha or 0.5
            
            -- Применяем Outline Color и Transparency
            highlight.OutlineColor = outlineColor or z(0, 0, 0)
            highlight.OutlineTransparency = outlineAlpha or 0.5
            
            highlight.Adornee = character
            highlight.Parent = character
            highlight.Enabled = true
        end
        
        -- Функция настройки Died connection для локального игрока
        local function setupLocalDiedConnection(character)
            if not character then return end
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                if localHighlightData.died_conn then
                    localHighlightData.died_conn:Disconnect()
                end
                
                localHighlightData.died_conn = humanoid.Died:Connect(function()
                    cleanupLocalHighlight()
                end)
            end
        end
        
        -- Функция привязки к локальному игроку
        local function bindToLocalPlayer()
            local localPlayer = g -- локальный игрок
            if not localPlayer then return end
            
            -- Отключаем старые соединения
            if localHighlightData.char_added_conn then
                localHighlightData.char_added_conn:Disconnect()
            end
            if localHighlightData.char_removing_conn then
                localHighlightData.char_removing_conn:Disconnect()
            end
            
            -- При удалении персонажа - очищаем highlight и очищаем сохраненные данные
            localHighlightData.char_removing_conn = localPlayer.CharacterRemoving:Connect(function(character)
                cleanupLocalHighlight()
                -- Очищаем сохраненные данные при удалении персонажа
                localHighlightData.original_materials = {}
                localHighlightData.original_colors = {}
            end)
            
            -- При добавлении персонажа - применяем все эффекты
            localHighlightData.char_added_conn = localPlayer.CharacterAdded:Connect(function(character)
                -- Ждем немного чтобы персонаж полностью загрузился
                task.wait(0.1)
                
                -- Применяем highlight если включен
                if K.Flags and K.Flags["local_highlight"] then
                    applyLocalHighlight(character)
                    setupLocalDiedConnection(character)
                end
            end)
            
            -- Если персонаж уже существует - применяем все эффекты сразу
            if localPlayer.Character then
                if K.Flags and K.Flags["local_highlight"] then
                    applyLocalHighlight(localPlayer.Character)
                    setupLocalDiedConnection(localPlayer.Character)
                end
            end
        end
        
        -- Local Highlight Toggle
        local _localHighlightToggle = localSection:Toggle({
            Name = "Highlight",
            Default = false,
            Flag = "local_highlight",
            Callback = function(value)
                if value then
                    bindToLocalPlayer()
                    -- Если персонаж уже есть - применяем highlight
                    if g and g.Character then
                        applyLocalHighlight(g.Character)
                        setupLocalDiedConnection(g.Character)
                    end
                else
                    cleanupLocalHighlight()
                    -- Отключаем соединения
                    if localHighlightData.char_added_conn then
                        localHighlightData.char_added_conn:Disconnect()
                        localHighlightData.char_added_conn = nil
                    end
                    if localHighlightData.char_removing_conn then
                        localHighlightData.char_removing_conn:Disconnect()
                        localHighlightData.char_removing_conn = nil
                    end
                    if localHighlightData.died_conn then
                        localHighlightData.died_conn:Disconnect()
                        localHighlightData.died_conn = nil
                    end
                end
            end
        })
        
        -- Self Material Toggle
        local _selfMaterialToggle = localSection:Toggle({
            Name = "Self Material",
            Default = false,
            Flag = "self_material",
            Callback = function(value)
                if value then
                    EnableSelfMaterial()
                else
                    DisableSelfMaterial()
                end
            end
        })
        
        -- Self Material Color Picker с прозрачностью
        _selfMaterialToggle:Colorpicker({
            Name = "Color",
            Default = z(255, 255, 255),
            Alpha = 0,
            Flag = "self_material_color",
            Callback = function(color, alpha)
                K.Flags["self_material_color"] = color
                K.Flags["self_material_transparency"] = alpha or 0
                -- Обновляем цвет и прозрачность если Self Material активен
                if K.Flags["self_material"] and g and g.Character then
                    -- Применяем новые цвет и прозрачность ко всем частям тела
                    for _, part in pairs(g.Character:GetChildren()) do
                        if part:IsA("BasePart") and R15Parts[part.Name] and part.Material == Enum.Material.ForceField then
                            part.Color = color
                            if part.Name ~= "HumanoidRootPart" then
                                part.Transparency = alpha or 0
                            end
                        end
                    end
                end
            end
        })
        
        -- Local Highlight Fill Color Picker
        _localHighlightToggle:Colorpicker({
            Name = "Fill Color",
            Default = z(255, 255, 0),
            Alpha = 0.5,
            Flag = "local_highlight_fill",
            Callback = function(color, alpha)
                K.Flags["local_highlight_fill"] = color
                K.Flags["local_highlight_fill_alpha"] = alpha
                -- Обновляем highlight если он активен
                if K.Flags["local_highlight"] and g and g.Character then
                    applyLocalHighlight(g.Character)
                end
            end
        })
        
        -- Local Highlight Outline Color Picker
        _localHighlightToggle:Colorpicker({
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 0.5,
            Flag = "local_highlight_outline",
            Callback = function(color, alpha)
                K.Flags["local_highlight_outline"] = color
                K.Flags["local_highlight_outline_alpha"] = alpha
                -- Обновляем highlight если он активен
                if K.Flags["local_highlight"] and g and g.Character then
                    applyLocalHighlight(g.Character)
                end
            end
        })
        
    end
    
    do -- idk Section
        local idkSection = N:Section({Name = "idk", Side = 1})
        
        -- Texture system state
        local texture_state = {
            enabled = false,
            material = "Plastic",
            original_materials = {},
            affected_parts = {}
        }
        
        -- Все доступные материалы в Roblox
        local materials_list = {
            "Plastic",
            "Wood",
            "WoodPlanks", 
            "Marble",
            "Basalt",
            "Slate",
            "CrackedLava",
            "Concrete",
            "Limestone",
            "Granite",
            "Pavement",
            "Brick",
            "Pebble",
            "Cobblestone",
            "Rock",
            "Sandstone",
            "CorrodedMetal",
            "DiamondPlate",
            "Foil",
            "Metal",
            "Grass",
            "LeafyGrass",
            "Sand",
            "Fabric",
            "Snow",
            "Mud",
            "Ground",
            "Asphalt",
            "Salt",
            "Ice",
            "Glass",
            "Neon",
            "ForceField",
            "Air",
            "Water",
            "Carpet",
            "CarpetShag",
            "Plaster",
            "CardBoard",
            "Leather",
            "Coal",
            "Rubber"
        }
        
        -- Utility функция для изменения материалов
        local function applyTextures()
            if not texture_state.enabled then
                -- Восстанавливаем оригинальные материалы
                for part, original_material in pairs(texture_state.original_materials) do
                    if part and part.Parent then
                        pcall(function()
                            part.Material = original_material
                        end)
                    end
                end
                texture_state.original_materials = {}
                texture_state.affected_parts = {}
                return
            end
            
            -- Сохраняем и изменяем материалы
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and obj.Parent ~= g.Character then
                    -- Сохраняем оригинальный материал если еще не сохранен
                    if not texture_state.original_materials[obj] then
                        texture_state.original_materials[obj] = obj.Material
                    end
                    
                    -- Применяем новый материал
                    pcall(function()
                        obj.Material = Enum.Material[texture_state.material]
                    end)
                    
                    texture_state.affected_parts[obj] = true
                end
            end
        end
        
        -- Функция обновления при изменении workspace
        local function setupWorkspaceListener()
            workspace.DescendantAdded:Connect(function(obj)
                if texture_state.enabled and obj:IsA("BasePart") and obj.Parent ~= g.Character then
                    task.wait(0.1) -- Небольшая задержка для загрузки объекта
                    if not texture_state.original_materials[obj] then
                        texture_state.original_materials[obj] = obj.Material
                    end
                    pcall(function()
                        obj.Material = Enum.Material[texture_state.material]
                    end)
                    texture_state.affected_parts[obj] = true
                end
            end)
        end
        
        -- Textures Toggle
        local _texturesToggle = idkSection:Toggle({
            Name = "Textures",
            Flag = "textures_enabled",
            Default = false,
            Callback = function(value)
                texture_state.enabled = value
                applyTextures()
            end
        })
        
        -- Material Dropdown
        local _materialDropdown = idkSection:Dropdown({
            Name = "Material Type",
            Items = materials_list,
            Default = "Plastic",
            Flag = "texture_material",
            Callback = function(value)
                texture_state.material = value
                if texture_state.enabled then
                    applyTextures()
                end
            end
        })
        
        -- Инициализация listener для новых объектов
        setupWorkspaceListener()
        
        -- Bullet Tracers система
        local bullet_tracers_state = {
            enabled = false,
            color1 = z(255, 255, 255),
            color2 = z(255, 0, 0),
            thickness = 1.0,
            style = "fent",
            texture = "rbxassetid://446111271",
            texture_mode = "Stretch",
            container = nil,
            connections = {}
        }
        
        -- Стили трейсеров
        local tracer_styles = {
            fent = {
                texture = "rbxassetid://446111271",
                mode = "Stretch"
            },
            lightning = {
                texture = "rbxassetid://14050932611",
                mode = "Stretch"
            },
            chain = {
                texture = "rbxassetid://12721435220",
                mode = "Static"
            },
            arrow = {
                texture = "rbxassetid://14051022203",
                mode = "Static"
            },
            ware = {
                texture = "rbxassetid://11829306338",
                mode = "Stretch"
            }
        }
        
        -- Функция создания трассера
        local function createTracer(startPos, endPos)
            if not bullet_tracers_state.enabled then 
                return 
            end
            
            if not bullet_tracers_state.container then
                bullet_tracers_state.container = Instance.new("Folder", workspace)
                bullet_tracers_state.container.Name = "TracerContainer"
            end
            
            local colorSequence = ColorSequence.new({
                ColorSequenceKeypoint.new(0, bullet_tracers_state.color1),
                ColorSequenceKeypoint.new(1, bullet_tracers_state.color2)
            })
            
            local startPart = Instance.new("Part", bullet_tracers_state.container)
            startPart.Size = Vector3.new(0, 0, 0)
            startPart.Massless = true
            startPart.Transparency = 1
            startPart.CanCollide = false
            startPart.Position = startPos
            startPart.Anchored = true
            
            local startAttachment = Instance.new("Attachment", startPart)
            
            local impactPart = Instance.new("Part", bullet_tracers_state.container)
            impactPart.Size = Vector3.new(0, 0, 0)
            impactPart.Transparency = 1
            impactPart.CanCollide = false
            impactPart.Position = endPos
            impactPart.Anchored = true
            impactPart.Material = Enum.Material.ForceField
            impactPart.Massless = true
            
            local impactAttachment = Instance.new("Attachment", impactPart)
            
            local beam = Instance.new("Beam", startPart)
            beam.FaceCamera = true
            beam.Color = colorSequence
            beam.Attachment0 = startAttachment
            beam.Attachment1 = impactAttachment
            beam.LightEmission = 6
            beam.LightInfluence = 1
            beam.Width0 = bullet_tracers_state.thickness
            beam.Width1 = bullet_tracers_state.thickness
            beam.Texture = bullet_tracers_state.texture
            beam.TextureMode = Enum.TextureMode[bullet_tracers_state.texture_mode]
            beam.TextureSpeed = 1
            beam.TextureLength = 1
            beam.Transparency = NumberSequence.new(0)
            
            -- Анимация исчезновения
            local elapsedTime = 0
            local fadeCoroutine = coroutine.create(function()
                while elapsedTime < 0.5 do
                    elapsedTime = elapsedTime + b.Heartbeat:Wait()
                end
                elapsedTime = 0
                while elapsedTime < 0.1 do
                    elapsedTime = elapsedTime + b.Heartbeat:Wait()
                    local alpha = elapsedTime / 0.1
                    beam.Transparency = NumberSequence.new(alpha)
                end
                startPart:Destroy()
                impactPart:Destroy()
            end)
            coroutine.resume(fadeCoroutine)
        end
        
        -- Функция очистки соединений
        local function cleanupTracerConnections()
            for _, connection in pairs(bullet_tracers_state.connections) do
                if connection then
                    pcall(function()
                        connection:Disconnect()
                    end)
                end
            end
            bullet_tracers_state.connections = {}
            
            if bullet_tracers_state.container then
                pcall(function()
                    bullet_tracers_state.container:Destroy()
                end)
                bullet_tracers_state.container = nil
            end
        end
        
        -- Функция инициализации трассеров
        local function setupBulletTracers()
            if not bullet_tracers_state.enabled then
                cleanupTracerConnections()
                return
            end
            
            -- Проверяем существование пути к BULLET_RAYS
            local ignored = workspace:FindFirstChild("Ignored")
            local siren = ignored and ignored:FindFirstChild("Siren")
            local radius = siren and siren:FindFirstChild("Radius")
            
            if not radius then
                return
            end
            
            -- Соединение для отслеживания новых BULLET_RAYS
            local childAddedConnection = radius.ChildAdded:Connect(function(object)
                if object.Name == "BULLET_RAYS" then
                    local ownerCharacterName = object:GetAttribute("OwnerCharacter")
                    if ownerCharacterName and ownerCharacterName == g.Name then
                        local startPos = object.CFrame.Position
                        local lookVector = object.CFrame.LookVector
                        
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
                        raycastParams.IgnoreWater = true
                        raycastParams.FilterDescendantsInstances = {g.Character}
                        
                        local ray = workspace:Raycast(startPos, lookVector * 1000, raycastParams)
                        if ray then
                            local endPos = ray.Position
                            createTracer(startPos, endPos)
                        end
                    end
                end
            end)
            
            -- Соединение для очистки BULLET_RAYS
            local renderSteppedConnection = b.RenderStepped:Connect(function()
                if bullet_tracers_state.enabled then
                    for _, child in pairs(radius:GetChildren()) do
                        if child.Name == "BULLET_RAYS" then
                            child:Destroy()
                        end
                    end
                end
            end)
            
            bullet_tracers_state.connections.childAdded = childAddedConnection
            bullet_tracers_state.connections.renderStepped = renderSteppedConnection
        end
        
        -- Bullet Tracers Toggle
        local _bulletTracersToggle = idkSection:Toggle({
            Name = "Bullet tracers",
            Flag = "bullet_tracers_enabled",
            Default = false,
            Callback = function(value)
                bullet_tracers_state.enabled = value
                setupBulletTracers()
            end
        })
        
        -- Bullet Tracers Color Picker 1
        _bulletTracersToggle:Colorpicker({
            Name = "Start Color",
            Default = z(255, 255, 255),
            Flag = "bullet_tracers_color1",
            Callback = function(color)
                bullet_tracers_state.color1 = color
            end
        })
        
        -- Bullet Tracers Color Picker 2
        _bulletTracersToggle:Colorpicker({
            Name = "End Color",
            Default = z(255, 0, 0),
            Flag = "bullet_tracers_color2",
            Callback = function(color)
                bullet_tracers_state.color2 = color
            end
        })
        
        -- Bullet Tracers Style Dropdown
        local _bulletTracersStyleDropdown = idkSection:Dropdown({
            Name = "Style",
            Items = {"fent", "lightning", "chain", "arrow", "ware"},
            Default = "fent",
            Flag = "bullet_tracers_style",
            Callback = function(value)
                bullet_tracers_state.style = value
                local style_data = tracer_styles[value]
                if style_data then
                    bullet_tracers_state.texture = style_data.texture
                    bullet_tracers_state.texture_mode = style_data.mode
                end
            end
        })
        
        -- Bullet Tracers Thickness Slider
        local _bulletTracersSlider = idkSection:Slider({
            Name = "Thickness",
            Min = 0.01,
            Max = 10,
            Default = 1.0,
            Decimals = 0.01,
            Suffix = "",
            Flag = "bullet_tracers_thickness",
            Callback = function(value)
                bullet_tracers_state.thickness = value
            end
        })
        
    end
    
    do -- Screen Section
        local screenSection = N:Section({Name = "Screen", Side = 1})
        
        -- FOV система
        local fov_state = {
            enabled = false,
            value = 70,
            original_fov = nil,
            connection = nil
        }
        
        -- Функция применения FOV
        local function applyFOV()
            if not fov_state.enabled then
                -- Восстанавливаем оригинальный FOV
                if fov_state.original_fov and workspace.CurrentCamera then
                    workspace.CurrentCamera.FieldOfView = fov_state.original_fov
                end
                
                -- Отключаем соединение
                if fov_state.connection then
                    pcall(function()
                        fov_state.connection:Disconnect()
                    end)
                    fov_state.connection = nil
                end
                return
            end
            
            local camera = workspace.CurrentCamera
            if not camera then
                return
            end
            
            -- Сохраняем оригинальный FOV при первом включении
            if not fov_state.original_fov then
                fov_state.original_fov = camera.FieldOfView
            end
            
            -- Применяем новый FOV
            camera.FieldOfView = fov_state.value
            
            -- Создаем соединение для постоянного применения FOV
            if not fov_state.connection then
                fov_state.connection = b.RenderStepped:Connect(function()
                    if fov_state.enabled and camera then
                        camera.FieldOfView = fov_state.value
                    end
                end)
            end
        end
        
        -- FOV Toggle
        local _fovToggle = screenSection:Toggle({
            Name = "FOV",
            Flag = "fov_enabled",
            Default = false,
            Callback = function(value)
                fov_state.enabled = value
                applyFOV()
            end
        })
        
        -- FOV Slider
        local _fovSlider = screenSection:Slider({
            Name = "FOV Value",
            Min = 60,
            Max = 120,
            Default = 70,
            Decimals = 1,
            Suffix = "°",
            Flag = "fov_value",
            Callback = function(value)
                fov_state.value = value
                if fov_state.enabled then
                    applyFOV()
                end
            end
        })
        
    end
    
    do -- Stuff Section
        local stuffSection = N:Section({Name = "Stuff", Side = 2})
        
        -- Aura utility functions
        local aura_utility = {}
        
        -- Aura система
        local aura_state = {
            enabled = false,
            mode = "Lighting",
            color = z(31, 226, 130), -- Цвет ауры по умолчанию
            attachments = {},
            beams = {},
            particle_emitters = {},
            cleanup_connections = {}
        }
        
        function aura_utility:cleanup()
            -- Отключаем все соединения
            for _, connection in pairs(aura_state.cleanup_connections) do
                if connection then
                    connection:Disconnect()
                end
            end
            aura_state.cleanup_connections = {}
            
            -- Удаляем Lighting элементы
            if aura_state.particle_emitter then
                aura_state.particle_emitter:Destroy()
                aura_state.particle_emitter = nil
            end
            
            if aura_state.flash_emitter then
                aura_state.flash_emitter:Destroy()
                aura_state.flash_emitter = nil
            end
            
            if aura_state.attachment then
                aura_state.attachment:Destroy()
                aura_state.attachment = nil
            end
            
            -- Удаляем FrostBlades элементы
            for _, beam in pairs(aura_state.beams) do
                if beam then
                    beam:Destroy()
                end
            end
            aura_state.beams = {}
            
            for _, attachment in pairs(aura_state.attachments) do
                if attachment then
                    attachment:Destroy()
                end
            end
            aura_state.attachments = {}
            
            for _, emitter in pairs(aura_state.particle_emitters) do
                if emitter then
                    emitter:Destroy()
                end
            end
            aura_state.particle_emitters = {}
        end
        
        function aura_utility:createAura()
            local localPlayer = g
            if not localPlayer or not localPlayer.Character then
                return
            end
            
            local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                return
            end
            
            -- Очищаем предыдущую ауру
            self:cleanup()
            
            -- Используем кастомный цвет ауры
            local auraColor = aura_state.color
            
            -- Создаем ауру в зависимости от режима
            if aura_state.mode == "Lighting" then
                self:createLightingAura(hrp, auraColor)
            elseif aura_state.mode == "FrostBlades" then
                self:createFrostBladesAura(hrp, auraColor)
            elseif aura_state.mode == "Charge" then
                self:createChargeAura(hrp, auraColor)
            elseif aura_state.mode == "Atomic" then
                self:createAtomicAura(hrp, auraColor)
            end
            
            -- Подключаемся к событиям персонажа
            self:setupCharacterEvents(localPlayer)
        end
        
        function aura_utility:createLightingAura(hrp, accentColor)
            -- Создаем RootAttachment
            local rootAttachment = Instance.new("Attachment")
            rootAttachment.Name = "RootAttachment"
            rootAttachment.Axis = B(1, 0, 0)
            rootAttachment.CFrame = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            rootAttachment.Orientation = B(-0, 0, 0)
            rootAttachment.Position = B(0, 0, 0)
            rootAttachment.SecondaryAxis = B(0, 1, 0)
            rootAttachment.Visible = false
            rootAttachment.Parent = hrp
            
            -- Создаем основной ParticleEmitter
            local particleEmitter = Instance.new("ParticleEmitter")
            particleEmitter.Name = "ParticleEmitter"
            particleEmitter.Acceleration = B(0, 0, 0)
            particleEmitter.Brightness = 1
            particleEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            particleEmitter.Drag = 0
            particleEmitter.EmissionDirection = Enum.NormalId.Top
            particleEmitter.Enabled = true
            particleEmitter.FlipbookFramerate = NumberRange.new(20, 20)
            particleEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid2x2
            particleEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            particleEmitter.FlipbookStartRandom = true
            particleEmitter.Lifetime = NumberRange.new(0.15, 0.15)
            particleEmitter.LightEmission = 1
            particleEmitter.LightInfluence = 0
            particleEmitter.LockedToPart = true
            particleEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
            particleEmitter.Rate = 4
            particleEmitter.RotSpeed = NumberRange.new(0, 0)
            particleEmitter.Rotation = NumberRange.new(-180, 180)
            particleEmitter.Shape = Enum.ParticleEmitterShape.Box
            particleEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            particleEmitter.ShapePartial = 1
            particleEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            particleEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 2)}
            particleEmitter.Speed = NumberRange.new(0.01, 0.01)
            particleEmitter.SpreadAngle = Vector2.new(0, 0)
            particleEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            particleEmitter.Texture = "http://www.roblox.com/asset/?id=12800314277"
            particleEmitter.TimeScale = 1
            particleEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            particleEmitter.VelocityInheritance = 0
            particleEmitter.ZOffset = 2
            particleEmitter.Parent = rootAttachment
            
            -- Создаем Flash ParticleEmitter
            local flashEmitter = Instance.new("ParticleEmitter")
            flashEmitter.Name = "Flash"
            flashEmitter.Acceleration = B(0, 0, 0)
            flashEmitter.Brightness = 1
            flashEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            flashEmitter.Drag = 0
            flashEmitter.EmissionDirection = Enum.NormalId.Top
            flashEmitter.Enabled = true
            flashEmitter.FlipbookFramerate = NumberRange.new(20, 20)
            flashEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
            flashEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            flashEmitter.FlipbookStartRandom = false
            flashEmitter.Lifetime = NumberRange.new(0.3, 0.6)
            flashEmitter.LightEmission = 0
            flashEmitter.LightInfluence = 0
            flashEmitter.LockedToPart = true
            flashEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
            flashEmitter.Rate = 3
            flashEmitter.RotSpeed = NumberRange.new(0, 0)
            flashEmitter.Rotation = NumberRange.new(-360, 360)
            flashEmitter.Shape = Enum.ParticleEmitterShape.Box
            flashEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            flashEmitter.ShapePartial = 1
            flashEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            flashEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 2)}
            flashEmitter.Speed = NumberRange.new(0, 0)
            flashEmitter.SpreadAngle = Vector2.new(-360, 360)
            flashEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            flashEmitter.Texture = "rbxassetid://11372587580"
            flashEmitter.TimeScale = 1
            flashEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            flashEmitter.VelocityInheritance = 0
            flashEmitter.ZOffset = 1
            flashEmitter.Parent = rootAttachment
            
            -- Сохраняем ссылки
            aura_state.attachment = rootAttachment
            aura_state.particle_emitter = particleEmitter
            aura_state.flash_emitter = flashEmitter
        end
        
        function aura_utility:createFrostBladesAura(hrp, accentColor)
            local attachments = {}
            local beams = {}
            local emitters = {}
            
            -- Создаем RootAttachment
            local rootAttachment = Instance.new("Attachment")
            rootAttachment.Name = "RootAttachment"
            rootAttachment.Axis = B(1, 0, 0)
            rootAttachment.CFrame = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            rootAttachment.Orientation = B(-0, 0, 0)
            rootAttachment.Position = B(0, 0, 0)
            rootAttachment.SecondaryAxis = B(0, 1, 0)
            rootAttachment.Visible = false
            rootAttachment.Parent = hrp
            p(attachments, rootAttachment)
            
            -- Создаем bottom attachment
            local bottomAttachment = Instance.new("Attachment")
            bottomAttachment.Name = "bottom"
            bottomAttachment.Axis = B(1, 0, 0)
            bottomAttachment.CFrame = C(0, -3, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            bottomAttachment.Orientation = B(-0, 0, 0)
            bottomAttachment.Position = B(0, -3, 0)
            bottomAttachment.SecondaryAxis = B(0, 1, 0)
            bottomAttachment.Visible = false
            bottomAttachment.Parent = hrp
            p(attachments, bottomAttachment)
            
            -- Создаем whirl ParticleEmitter на bottom
            local whirlEmitter = Instance.new("ParticleEmitter")
            whirlEmitter.Name = "whirl"
            whirlEmitter.Acceleration = B(0, 0, 0)
            whirlEmitter.Brightness = 5.199999809265137
            whirlEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            whirlEmitter.Drag = 0
            whirlEmitter.EmissionDirection = Enum.NormalId.Top
            whirlEmitter.Enabled = true
            whirlEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            whirlEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            whirlEmitter.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            whirlEmitter.FlipbookStartRandom = false
            whirlEmitter.Lifetime = NumberRange.new(2, 2)
            whirlEmitter.LightEmission = 0.15000000596046448
            whirlEmitter.LightInfluence = 0
            whirlEmitter.LockedToPart = true
            whirlEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            whirlEmitter.Rate = 2
            whirlEmitter.RotSpeed = NumberRange.new(400, 400)
            whirlEmitter.Rotation = NumberRange.new(0, 90)
            whirlEmitter.Shape = Enum.ParticleEmitterShape.Box
            whirlEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            whirlEmitter.ShapePartial = 1
            whirlEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            whirlEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 3)}
            whirlEmitter.Speed = NumberRange.new(1.5, 1.5)
            whirlEmitter.SpreadAngle = Vector2.new(5, 5)
            whirlEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            whirlEmitter.Texture = "rbxassetid://9098555411"
            whirlEmitter.TimeScale = 1
            whirlEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.153906, 0), NumberSequenceKeypoint.new(0.847641, 0), NumberSequenceKeypoint.new(1, 1)}
            whirlEmitter.VelocityInheritance = 0
            whirlEmitter.ZOffset = 0
            whirlEmitter.Parent = bottomAttachment
            p(emitters, whirlEmitter)
            
            -- Создаем specs ParticleEmitter на bottom
            local specsEmitter = Instance.new("ParticleEmitter")
            specsEmitter.Name = "specs"
            specsEmitter.Acceleration = B(0, 3, 0)
            specsEmitter.Brightness = 10
            specsEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            specsEmitter.Drag = 0
            specsEmitter.EmissionDirection = Enum.NormalId.Top
            specsEmitter.Enabled = true
            specsEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            specsEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            specsEmitter.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            specsEmitter.FlipbookStartRandom = false
            specsEmitter.Lifetime = NumberRange.new(1.5, 1.8)
            specsEmitter.LightEmission = 1
            specsEmitter.LightInfluence = 0
            specsEmitter.LockedToPart = true
            specsEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
            specsEmitter.Rate = 20
            specsEmitter.RotSpeed = NumberRange.new(1000, 1000)
            specsEmitter.Rotation = NumberRange.new(0, 0)
            specsEmitter.Shape = Enum.ParticleEmitterShape.Box
            specsEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            specsEmitter.ShapePartial = 1
            specsEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            specsEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.1), NumberSequenceKeypoint.new(0.594, 0.1), NumberSequenceKeypoint.new(1, 0)}
            specsEmitter.Speed = NumberRange.new(3, 3)
            specsEmitter.SpreadAngle = Vector2.new(90, 90)
            specsEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            specsEmitter.Texture = "rbxasset://textures/particles/sparkles_main.dds"
            specsEmitter.TimeScale = 1
            specsEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.160866, 1), NumberSequenceKeypoint.new(0.167827, 0), NumberSequenceKeypoint.new(1, 0)}
            specsEmitter.VelocityInheritance = 0
            specsEmitter.ZOffset = 0
            specsEmitter.Parent = bottomAttachment
            p(emitters, specsEmitter)
            
            -- Создаем en attachments (5 штук)
            local enAttachments = {}
            local enPositions = {
                {-3.5, 3.5, -2.5},
                {-4.5, 2, 3},
                {-0.0999984741, 4, 3.19999695},
                {3.89999771, 4.79999971, 2},
                {3.29999924, 2.79999971, -2.19999695}
            }
            
            for i = 1, 5 do
                local pos = enPositions[i]
                local enAttachment = Instance.new("Attachment")
                enAttachment.Name = "en" .. i
                enAttachment.Axis = B(0, 0, -1)
                enAttachment.CFrame = C(pos[1], pos[2], pos[3], 0, 0, 1, 0, 1, -0, -1, 0, 0)
                enAttachment.Orientation = B(-0, 90, 0)
                enAttachment.Position = B(pos[1], pos[2], pos[3])
                enAttachment.SecondaryAxis = B(0, 1, 0)
                enAttachment.Visible = false
                enAttachment.Parent = hrp
                p(attachments, enAttachment)
                enAttachments[i] = enAttachment
            end
            
            -- Создаем st attachments (5 штук)
            local stAttachments = {}
            local stPositions = {
                {-1.49996948, -2.99999428, -0.999954224},
                {-1.5, -3, 1},
                {0.299999237, -3, 1.79999542},
                {2.09999847, -3, 0.399993896},
                {1.29999924, -3, -1.40000916}
            }
            
            for i = 1, 5 do
                local pos = stPositions[i]
                local stAttachment = Instance.new("Attachment")
                stAttachment.Name = "st" .. i
                stAttachment.Axis = B(0, 0, -1)
                stAttachment.CFrame = C(pos[1], pos[2], pos[3], 0, 0, 1, 0, 1, -0, -1, 0, 0)
                stAttachment.Orientation = B(-0, 90, 0)
                stAttachment.Position = B(pos[1], pos[2], pos[3])
                stAttachment.SecondaryAxis = B(0, 1, 0)
                stAttachment.Visible = false
                stAttachment.Parent = hrp
                p(attachments, stAttachment)
                stAttachments[i] = stAttachment
            end
            
            -- Создаем end1 и start1 attachments
            local endAttachment = Instance.new("Attachment")
            endAttachment.Name = "end1"
            endAttachment.Axis = B(0, -1, 0)
            endAttachment.CFrame = C(0, -2.88535929, -3.5, 0, -1, -4.37113883e-08, -1, 0, -0, 0, 4.37113883e-08, -1)
            endAttachment.Orientation = B(-0, -179.99998474121094, -90)
            endAttachment.Position = B(0, -2.885359287261963, -3.5)
            endAttachment.SecondaryAxis = B(-1, -4.371138828673793e-08, 1.5099580252808664e-07)
            endAttachment.Visible = false
            endAttachment.Parent = hrp
            p(attachments, endAttachment)
            
            local startAttachment = Instance.new("Attachment")
            startAttachment.Name = "start1"
            startAttachment.Axis = B(0, -1, 0)
            startAttachment.CFrame = C(0, -2.88535929, 3.5, 0, -1, -4.37113883e-08, -1, 0, -0, 0, 4.37113883e-08, -1)
            startAttachment.Orientation = B(-0, -179.99998474121094, -90)
            startAttachment.Position = B(0, -2.885359287261963, 3.5)
            startAttachment.SecondaryAxis = B(-1, -4.371138828673793e-08, 1.5099580252808664e-07)
            startAttachment.Visible = false
            startAttachment.Parent = hrp
            p(attachments, startAttachment)
            
            -- Создаем blade beams (5 штук)
            for i = 1, 5 do
                local bladeBeam = Instance.new("Beam")
                bladeBeam.Name = "blade" .. i
                bladeBeam.Attachment0 = enAttachments[i]
                bladeBeam.Attachment1 = stAttachments[i]
                bladeBeam.Brightness = 1
                bladeBeam.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, accentColor),
                    ColorSequenceKeypoint.new(1, accentColor)
                }
                bladeBeam.CurveSize0 = 0
                bladeBeam.CurveSize1 = 0
                bladeBeam.Enabled = true
                bladeBeam.FaceCamera = true
                bladeBeam.LightEmission = 1
                bladeBeam.LightInfluence = 1
                bladeBeam.Segments = 10
                bladeBeam.Texture = "rbxassetid://14050932611"
                bladeBeam.TextureLength = 1
                bladeBeam.TextureMode = Enum.TextureMode.Stretch
                bladeBeam.TextureSpeed = 0
                bladeBeam.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
                bladeBeam.Width0 = 0
                bladeBeam.Width1 = 8
                bladeBeam.ZOffset = 0
                bladeBeam.Parent = hrp
                p(beams, bladeBeam)
            end
            
            -- Создаем energy beams (5 штук)
            for i = 1, 5 do
                local energyBeam = Instance.new("Beam")
                energyBeam.Name = "energy" .. i
                energyBeam.Attachment0 = stAttachments[i]
                energyBeam.Attachment1 = enAttachments[i]
                energyBeam.Brightness = 6.534999847412109
                energyBeam.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, accentColor),
                    ColorSequenceKeypoint.new(1, accentColor)
                }
                energyBeam.CurveSize0 = 0
                energyBeam.CurveSize1 = 0
                energyBeam.Enabled = true
                energyBeam.FaceCamera = true
                energyBeam.LightEmission = 1
                energyBeam.LightInfluence = 0
                energyBeam.Segments = 10
                energyBeam.Texture = "http://www.roblox.com/asset/?id=6365212829"
                energyBeam.TextureLength = 10
                energyBeam.TextureMode = Enum.TextureMode.Static
                energyBeam.TextureSpeed = 1
                energyBeam.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.845321, 0.01875), NumberSequenceKeypoint.new(0.887858, 1), NumberSequenceKeypoint.new(1, 1)}
                energyBeam.Width0 = 0.5
                energyBeam.Width1 = 0.5
                energyBeam.ZOffset = 0.10000000149011612
                energyBeam.Parent = hrp
                p(beams, energyBeam)
            end
            
            -- Создаем glow beam
            local glowBeam = Instance.new("Beam")
            glowBeam.Name = "glow"
            glowBeam.Attachment0 = endAttachment
            glowBeam.Attachment1 = startAttachment
            glowBeam.Brightness = 2.265000104904175
            glowBeam.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            glowBeam.CurveSize0 = 0
            glowBeam.CurveSize1 = 0
            glowBeam.Enabled = true
            glowBeam.FaceCamera = false
            glowBeam.LightEmission = 1
            glowBeam.LightInfluence = 0
            glowBeam.Segments = 10
            glowBeam.Texture = "http://www.roblox.com/asset/?id=4464710465"
            glowBeam.TextureLength = 1
            glowBeam.TextureMode = Enum.TextureMode.Stretch
            glowBeam.TextureSpeed = 0
            glowBeam.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 0.5)}
            glowBeam.Width0 = 8
            glowBeam.Width1 = 8
            glowBeam.ZOffset = 0
            glowBeam.Parent = hrp
            p(beams, glowBeam)
            
            -- Сохраняем ссылки
            aura_state.attachments = attachments
            aura_state.beams = beams
            aura_state.particle_emitters = emitters
        end
        
        function aura_utility:createChargeAura(hrp, accentColor)
            local attachments = {}
            local emitters = {}
            
            -- Создаем Main attachment
            local mainAttachment = Instance.new("Attachment")
            mainAttachment.Name = "Main"
            mainAttachment.Axis = B(1, 0, 0)
            mainAttachment.CFrame = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            mainAttachment.Orientation = B(-0, 0, 0)
            mainAttachment.Position = B(0, 0, 0)
            mainAttachment.SecondaryAxis = B(0, 1, 0)
            mainAttachment.Visible = false
            mainAttachment.Parent = hrp
            p(attachments, mainAttachment)
            
            -- Создаем Energy1 ParticleEmitter
            local energy1Emitter = Instance.new("ParticleEmitter")
            energy1Emitter.Name = "Energy1"
            energy1Emitter.Acceleration = B(0, 0, 0)
            energy1Emitter.Brightness = 25
            energy1Emitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            energy1Emitter.Drag = 0
            energy1Emitter.EmissionDirection = Enum.NormalId.Top
            energy1Emitter.Enabled = true
            energy1Emitter.FlipbookFramerate = NumberRange.new(1, 1)
            energy1Emitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
            energy1Emitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            energy1Emitter.FlipbookStartRandom = false
            energy1Emitter.Lifetime = NumberRange.new(0.3, 0.3)
            energy1Emitter.LightEmission = 1
            energy1Emitter.LightInfluence = 0
            energy1Emitter.LockedToPart = true
            energy1Emitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            energy1Emitter.Rate = 20
            energy1Emitter.RotSpeed = NumberRange.new(0, 0)
            energy1Emitter.Rotation = NumberRange.new(-360, 360)
            energy1Emitter.Shape = Enum.ParticleEmitterShape.Box
            energy1Emitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            energy1Emitter.ShapePartial = 1
            energy1Emitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            energy1Emitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 5), NumberSequenceKeypoint.new(1, 5)}
            energy1Emitter.Speed = NumberRange.new(0.001, 0.001)
            energy1Emitter.SpreadAngle = Vector2.new(75, 75)
            energy1Emitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy1Emitter.Texture = "rbxassetid://15041986621"
            energy1Emitter.TimeScale = 1
            energy1Emitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy1Emitter.VelocityInheritance = 0
            energy1Emitter.ZOffset = 1
            energy1Emitter.Parent = mainAttachment
            p(emitters, energy1Emitter)
            
            -- Создаем Energy2 ParticleEmitter
            local energy2Emitter = Instance.new("ParticleEmitter")
            energy2Emitter.Name = "Energy2"
            energy2Emitter.Acceleration = B(0, 0, 0)
            energy2Emitter.Brightness = 25
            energy2Emitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            energy2Emitter.Drag = 0
            energy2Emitter.EmissionDirection = Enum.NormalId.Top
            energy2Emitter.Enabled = true
            energy2Emitter.FlipbookFramerate = NumberRange.new(1, 1)
            energy2Emitter.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
            energy2Emitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            energy2Emitter.FlipbookStartRandom = false
            energy2Emitter.Lifetime = NumberRange.new(0.3, 0.3)
            energy2Emitter.LightEmission = 1
            energy2Emitter.LightInfluence = 0
            energy2Emitter.LockedToPart = true
            energy2Emitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            energy2Emitter.Rate = 20
            energy2Emitter.RotSpeed = NumberRange.new(0, 0)
            energy2Emitter.Rotation = NumberRange.new(-360, 360)
            energy2Emitter.Shape = Enum.ParticleEmitterShape.Box
            energy2Emitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            energy2Emitter.ShapePartial = 1
            energy2Emitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            energy2Emitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 5), NumberSequenceKeypoint.new(1, 5)}
            energy2Emitter.Speed = NumberRange.new(0.001, 0.001)
            energy2Emitter.SpreadAngle = Vector2.new(75, 75)
            energy2Emitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy2Emitter.Texture = "rbxassetid://15041986460"
            energy2Emitter.TimeScale = 1
            energy2Emitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            energy2Emitter.VelocityInheritance = 0
            energy2Emitter.ZOffset = 1
            energy2Emitter.Parent = mainAttachment
            p(emitters, energy2Emitter)
            
            -- Сохраняем ссылки
            aura_state.attachments = attachments
            aura_state.beams = {}
            aura_state.particle_emitters = emitters
        end
        
        function aura_utility:createAtomicAura(hrp, accentColor)
            local attachments = {}
            local emitters = {}
            
            -- Создаем Attachment для BlackSwirl
            local atomicAttachment = Instance.new("Attachment")
            atomicAttachment.Name = "AtomicAttachment"
            atomicAttachment.Parent = hrp
            p(attachments, atomicAttachment)
            
            -- Создаем BlackSwirl ParticleEmitter
            local blackSwirl = Instance.new("ParticleEmitter")
            blackSwirl.Name = "BlackSwirl"
            blackSwirl.Acceleration = B(0, 0, 0)
            blackSwirl.Brightness = 1
            blackSwirl.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, accentColor),
                ColorSequenceKeypoint.new(1, accentColor)
            }
            blackSwirl.Drag = 0
            blackSwirl.EmissionDirection = Enum.NormalId.Top
            blackSwirl.Enabled = true
            blackSwirl.FlipbookFramerate = NumberRange.new(1, 1)
            blackSwirl.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            blackSwirl.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            blackSwirl.FlipbookStartRandom = false
            blackSwirl.Lifetime = NumberRange.new(3, 3)
            blackSwirl.LightEmission = 1
            blackSwirl.LightInfluence = 0
            blackSwirl.LockedToPart = true
            blackSwirl.Orientation = Enum.ParticleOrientation.VelocityParallel
            blackSwirl.Rate = 5
            blackSwirl.RotSpeed = NumberRange.new(360, 360)
            blackSwirl.Rotation = NumberRange.new(-180, 180)
            blackSwirl.Shape = Enum.ParticleEmitterShape.Box
            blackSwirl.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            blackSwirl.ShapePartial = 1
            blackSwirl.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            blackSwirl.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 4), NumberSequenceKeypoint.new(1, 4)}
            blackSwirl.Speed = NumberRange.new(0.01, 0.01)
            blackSwirl.SpreadAngle = Vector2.new(360, -360)
            blackSwirl.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            blackSwirl.Texture = "rbxassetid://10558425570"
            blackSwirl.TimeScale = 1
            blackSwirl.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            blackSwirl.VelocityInheritance = 0
            blackSwirl.ZOffset = 0.2
            blackSwirl.Parent = atomicAttachment
            p(emitters, blackSwirl)
            
            -- Сохраняем ссылки
            aura_state.attachments = attachments
            aura_state.beams = {}
            aura_state.particle_emitters = emitters
        end
        
        function aura_utility:setupCharacterEvents(localPlayer)
            -- Подключаемся к событию смерти персонажа
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local diedConnection = humanoid.Died:Connect(function()
                    -- Очищаем только визуальные элементы, но не отключаем систему
                    for _, attachment in pairs(aura_state.attachments) do
                        if attachment then
                            attachment:Destroy()
                        end
                    end
                    for _, beam in pairs(aura_state.beams) do
                        if beam then
                            beam:Destroy()
                        end
                    end
                    for _, emitter in pairs(aura_state.particle_emitters) do
                        if emitter then
                            emitter:Destroy()
                        end
                    end
                    aura_state.attachments = {}
                    aura_state.beams = {}
                    aura_state.particle_emitters = {}
                end)
                p(aura_state.cleanup_connections, diedConnection)
            end
        end
        
        function aura_utility:setEnabled(enabled)
            aura_state.enabled = enabled
            
            if enabled then
                self:createAura()
            else
                self:cleanup()
            end
        end
        
        function aura_utility:setMode(mode)
            aura_state.mode = mode
            
            -- Если аура включена, пересоздаем ее с новым режимом
            if aura_state.enabled then
                self:createAura()
            end
        end
        
        function aura_utility:updateColor(newColor)
            aura_state.color = newColor
            
            if aura_state.mode == "Lighting" then
                -- Обновляем цвета для Lighting режима
                if aura_state.particle_emitter then
                    aura_state.particle_emitter.Color = ColorSequence.new{
                        ColorSequenceKeypoint.new(0, newColor),
                        ColorSequenceKeypoint.new(1, newColor)
                    }
                end
                
                if aura_state.flash_emitter then
                    aura_state.flash_emitter.Color = ColorSequence.new{
                        ColorSequenceKeypoint.new(0, newColor),
                        ColorSequenceKeypoint.new(1, newColor)
                    }
                end
            elseif aura_state.mode == "FrostBlades" then
                -- Обновляем цвета для FrostBlades режима
                for _, beam in pairs(aura_state.beams) do
                    if beam then
                        beam.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
                
                for _, emitter in pairs(aura_state.particle_emitters) do
                    if emitter then
                        emitter.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
            elseif aura_state.mode == "Charge" then
                -- Обновляем цвета для Charge режима
                for _, emitter in pairs(aura_state.particle_emitters) do
                    if emitter then
                        emitter.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
            elseif aura_state.mode == "Atomic" then
                -- Обновляем цвета для Atomic режима
                for _, emitter in pairs(aura_state.particle_emitters) do
                    if emitter then
                        emitter.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, newColor),
                            ColorSequenceKeypoint.new(1, newColor)
                        }
                    end
                end
            end
        end
        
        -- Aura Toggle
        local auraToggle = stuffSection:Toggle({
            Name = "Aura",
            Default = false,
            Flag = "aura_enabled",
            Callback = function(value)
                aura_utility:setEnabled(value)
            end
        })
        
        -- Aura Colorpicker
        auraToggle:Colorpicker({
            Name = "Aura Color",
            Default = z(31, 226, 130), -- Зеленоватый цвет по умолчанию
            Flag = "aura_color",
            Callback = function(value)
                aura_utility:updateColor(value)
            end
        })
        
        -- Aura Mode Dropdown
        local _auraMode = stuffSection:Dropdown({
            Name = "Aura Mode",
            Items = {"Lighting", "FrostBlades", "Charge", "Atomic"},
            Default = "Lighting",
            Flag = "aura_mode",
            Callback = function(value)
                aura_state.mode = value
                -- Если аура включена, пересоздаем её с новым режимом
                if aura_state.enabled then
                    aura_utility:setEnabled(false)
                    task.wait(0.1)
                    aura_utility:setEnabled(true)
                end
            end
        })
        
        -- Глобальное подключение к событию CharacterAdded для аур
        g.CharacterAdded:Connect(function(newchar)
            wait(0.5) -- Ждем полной загрузки персонажа
            if aura_state.enabled then
                aura_utility:createAura()
            end
        end)
        
        -- Если персонаж уже существует при загрузке скрипта
        if g.Character then
            spawn(function()
                wait(0.5)
                if aura_state.enabled then
                    aura_utility:createAura()
                end
            end)
        end
        
        -- Сохраняем в глобальную область для доступа из других частей кода
        _G.AuraUtility = aura_utility
        
        -- Halo (Нимб) система
        local halo_state = {
            enabled = false,
            color = z(255, 225, 0), -- Золотой цвет по умолчанию
            attachment = nil,
            particle_emitter = nil,
            cleanup_connections = {}
        }
        
        local halo_utility = {}
        
        function halo_utility:cleanup()
            -- Удаляем attachment и particle emitter
            if halo_state.attachment then
                halo_state.attachment:Destroy()
                halo_state.attachment = nil
            end
            
            if halo_state.particle_emitter then
                halo_state.particle_emitter:Destroy()
                halo_state.particle_emitter = nil
            end
            
            -- Отключаем все подключения
            for _, connection in pairs(halo_state.cleanup_connections) do
                if connection then
                    connection:Disconnect()
                end
            end
            halo_state.cleanup_connections = {}
        end
        
        function halo_utility:createHalo()
            local localPlayer = g
            if not localPlayer.Character then
                return
            end
            
            local head = localPlayer.Character:FindFirstChild("Head")
            if not head then
                return
            end
            
            -- Очищаем предыдущий нимб
            self:cleanup()
            
            -- Создаем Attachment для нимба
            local haloAttachment = Instance.new("Attachment")
            haloAttachment.Name = "HaloAttachment"
            haloAttachment.Position = B(0, 1.4, 0) -- Позиция над головой
            haloAttachment.Orientation = B(0, 0, 7) -- Наклон на 6 градусов
            haloAttachment.Parent = head
            halo_state.attachment = haloAttachment
            
            -- Создаем ParticleEmitter для нимба
            local haloEmitter = Instance.new("ParticleEmitter")
            haloEmitter.Name = "Halo"
            haloEmitter.Acceleration = B(0, 0, 0)
            haloEmitter.Brightness = 1
            haloEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, halo_state.color),
                ColorSequenceKeypoint.new(1, halo_state.color)
            }
            haloEmitter.Drag = 0
            haloEmitter.EmissionDirection = Enum.NormalId.Top
            haloEmitter.Enabled = true
            haloEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            haloEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            haloEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            haloEmitter.FlipbookStartRandom = false
            haloEmitter.Lifetime = NumberRange.new(1.5, 1.5)
            haloEmitter.LightEmission = 1
            haloEmitter.LightInfluence = 0
            haloEmitter.LockedToPart = true
            haloEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            haloEmitter.Rate = 3
            haloEmitter.RotSpeed = NumberRange.new(-360, -360)
            haloEmitter.Rotation = NumberRange.new(-360, 360)
            haloEmitter.Shape = Enum.ParticleEmitterShape.Box
            haloEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            haloEmitter.ShapePartial = 1
            haloEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            haloEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 2.6), NumberSequenceKeypoint.new(1, 2.6)}
            haloEmitter.Speed = NumberRange.new(0.001, 0.001)
            haloEmitter.SpreadAngle = Vector2.new(3, 2)
            haloEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.01), NumberSequenceKeypoint.new(1, 0.01)}
            haloEmitter.Texture = "rbxassetid://7185003058"
            haloEmitter.TimeScale = 1
            haloEmitter.Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.293, 0),
                NumberSequenceKeypoint.new(0.497, 0),
                NumberSequenceKeypoint.new(0.701, 0),
                NumberSequenceKeypoint.new(1, 1)
            }
            haloEmitter.VelocityInheritance = 0
            haloEmitter.ZOffset = 0
            haloEmitter.Parent = haloAttachment
            halo_state.particle_emitter = haloEmitter
            
            -- Подключаемся к событиям персонажа
            self:setupCharacterEvents(localPlayer)
        end
        
        function halo_utility:setupCharacterEvents(localPlayer)
            -- Подключаемся к событию смерти персонажа
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local diedConnection = humanoid.Died:Connect(function()
                    -- Очищаем только визуальные элементы
                    if halo_state.attachment then
                        halo_state.attachment:Destroy()
                        halo_state.attachment = nil
                    end
                    if halo_state.particle_emitter then
                        halo_state.particle_emitter:Destroy()
                        halo_state.particle_emitter = nil
                    end
                end)
                table.insert(halo_state.cleanup_connections, diedConnection)
            end
        end
        
        function halo_utility:setEnabled(enabled)
            halo_state.enabled = enabled
            
            if enabled then
                self:createHalo()
            else
                self:cleanup()
            end
        end
        
        function halo_utility:updateColor(newColor)
            halo_state.color = newColor
            
            -- Обновляем цвет существующего нимба
            if halo_state.particle_emitter then
                halo_state.particle_emitter.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, newColor),
                    ColorSequenceKeypoint.new(1, newColor)
                }
            end
        end
        
        -- Halo Toggle
        local haloToggle = stuffSection:Toggle({
            Name = "Halo",
            Default = false,
            Flag = "halo_enabled",
            Callback = function(value)
                halo_utility:setEnabled(value)
            end
        })
        
        -- Halo Colorpicker
        haloToggle:Colorpicker({
            Name = "Halo Color",
            Default = z(255, 225, 0), -- Золотой цвет по умолчанию
            Flag = "halo_color",
            Callback = function(value)
                halo_utility:updateColor(value)
            end
        })
        
        -- Глобальное подключение к событию CharacterAdded для нимба
        g.CharacterAdded:Connect(function(newchar)
            wait(0.5) -- Ждем полной загрузки персонажа
            if halo_state.enabled then
                halo_utility:createHalo()
            end
        end)
        
        -- Если персонаж уже существует при загрузке скрипта
        if g.Character then
            spawn(function()
                wait(0.5)
                if halo_state.enabled then
                    halo_utility:createHalo()
                end
            end)
        end
        
        -- Сохраняем в глобальную область для доступа из других частей кода
        _G.HaloUtility = halo_utility
        
        -- Snow система
        local snow_state = {
            enabled = false,
            color = z(255, 255, 255), -- Белый цвет по умолчанию
            part = nil,
            particle_emitter = nil,
            weld_constraint = nil,
            cleanup_connections = {}
        }
        
        local snow_utility = {}
        
        function snow_utility:cleanup()
            -- Удаляем part и particle emitter
            if snow_state.part then
                snow_state.part:Destroy()
                snow_state.part = nil
            end
            
            if snow_state.particle_emitter then
                snow_state.particle_emitter = nil
            end
            
            if snow_state.weld_constraint then
                snow_state.weld_constraint:Destroy()
                snow_state.weld_constraint = nil
            end
            
            -- Отключаем все подключения
            for _, connection in pairs(snow_state.cleanup_connections) do
                if connection then
                    connection:Disconnect()
                end
            end
            snow_state.cleanup_connections = {}
        end
        
        function snow_utility:createSnow()
            local localPlayer = g
            if not localPlayer.Character then
                return
            end
            
            local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                return
            end
            
            -- Очищаем предыдущий снег
            self:cleanup()
            
            -- Создаем Part для снега
            local snowPart = Instance.new("Part")
            snowPart.Name = "SnowPart"
            snowPart.Anchored = false
            snowPart.AssemblyAngularVelocity = B(0, 0, 0)
            snowPart.AssemblyLinearVelocity = B(0, 0, 0)
            snowPart.BackSurface = Enum.SurfaceType.Smooth
            snowPart.BottomSurface = Enum.SurfaceType.Smooth
            snowPart.BrickColor = BrickColor.new("Medium stone grey")
            snowPart.CFrame = C(hrp.Position.X, hrp.Position.Y + 75, hrp.Position.Z)
            snowPart.CanCollide = false
            snowPart.CanQuery = false
            snowPart.CanTouch = false
            snowPart.CastShadow = false
            snowPart.Color = z(0.639216, 0.635294, 0.647059)
            snowPart.FrontSurface = Enum.SurfaceType.Smooth
            snowPart.LeftSurface = Enum.SurfaceType.Smooth
            snowPart.Locked = false
            snowPart.Massless = true
            snowPart.Material = Enum.Material.Plastic
            snowPart.MaterialVariant = ""
            snowPart.Orientation = B(0, 0, 0)
            snowPart.PivotOffset = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            snowPart.Position = B(hrp.Position.X, hrp.Position.Y + 75, hrp.Position.Z)
            snowPart.Reflectance = 0
            snowPart.RightSurface = Enum.SurfaceType.Smooth
            snowPart.RootPriority = 0
            snowPart.Rotation = B(0, 0, 0)
            snowPart.Size = B(200, 150, 200)
            snowPart.TopSurface = Enum.SurfaceType.Smooth
            snowPart.Transparency = 1
            snowPart.Parent = workspace
            snow_state.part = snowPart
            
            -- Создаем WeldConstraint для привязки к персонажу
            local weldConstraint = Instance.new("WeldConstraint")
            weldConstraint.Part0 = hrp
            weldConstraint.Part1 = snowPart
            weldConstraint.Parent = snowPart
            snow_state.weld_constraint = weldConstraint
            
            -- Создаем ParticleEmitter для снега
            local snowEmitter = Instance.new("ParticleEmitter")
            snowEmitter.Name = "SnowEmitter"
            snowEmitter.Acceleration = B(0, 0, 0)
            snowEmitter.Brightness = 1.5
            snowEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, snow_state.color),
                ColorSequenceKeypoint.new(1, snow_state.color)
            }
            snowEmitter.Drag = 0
            snowEmitter.EmissionDirection = Enum.NormalId.Top
            snowEmitter.Enabled = true
            snowEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            snowEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            snowEmitter.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            snowEmitter.FlipbookStartRandom = false
            snowEmitter.Lifetime = NumberRange.new(2, 3)
            snowEmitter.LightEmission = 1
            snowEmitter.LightInfluence = 0
            snowEmitter.LockedToPart = false
            snowEmitter.Orientation = Enum.ParticleOrientation.VelocityParallel
            snowEmitter.Rate = 1000
            snowEmitter.RotSpeed = NumberRange.new(0, 0)
            snowEmitter.Rotation = NumberRange.new(90, 90)
            snowEmitter.Shape = Enum.ParticleEmitterShape.Box
            snowEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Inward
            snowEmitter.ShapePartial = 1
            snowEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            snowEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.7), NumberSequenceKeypoint.new(1, 0.7)}
            snowEmitter.Speed = NumberRange.new(5, 5)
            snowEmitter.SpreadAngle = Vector2.new(0, 0)
            snowEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            snowEmitter.Texture = "rbxassetid://14197923174"
            snowEmitter.TimeScale = 1
            snowEmitter.Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.498132, 0),
                NumberSequenceKeypoint.new(1, 1)
            }
            snowEmitter.VelocityInheritance = 0
            snowEmitter.ZOffset = 1
            snowEmitter.Parent = snowPart
            snow_state.particle_emitter = snowEmitter
            
            -- Подключаемся к событиям персонажа
            self:setupCharacterEvents(localPlayer)
        end
        
        function snow_utility:setupCharacterEvents(localPlayer)
            -- Подключаемся к событию смерти персонажа
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local diedConnection = humanoid.Died:Connect(function()
                    -- Очищаем только визуальные элементы
                    if snow_state.part then
                        snow_state.part:Destroy()
                        snow_state.part = nil
                    end
                    if snow_state.particle_emitter then
                        snow_state.particle_emitter = nil
                    end
                    if snow_state.weld_constraint then
                        snow_state.weld_constraint:Destroy()
                        snow_state.weld_constraint = nil
                    end
                end)
                table.insert(snow_state.cleanup_connections, diedConnection)
            end
        end
        
        function snow_utility:setEnabled(enabled)
            snow_state.enabled = enabled
            
            if enabled then
                self:createSnow()
            else
                self:cleanup()
            end
        end
        
        function snow_utility:updateColor(newColor)
            snow_state.color = newColor
            
            -- Обновляем цвет существующего снега
            if snow_state.particle_emitter then
                snow_state.particle_emitter.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, newColor),
                    ColorSequenceKeypoint.new(1, newColor)
                }
            end
        end
        
        -- Snow Toggle
        local snowToggle = stuffSection:Toggle({
            Name = "Snow",
            Default = false,
            Flag = "snow_enabled",
            Callback = function(value)
                snow_utility:setEnabled(value)
            end
        })
        
        -- Snow Colorpicker
        snowToggle:Colorpicker({
            Name = "Snow Color",
            Default = z(255, 255, 255), -- Белый цвет по умолчанию
            Flag = "snow_color",
            Callback = function(value)
                snow_utility:updateColor(value)
            end
        })
        
        -- Глобальное подключение к событию CharacterAdded для снега
        g.CharacterAdded:Connect(function(newchar)
            wait(0.5) -- Ждем полной загрузки персонажа
            if snow_state.enabled then
                snow_utility:createSnow()
            end
        end)
        
        -- Если персонаж уже существует при загрузке скрипта
        if g.Character then
            spawn(function()
                wait(0.5)
                if snow_state.enabled then
                    snow_utility:createSnow()
                end
            end)
        end
        
        -- Сохраняем в глобальную область для доступа из других частей кода
        _G.SnowUtility = snow_utility
        
        -- Wings система
        local wings_state = {
            enabled = false,
            color = z(255, 0, 0), -- Красный цвет по умолчанию
            attachments = {},
            particle_emitters = {},
            cleanup_connections = {}
        }
        
        local wings_utility = {}
        
        function wings_utility:cleanup()
            -- Удаляем все attachments и particle emitters
            for _, attachment in pairs(wings_state.attachments) do
                if attachment then
                    attachment:Destroy()
                end
            end
            wings_state.attachments = {}
            
            for _, emitter in pairs(wings_state.particle_emitters) do
                if emitter then
                    emitter:Destroy()
                end
            end
            wings_state.particle_emitters = {}
            
            -- Отключаем все подключения
            for _, connection in pairs(wings_state.cleanup_connections) do
                if connection then
                    connection:Disconnect()
                end
            end
            wings_state.cleanup_connections = {}
        end
        
        function wings_utility:createWings()
            local localPlayer = g
            if not localPlayer.Character then
                return
            end
            
            local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                return
            end
            
            -- Очищаем предыдущие крылья
            self:cleanup()
            
            local attachments = {}
            local emitters = {}
            
            -- Создаем RootAttachment с ashes emitter
            local rootAttachment = Instance.new("Attachment")
            rootAttachment.Name = "WingsRootAttachment"
            rootAttachment.Axis = B(1, 0, 0)
            rootAttachment.CFrame = C(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            rootAttachment.Orientation = B(0, 0, 0)
            rootAttachment.Position = B(0, 0, 0)
            rootAttachment.SecondaryAxis = B(0, 1, 0)
            rootAttachment.Visible = false
            rootAttachment.Parent = hrp
            p(attachments, rootAttachment)
            
            -- Создаем ashes emitter на RootAttachment
            local ashesEmitter = Instance.new("ParticleEmitter")
            ashesEmitter.Name = "ashes"
            ashesEmitter.Acceleration = B(0, 0, 4)
            ashesEmitter.Brightness = 2
            ashesEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, wings_state.color),
                ColorSequenceKeypoint.new(1, wings_state.color)
            }
            ashesEmitter.Drag = 0
            ashesEmitter.EmissionDirection = Enum.NormalId.Top
            ashesEmitter.Enabled = true
            ashesEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            ashesEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            ashesEmitter.FlipbookMode = Enum.ParticleFlipbookMode.Loop
            ashesEmitter.FlipbookStartRandom = false
            ashesEmitter.Lifetime = NumberRange.new(2, 3)
            ashesEmitter.LightEmission = 0.5
            ashesEmitter.LightInfluence = 1
            ashesEmitter.LockedToPart = false
            ashesEmitter.Orientation = Enum.ParticleOrientation.FacingCamera
            ashesEmitter.Rate = 10
            ashesEmitter.RotSpeed = NumberRange.new(-100, 100)
            ashesEmitter.Rotation = NumberRange.new(-180, 180)
            ashesEmitter.Shape = Enum.ParticleEmitterShape.Box
            ashesEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            ashesEmitter.ShapePartial = 1
            ashesEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            ashesEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.1), NumberSequenceKeypoint.new(1, 0.1)}
            ashesEmitter.Speed = NumberRange.new(3, 3)
            ashesEmitter.SpreadAngle = Vector2.new(70, 70)
            ashesEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            ashesEmitter.Texture = "http://www.roblox.com/asset/?id=12222002958"
            ashesEmitter.TimeScale = 1
            ashesEmitter.Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.498132, 0),
                NumberSequenceKeypoint.new(1, 1)
            }
            ashesEmitter.VelocityInheritance = 0
            ashesEmitter.ZOffset = 0
            ashesEmitter.Parent = rootAttachment
            p(emitters, ashesEmitter)
            
            -- Создаем middle attachment (левое крыло)
            local middleAttachment = Instance.new("Attachment")
            middleAttachment.Name = "middle"
            middleAttachment.Axis = B(-4.371138828673793e-08, 0, 1)
            middleAttachment.CFrame = C(-2.20000005, 0.5, 2.29999995, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08)
            middleAttachment.Orientation = B(0, -90, 0)
            middleAttachment.Position = B(-2.20000005, 0.5, 2.29999995)
            middleAttachment.SecondaryAxis = B(0, 1, 0)
            middleAttachment.Visible = false
            middleAttachment.Parent = hrp
            p(attachments, middleAttachment)
            
            -- Создаем leftwing emitter
            local leftWingEmitter = Instance.new("ParticleEmitter")
            leftWingEmitter.Name = "leftwing"
            leftWingEmitter.Acceleration = B(0.01, 0, -0.01)
            leftWingEmitter.Brightness = 2
            leftWingEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, wings_state.color),
                ColorSequenceKeypoint.new(1, wings_state.color)
            }
            leftWingEmitter.Drag = 0
            leftWingEmitter.EmissionDirection = Enum.NormalId.Left
            leftWingEmitter.Enabled = true
            leftWingEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            leftWingEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            leftWingEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            leftWingEmitter.FlipbookStartRandom = false
            leftWingEmitter.Lifetime = NumberRange.new(5, 5)
            leftWingEmitter.LightEmission = 0.5
            leftWingEmitter.LightInfluence = 0
            leftWingEmitter.LockedToPart = true
            leftWingEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            leftWingEmitter.Rate = 1
            leftWingEmitter.RotSpeed = NumberRange.new(0, 0)
            leftWingEmitter.Rotation = NumberRange.new(0, 0)
            leftWingEmitter.Shape = Enum.ParticleEmitterShape.Disc
            leftWingEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Inward
            leftWingEmitter.ShapePartial = 1
            leftWingEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            leftWingEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(1, 3)}
            leftWingEmitter.Speed = NumberRange.new(0, 0)
            leftWingEmitter.SpreadAngle = Vector2.new(0, 0)
            leftWingEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            leftWingEmitter.Texture = "rbxassetid://13326678344"
            leftWingEmitter.TimeScale = 1
            leftWingEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            leftWingEmitter.VelocityInheritance = 0
            leftWingEmitter.ZOffset = 0
            leftWingEmitter.Parent = middleAttachment
            p(emitters, leftWingEmitter)
            
            -- Создаем anotherwing attachment (правое крыло)
            local anotherWingAttachment = Instance.new("Attachment")
            anotherWingAttachment.Name = "anotherwing"
            anotherWingAttachment.Axis = B(1, 0, 0)
            anotherWingAttachment.CFrame = C(2, 0.5, 2.29999995, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            anotherWingAttachment.Orientation = B(0, 0, 0)
            anotherWingAttachment.Position = B(2, 0.5, 2.29999995)
            anotherWingAttachment.SecondaryAxis = B(0, 1, 0)
            anotherWingAttachment.Visible = false
            anotherWingAttachment.Parent = hrp
            p(attachments, anotherWingAttachment)
            
            -- Создаем rightwing emitter
            local rightWingEmitter = Instance.new("ParticleEmitter")
            rightWingEmitter.Name = "rightwing"
            rightWingEmitter.Acceleration = B(0.01, 0, -0.01)
            rightWingEmitter.Brightness = 2
            rightWingEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, wings_state.color),
                ColorSequenceKeypoint.new(1, wings_state.color)
            }
            rightWingEmitter.Drag = 0
            rightWingEmitter.EmissionDirection = Enum.NormalId.Left
            rightWingEmitter.Enabled = true
            rightWingEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            rightWingEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            rightWingEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            rightWingEmitter.FlipbookStartRandom = false
            rightWingEmitter.Lifetime = NumberRange.new(5, 5)
            rightWingEmitter.LightEmission = 0.5
            rightWingEmitter.LightInfluence = 0
            rightWingEmitter.LockedToPart = true
            rightWingEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
            rightWingEmitter.Rate = 1
            rightWingEmitter.RotSpeed = NumberRange.new(0, 0)
            rightWingEmitter.Rotation = NumberRange.new(0, 0)
            rightWingEmitter.Shape = Enum.ParticleEmitterShape.Disc
            rightWingEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Inward
            rightWingEmitter.ShapePartial = 1
            rightWingEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            rightWingEmitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(1, 3)}
            rightWingEmitter.Speed = NumberRange.new(0, 0)
            rightWingEmitter.SpreadAngle = Vector2.new(0, 0)
            rightWingEmitter.Squash = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            rightWingEmitter.Texture = "rbxassetid://13326678344"
            rightWingEmitter.TimeScale = 1
            rightWingEmitter.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}
            rightWingEmitter.VelocityInheritance = 0
            rightWingEmitter.ZOffset = 0
            rightWingEmitter.Parent = anotherWingAttachment
            p(emitters, rightWingEmitter)
            
            -- Сохраняем ссылки
            wings_state.attachments = attachments
            wings_state.particle_emitters = emitters
            
            -- Подключаемся к событиям персонажа
            self:setupCharacterEvents(localPlayer)
        end
        
        function wings_utility:setupCharacterEvents(localPlayer)
            -- Подключаемся к событию смерти персонажа
            local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local diedConnection = humanoid.Died:Connect(function()
                    -- Очищаем только визуальные элементы
                    for _, attachment in pairs(wings_state.attachments) do
                        if attachment then
                            attachment:Destroy()
                        end
                    end
                    for _, emitter in pairs(wings_state.particle_emitters) do
                        if emitter then
                            emitter:Destroy()
                        end
                    end
                    wings_state.attachments = {}
                    wings_state.particle_emitters = {}
                end)
                table.insert(wings_state.cleanup_connections, diedConnection)
            end
        end
        
        function wings_utility:setEnabled(enabled)
            wings_state.enabled = enabled
            
            if enabled then
                self:createWings()
            else
                self:cleanup()
            end
        end
        
        function wings_utility:updateColor(newColor)
            wings_state.color = newColor
            
            -- Обновляем цвет существующих крыльев
            for _, emitter in pairs(wings_state.particle_emitters) do
                if emitter then
                    emitter.Color = ColorSequence.new{
                        ColorSequenceKeypoint.new(0, newColor),
                        ColorSequenceKeypoint.new(1, newColor)
                    }
                end
            end
        end
        
        -- Wings Toggle
        local wingsToggle = stuffSection:Toggle({
            Name = "Wings",
            Default = false,
            Flag = "wings_enabled",
            Callback = function(value)
                wings_utility:setEnabled(value)
            end
        })
        
        -- Wings Colorpicker
        wingsToggle:Colorpicker({
            Name = "Wings Color",
            Default = z(255, 0, 0), -- Красный цвет по умолчанию
            Flag = "wings_color",
            Callback = function(value)
                wings_utility:updateColor(value)
            end
        })
        
        -- Глобальное подключение к событию CharacterAdded для крыльев (вне функций)
        g.CharacterAdded:Connect(function(newchar)
            wait(0.5) -- Ждем полной загрузки персонажа
            if wings_state.enabled then
                wings_utility:createWings()
            end
        end)
        
        -- Если персонаж уже существует при загрузке скрипта
        if g.Character then
            spawn(function()
                wait(0.5)
                if wings_state.enabled then
                    wings_utility:createWings()
                end
            end)
        end
        
        -- Сохраняем в глобальную область для доступа из других частей кода
        _G.WingsUtility = wings_utility
        
        -- Trail система
        local trail_state = {
            enabled = false,
            color = z(255, 0, 0), -- Красный цвет по умолчанию
            attachment = nil,
            particle_emitter = nil,
            cleanup_connections = {},
            last_position = nil,
            movement_connection = nil
        }
        
        local trail_utility = {}
        
        function trail_utility:cleanup()
            -- Удаляем attachment и particle emitter
            if trail_state.attachment then
                trail_state.attachment:Destroy()
                trail_state.attachment = nil
            end
            
            if trail_state.particle_emitter then
                trail_state.particle_emitter:Destroy()
                trail_state.particle_emitter = nil
            end
            
            -- Отключаем соединения
            for _, connection in pairs(trail_state.cleanup_connections) do
                if connection then
                    connection:Disconnect()
                end
            end
            trail_state.cleanup_connections = {}
            
            if trail_state.movement_connection then
                trail_state.movement_connection:Disconnect()
                trail_state.movement_connection = nil
            end
            
            trail_state.last_position = nil
        end
        
        function trail_utility:setupCharacterEvents(player)
            local character = player.Character
            if not character then return end
            
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local connection = humanoid.Died:Connect(function()
                    self:cleanup()
                end)
                p(trail_state.cleanup_connections, connection)
            end
        end
        
        function trail_utility:createTrail()
            local localPlayer = g
            if not localPlayer.Character then return end
            local hrp = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            self:cleanup()
            
            -- Создаем RootAttachment
            local rootAttachment = Instance.new("Attachment")
            rootAttachment.Name = "RootAttachment"
            rootAttachment.Axis = B(1, 0, 0)
            rootAttachment.CFrame = C(0, 0, 0)
            rootAttachment.Position = B(0, 0, 0)
            rootAttachment.SecondaryAxis = B(0, 1, 0)
            rootAttachment.Visible = false
            rootAttachment.Parent = hrp
            trail_state.attachment = rootAttachment
            
            -- Создаем Blood1 emitter
            local bloodEmitter = Instance.new("ParticleEmitter")
            bloodEmitter.Name = "Blood1"
            bloodEmitter.Acceleration = B(0, -15, 0)
            bloodEmitter.Brightness = 5
            bloodEmitter.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, trail_state.color),
                ColorSequenceKeypoint.new(1, trail_state.color)
            }
            bloodEmitter.Drag = 0
            bloodEmitter.EmissionDirection = Enum.NormalId.Top
            bloodEmitter.Enabled = false -- Изначально выключен
            bloodEmitter.FlipbookFramerate = NumberRange.new(1, 1)
            bloodEmitter.FlipbookLayout = Enum.ParticleFlipbookLayout.None
            bloodEmitter.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
            bloodEmitter.FlipbookStartRandom = false
            bloodEmitter.Lifetime = NumberRange.new(2, 2)
            bloodEmitter.LightEmission = 0.5
            bloodEmitter.LightInfluence = 0
            bloodEmitter.LockedToPart = false
            bloodEmitter.Orientation = Enum.ParticleOrientation.VelocityParallel
            bloodEmitter.Rate = 25
            bloodEmitter.RotSpeed = NumberRange.new(0, 0)
            bloodEmitter.Rotation = NumberRange.new(-90, -90)
            bloodEmitter.Shape = Enum.ParticleEmitterShape.Box
            bloodEmitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
            bloodEmitter.ShapePartial = 1
            bloodEmitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
            bloodEmitter.Size = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 0.2),
                NumberSequenceKeypoint.new(1, 0.2)
            }
            bloodEmitter.Speed = NumberRange.new(3, 3)
            bloodEmitter.SpreadAngle = Vector2.new(-150, -150)
            bloodEmitter.Squash = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 0)
            }
            bloodEmitter.Texture = "rbxassetid://12363979555"
            bloodEmitter.TimeScale = 1
            bloodEmitter.Transparency = NumberSequence.new{
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 0)
            }
            bloodEmitter.VelocityInheritance = 0
            bloodEmitter.ZOffset = 0
            bloodEmitter.Parent = rootAttachment
            trail_state.particle_emitter = bloodEmitter
            
            -- Инициализируем начальную позицию
            trail_state.last_position = hrp.Position
            
            -- Создаем соединение для отслеживания движения
            trail_state.movement_connection = b.Heartbeat:Connect(function()
                if not hrp or not hrp.Parent then return end
                if not trail_state.particle_emitter then return end
                
                local currentPosition = hrp.Position
                if trail_state.last_position then
                    local distance = (currentPosition - trail_state.last_position).Magnitude
                    
                    -- Если игрок движется (расстояние больше порога)
                    -- Уменьшаем порог для более чувствительного определения движения
                    if distance > 0.05 then
                        trail_state.particle_emitter.Enabled = true
                    else
                        trail_state.particle_emitter.Enabled = false
                    end
                end
                
                trail_state.last_position = currentPosition
            end)
            
            self:setupCharacterEvents(localPlayer)
        end
        
        function trail_utility:setEnabled(enabled)
            trail_state.enabled = enabled
            
            if enabled then
                self:createTrail()
            else
                self:cleanup()
            end
        end
        
        function trail_utility:updateColor(color)
            trail_state.color = color
            
            if trail_state.particle_emitter then
                trail_state.particle_emitter.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, color),
                    ColorSequenceKeypoint.new(1, color)
                }
            end
        end
        
        -- Trail Toggle
        local trailToggle = stuffSection:Toggle({
            Name = "Trail",
            Default = false,
            Flag = "trail_enabled",
            Callback = function(value)
                trail_utility:setEnabled(value)
            end
        })
        
        -- Trail Colorpicker
        trailToggle:Colorpicker({
            Name = "Trail Color",
            Default = z(255, 0, 0), -- Красный цвет по умолчанию
            Flag = "trail_color",
            Callback = function(value)
                trail_utility:updateColor(value)
            end
        })
        
        -- Глобальное подключение к событию CharacterAdded для трейла
        g.CharacterAdded:Connect(function(newchar)
            wait(0.5) -- Ждем полной загрузки персонажа
            if trail_state.enabled then
                trail_utility:createTrail()
            end
        end)
        
        -- Если персонаж уже существует при загрузке скрипта
        if g.Character then
            spawn(function()
                wait(0.5)
                if trail_state.enabled then
                    trail_utility:createTrail()
                end
            end)
        end
        
        -- Сохраняем в глобальную область для доступа из других частей кода
        _G.TrailUtility = trail_utility
        
    end
    
    do -- World Section
        local worldSection = N:Section({Name = "World", Side = 2})
        
        -- Ambient utility
        local ambient_utility = {}
        local ambient_state = {
            enabled = false,
            custom_color = z(255, 255, 255),
            default_ambient = nil,
            default_outdoor_ambient = nil,
            lighting = nil
        }
        
        -- Функция инициализации
        function ambient_utility:init()
            ambient_state.lighting = game:GetService("Lighting")
            
            -- Сохраняем дефолтные значения при первом запуске
            if not ambient_state.default_ambient then
                ambient_state.default_ambient = ambient_state.lighting.Ambient
            end
            if not ambient_state.default_outdoor_ambient then
                ambient_state.default_outdoor_ambient = ambient_state.lighting.OutdoorAmbient
            end
        end
        
        -- Функция применения кастомного ambient
        function ambient_utility:applyCustomAmbient()
            if not ambient_state.lighting then
                self:init()
            end
            
            if ambient_state.enabled then
                -- Применяем кастомный цвет
                ambient_state.lighting.Ambient = ambient_state.custom_color
                ambient_state.lighting.OutdoorAmbient = ambient_state.custom_color
            else
                -- Восстанавливаем дефолтные значения
                self:restoreDefaults()
            end
        end
        
        -- Функция восстановления дефолтных значений
        function ambient_utility:restoreDefaults()
            if ambient_state.lighting and ambient_state.default_ambient and ambient_state.default_outdoor_ambient then
                ambient_state.lighting.Ambient = ambient_state.default_ambient
                ambient_state.lighting.OutdoorAmbient = ambient_state.default_outdoor_ambient
            end
        end
        
        -- Функция обновления цвета
        function ambient_utility:updateColor(color)
            ambient_state.custom_color = color
            if ambient_state.enabled then
                self:applyCustomAmbient()
            end
        end
        
        -- Функция включения/выключения
        function ambient_utility:setEnabled(enabled)
            ambient_state.enabled = enabled
            self:applyCustomAmbient()
        end
        
        -- Инициализируем утилиту
        ambient_utility:init()
        
        -- Создаем UI элементы
        local _ambientToggle = worldSection:Toggle({
            Name = "Ambient",
            Default = false,
            Flag = "world_ambient",
            Callback = function(value)
                ambient_utility:setEnabled(value)
            end
        })
        
        -- Колорпикер для Ambient
        _ambientToggle:Colorpicker({
            Name = "Ambient Color",
            Default = z(255, 255, 255),
            Flag = "world_ambient_color",
            Callback = function(color)
                ambient_utility:updateColor(color)
            end
        })
        
        -- Обработчик при выходе/смерти для восстановления дефолтных значений
        g.CharacterRemoving:Connect(function()
            ambient_utility:restoreDefaults()
        end)
        
        -- Сохраняем утилиту в глобальную область
        _G.AmbientUtility = ambient_utility
        
        -- Tint utility
        local tint_utility = {}
        local tint_state = {
            enabled = false,
            custom_color = z(255, 255, 255),
            color_correction = nil
        }
        
        -- Функция инициализации Tint
        function tint_utility:init()
            -- Ищем существующий ColorCorrection или создаем новый
            tint_state.color_correction = game:GetService("Lighting"):FindFirstChild("FentanylTint")
            
            if not tint_state.color_correction then
                tint_state.color_correction = Instance.new("ColorCorrectionEffect")
                tint_state.color_correction.Name = "FentanylTint"
                tint_state.color_correction.Enabled = false
                tint_state.color_correction.TintColor = z(255, 255, 255)
                tint_state.color_correction.Parent = game:GetService("Lighting")
            end
        end
        
        -- Функция применения tint
        function tint_utility:applyTint()
            if not tint_state.color_correction then
                self:init()
            end
            
            if tint_state.enabled then
                tint_state.color_correction.Enabled = true
                tint_state.color_correction.TintColor = tint_state.custom_color
            else
                tint_state.color_correction.Enabled = false
            end
        end
        
        -- Функция обновления цвета
        function tint_utility:updateColor(color)
            tint_state.custom_color = color
            if tint_state.color_correction then
                tint_state.color_correction.TintColor = color
            end
        end
        
        -- Функция включения/выключения
        function tint_utility:setEnabled(enabled)
            tint_state.enabled = enabled
            self:applyTint()
        end
        
        -- Функция очистки
        function tint_utility:cleanup()
            if tint_state.color_correction then
                tint_state.color_correction.Enabled = false
            end
        end
        
        -- Инициализируем tint утилиту
        tint_utility:init()
        
        -- Создаем UI элементы для Tint
        local _tintToggle = worldSection:Toggle({
            Name = "Tint",
            Default = false,
            Flag = "world_tint",
            Callback = function(value)
                tint_utility:setEnabled(value)
            end
        })
        
        -- Колорпикер для Tint
        _tintToggle:Colorpicker({
            Name = "Tint Color",
            Default = z(255, 255, 255),
            Flag = "world_tint_color",
            Callback = function(color)
                tint_utility:updateColor(color)
            end
        })
        
        -- Skybox utility
        local skybox_utility = {}
        local skybox_state = {
            enabled = false,
            current_type = "Galaxy",
            original_skybox = nil,
            custom_skybox = nil,
            lighting = nil
        }
        
        -- Skybox presets
        local skybox_presets = {
            ["Galaxy"] = {
                SkyboxBk = "rbxassetid://15983968922",
                SkyboxDn = "rbxassetid://15983966825",
                SkyboxFt = "rbxassetid://15983965025",
                SkyboxLf = "rbxassetid://15983967420",
                SkyboxRt = "rbxassetid://15983966246",
                SkyboxUp = "rbxassetid://15983964246",
                StarCount = 0,
                CelestialBodiesShown = true
            },
            ["SpongeBob"] = {
                SkyboxBk = "http://www.roblox.com/asset/?id=7633178166",
                SkyboxDn = "http://www.roblox.com/asset/?id=7633178166",
                SkyboxFt = "http://www.roblox.com/asset/?id=7633178166",
                SkyboxLf = "http://www.roblox.com/asset/?id=7633178166",
                SkyboxRt = "http://www.roblox.com/asset/?id=7633178166",
                SkyboxUp = "http://www.roblox.com/asset/?id=7633178166",
                StarCount = 0,
                CelestialBodiesShown = true,
                MoonTextureId = "http://www.roblox.com/asset/?id=7633178166"
            },
            ["Blue"] = {
                SkyboxBk = "http://www.roblox.com/asset/?id=16876760844",
                SkyboxDn = "http://www.roblox.com/asset/?id=16876762818",
                SkyboxFt = "http://www.roblox.com/asset/?id=16876765234",
                SkyboxLf = "http://www.roblox.com/asset/?id=16876767659",
                SkyboxRt = "http://www.roblox.com/asset/?id=16876769447",
                SkyboxUp = "http://www.roblox.com/asset/?id=16876771721",
                StarCount = 0,
                CelestialBodiesShown = false
            },
            ["Red"] = {
                SkyboxBk = "http://www.roblox.com/asset/?id=570555736",
                SkyboxDn = "http://www.roblox.com/asset/?id=570555964",
                SkyboxFt = "http://www.roblox.com/asset/?id=570555800",
                SkyboxLf = "http://www.roblox.com/asset/?id=570555840",
                SkyboxRt = "http://www.roblox.com/asset/?id=570555882",
                SkyboxUp = "http://www.roblox.com/asset/?id=570555929",
                StarCount = 0,
                CelestialBodiesShown = false
            }
        }
        
        -- Функция инициализации Skybox
        function skybox_utility:init()
            skybox_state.lighting = game:GetService("Lighting")
            
            -- Сохраняем оригинальный skybox
            local existingSkybox = skybox_state.lighting:FindFirstChildOfClass("Sky")
            if existingSkybox then
                skybox_state.original_skybox = {
                    SkyboxBk = existingSkybox.SkyboxBk,
                    SkyboxDn = existingSkybox.SkyboxDn,
                    SkyboxFt = existingSkybox.SkyboxFt,
                    SkyboxLf = existingSkybox.SkyboxLf,
                    SkyboxRt = existingSkybox.SkyboxRt,
                    SkyboxUp = existingSkybox.SkyboxUp,
                    StarCount = existingSkybox.StarCount,
                    CelestialBodiesShown = existingSkybox.CelestialBodiesShown,
                    MoonTextureId = existingSkybox.MoonTextureId,
                    SunTextureId = existingSkybox.SunTextureId,
                    MoonAngularSize = existingSkybox.MoonAngularSize,
                    SunAngularSize = existingSkybox.SunAngularSize
                }
            end
        end
        
        -- Функция применения skybox
        function skybox_utility:applySkybox()
            if not skybox_state.lighting then
                self:init()
            end
            
            local skybox = skybox_state.lighting:FindFirstChildOfClass("Sky")
            if not skybox then
                skybox = Instance.new("Sky")
                skybox.Parent = skybox_state.lighting
            end
            
            if skybox_state.enabled then
                local preset = skybox_presets[skybox_state.current_type]
                if preset then
                    -- Применяем настройки из пресета
                    skybox.SkyboxBk = preset.SkyboxBk
                    skybox.SkyboxDn = preset.SkyboxDn
                    skybox.SkyboxFt = preset.SkyboxFt
                    skybox.SkyboxLf = preset.SkyboxLf
                    skybox.SkyboxRt = preset.SkyboxRt
                    skybox.SkyboxUp = preset.SkyboxUp
                    skybox.StarCount = preset.StarCount or 3000
                    skybox.CelestialBodiesShown = preset.CelestialBodiesShown
                    
                    -- Специальные настройки для некоторых пресетов
                    if preset.MoonTextureId then
                        skybox.MoonTextureId = preset.MoonTextureId
                    else
                        skybox.MoonTextureId = "rbxasset://sky/moon.jpg"
                    end
                    
                    if preset.SunTextureId then
                        skybox.SunTextureId = preset.SunTextureId
                    else
                        skybox.SunTextureId = "rbxasset://sky/sun.jpg"
                    end
                end
            else
                -- Восстанавливаем оригинальный skybox
                if skybox_state.original_skybox then
                    skybox.SkyboxBk = skybox_state.original_skybox.SkyboxBk
                    skybox.SkyboxDn = skybox_state.original_skybox.SkyboxDn
                    skybox.SkyboxFt = skybox_state.original_skybox.SkyboxFt
                    skybox.SkyboxLf = skybox_state.original_skybox.SkyboxLf
                    skybox.SkyboxRt = skybox_state.original_skybox.SkyboxRt
                    skybox.SkyboxUp = skybox_state.original_skybox.SkyboxUp
                    skybox.StarCount = skybox_state.original_skybox.StarCount
                    skybox.CelestialBodiesShown = skybox_state.original_skybox.CelestialBodiesShown
                    skybox.MoonTextureId = skybox_state.original_skybox.MoonTextureId
                    skybox.SunTextureId = skybox_state.original_skybox.SunTextureId
                    skybox.MoonAngularSize = skybox_state.original_skybox.MoonAngularSize
                    skybox.SunAngularSize = skybox_state.original_skybox.SunAngularSize
                end
            end
        end
        
        -- Функция изменения типа skybox
        function skybox_utility:changeType(type)
            skybox_state.current_type = type
            if skybox_state.enabled then
                self:applySkybox()
            end
        end
        
        -- Функция включения/выключения
        function skybox_utility:setEnabled(enabled)
            skybox_state.enabled = enabled
            self:applySkybox()
        end
        
        -- Функция очистки
        function skybox_utility:cleanup()
            if skybox_state.original_skybox and skybox_state.lighting then
                local skybox = skybox_state.lighting:FindFirstChildOfClass("Sky")
                if skybox then
                    skybox.SkyboxBk = skybox_state.original_skybox.SkyboxBk
                    skybox.SkyboxDn = skybox_state.original_skybox.SkyboxDn
                    skybox.SkyboxFt = skybox_state.original_skybox.SkyboxFt
                    skybox.SkyboxLf = skybox_state.original_skybox.SkyboxLf
                    skybox.SkyboxRt = skybox_state.original_skybox.SkyboxRt
                    skybox.SkyboxUp = skybox_state.original_skybox.SkyboxUp
                    skybox.StarCount = skybox_state.original_skybox.StarCount
                    skybox.CelestialBodiesShown = skybox_state.original_skybox.CelestialBodiesShown
                    skybox.MoonTextureId = skybox_state.original_skybox.MoonTextureId
                    skybox.SunTextureId = skybox_state.original_skybox.SunTextureId
                end
            end
        end
        
        -- Инициализируем skybox утилиту
        skybox_utility:init()
        
        -- Создаем UI элементы для Skybox
        local _skyboxToggle = worldSection:Toggle({
            Name = "Skybox",
            Default = false,
            Flag = "world_skybox",
            Callback = function(value)
                skybox_utility:setEnabled(value)
            end
        })
        
        -- Дропдаун для выбора типа skybox
        worldSection:Dropdown({
            Name = "Skybox Type",
            Items = {"Galaxy", "SpongeBob", "Blue", "Red"},
            Default = "Galaxy",
            Flag = "world_skybox_type",
            Callback = function(value)
                skybox_utility:changeType(value)
            end
        })
        
        -- Color Correction utility
        local color_correction_utility = {}
        local color_correction_state = {
            enabled = false,
            saturation = 0,
            brightness = 0,
            contrast = 0,
            color_correction = nil
        }
        
        -- Функция инициализации Color Correction
        function color_correction_utility:init()
            -- Ищем существующий ColorCorrection или создаем новый
            color_correction_state.color_correction = game:GetService("Lighting"):FindFirstChild("FentanylColorCorrection")
            
            if not color_correction_state.color_correction then
                color_correction_state.color_correction = Instance.new("ColorCorrectionEffect")
                color_correction_state.color_correction.Name = "FentanylColorCorrection"
                color_correction_state.color_correction.Enabled = false
                color_correction_state.color_correction.Saturation = 0
                color_correction_state.color_correction.Brightness = 0
                color_correction_state.color_correction.Contrast = 0
                color_correction_state.color_correction.Parent = game:GetService("Lighting")
            end
        end
        
        -- Функция применения color correction
        function color_correction_utility:applyCorrection()
            if not color_correction_state.color_correction then
                self:init()
            end
            
            if color_correction_state.enabled then
                color_correction_state.color_correction.Enabled = true
                color_correction_state.color_correction.Saturation = color_correction_state.saturation
                color_correction_state.color_correction.Brightness = color_correction_state.brightness
                color_correction_state.color_correction.Contrast = color_correction_state.contrast
            else
                color_correction_state.color_correction.Enabled = false
            end
        end
        
        -- Функция обновления saturation
        function color_correction_utility:updateSaturation(value)
            color_correction_state.saturation = value
            if color_correction_state.color_correction and color_correction_state.enabled then
                color_correction_state.color_correction.Saturation = value
            end
        end
        
        -- Функция обновления brightness
        function color_correction_utility:updateBrightness(value)
            color_correction_state.brightness = value
            if color_correction_state.color_correction and color_correction_state.enabled then
                color_correction_state.color_correction.Brightness = value
            end
        end
        
        -- Функция обновления contrast
        function color_correction_utility:updateContrast(value)
            color_correction_state.contrast = value
            if color_correction_state.color_correction and color_correction_state.enabled then
                color_correction_state.color_correction.Contrast = value
            end
        end
        
        -- Функция включения/выключения
        function color_correction_utility:setEnabled(enabled)
            color_correction_state.enabled = enabled
            self:applyCorrection()
        end
        
        -- Функция очистки
        function color_correction_utility:cleanup()
            if color_correction_state.color_correction then
                color_correction_state.color_correction.Enabled = false
            end
        end
        
        -- Инициализируем color correction утилиту
        color_correction_utility:init()
        
        -- Создаем UI элементы для Color Correction
        local _colorCorrectionToggle = worldSection:Toggle({
            Name = "Color Correction",
            Default = false,
            Flag = "world_color_correction",
            Callback = function(value)
                color_correction_utility:setEnabled(value)
            end
        })
        
        -- Слайдер для Saturation
        worldSection:Slider({
            Name = "Saturation",
            Min = -1,
            Max = 1,
            Default = 0,
            Decimals = 0.01,
            Flag = "world_saturation",
            Callback = function(value)
                color_correction_utility:updateSaturation(value)
            end
        })
        
        -- Слайдер для Brightness
        worldSection:Slider({
            Name = "Brightness",
            Min = -1,
            Max = 1,
            Default = 0,
            Decimals = 0.01,
            Flag = "world_brightness",
            Callback = function(value)
                color_correction_utility:updateBrightness(value)
            end
        })
        
        -- Слайдер для Contrast
        worldSection:Slider({
            Name = "Contrast",
            Min = -1,
            Max = 1,
            Default = 0,
            Decimals = 0.01,
            Flag = "world_contrast",
            Callback = function(value)
                color_correction_utility:updateContrast(value)
            end
        })
        
        -- Atmosphere utility
        local atmosphere_utility = {}
        local atmosphere_state = {
            enabled = false,
            color = z(199, 199, 199),
            decay = z(92, 60, 13),
            density = 0.395,
            haze = 0,
            glare = 0,
            offset = 0,
            atmosphere = nil
        }
        
        -- Функция инициализации Atmosphere
        function atmosphere_utility:init()
            -- Ищем существующий Atmosphere или создаем новый
            atmosphere_state.atmosphere = game:GetService("Lighting"):FindFirstChild("FentanylAtmosphere")
            
            if not atmosphere_state.atmosphere then
                atmosphere_state.atmosphere = Instance.new("Atmosphere")
                atmosphere_state.atmosphere.Name = "FentanylAtmosphere"
                atmosphere_state.atmosphere.Color = atmosphere_state.color
                atmosphere_state.atmosphere.Decay = atmosphere_state.decay
                atmosphere_state.atmosphere.Density = atmosphere_state.density
                atmosphere_state.atmosphere.Haze = atmosphere_state.haze
                atmosphere_state.atmosphere.Glare = atmosphere_state.glare
                atmosphere_state.atmosphere.Offset = atmosphere_state.offset
                atmosphere_state.atmosphere.Parent = game:GetService("Lighting")
            end
        end
        
        -- Функция применения atmosphere
        function atmosphere_utility:applyAtmosphere()
            if not atmosphere_state.atmosphere then
                self:init()
            end
            
            if atmosphere_state.enabled then
                atmosphere_state.atmosphere.Color = atmosphere_state.color
                atmosphere_state.atmosphere.Decay = atmosphere_state.decay
                atmosphere_state.atmosphere.Density = atmosphere_state.density
                atmosphere_state.atmosphere.Haze = atmosphere_state.haze
                atmosphere_state.atmosphere.Glare = atmosphere_state.glare
                atmosphere_state.atmosphere.Offset = atmosphere_state.offset
            else
                -- Восстанавливаем дефолтные значения
                atmosphere_state.atmosphere.Color = z(199, 199, 199)
                atmosphere_state.atmosphere.Decay = z(92, 60, 13)
                atmosphere_state.atmosphere.Density = 0.395
                atmosphere_state.atmosphere.Haze = 0
                atmosphere_state.atmosphere.Glare = 0
                atmosphere_state.atmosphere.Offset = 0
            end
        end
        
        -- Функция обновления цвета
        function atmosphere_utility:updateColor(color)
            atmosphere_state.color = color
            if atmosphere_state.atmosphere and atmosphere_state.enabled then
                atmosphere_state.atmosphere.Color = color
            end
        end
        
        -- Функция обновления decay
        function atmosphere_utility:updateDecay(color)
            atmosphere_state.decay = color
            if atmosphere_state.atmosphere and atmosphere_state.enabled then
                atmosphere_state.atmosphere.Decay = color
            end
        end
        
        -- Функция обновления density
        function atmosphere_utility:updateDensity(value)
            atmosphere_state.density = value
            if atmosphere_state.atmosphere and atmosphere_state.enabled then
                atmosphere_state.atmosphere.Density = value
            end
        end
        
        -- Функция обновления haze
        function atmosphere_utility:updateHaze(value)
            atmosphere_state.haze = value
            if atmosphere_state.atmosphere and atmosphere_state.enabled then
                atmosphere_state.atmosphere.Haze = value
            end
        end
        
        -- Функция обновления glare
        function atmosphere_utility:updateGlare(value)
            atmosphere_state.glare = value
            if atmosphere_state.atmosphere and atmosphere_state.enabled then
                atmosphere_state.atmosphere.Glare = value
            end
        end
        
        -- Функция обновления offset
        function atmosphere_utility:updateOffset(value)
            atmosphere_state.offset = value
            if atmosphere_state.atmosphere and atmosphere_state.enabled then
                atmosphere_state.atmosphere.Offset = value
            end
        end
        
        -- Функция включения/выключения
        function atmosphere_utility:setEnabled(enabled)
            atmosphere_state.enabled = enabled
            self:applyAtmosphere()
        end
        
        -- Функция очистки
        function atmosphere_utility:cleanup()
            if atmosphere_state.atmosphere then
                -- Восстанавливаем дефолтные значения
                atmosphere_state.atmosphere.Color = z(199, 199, 199)
                atmosphere_state.atmosphere.Decay = z(92, 60, 13)
                atmosphere_state.atmosphere.Density = 0.395
                atmosphere_state.atmosphere.Haze = 0
                atmosphere_state.atmosphere.Glare = 0
                atmosphere_state.atmosphere.Offset = 0
            end
        end
        
        -- Инициализируем atmosphere утилиту
        atmosphere_utility:init()
        
        -- Создаем UI элементы для Atmosphere
        local _atmosphereToggle = worldSection:Toggle({
            Name = "Atmosphere",
            Default = false,
            Flag = "world_atmosphere",
            Callback = function(value)
                atmosphere_utility:setEnabled(value)
            end
        })
        
        -- Колорпикер для Color
        _atmosphereToggle:Colorpicker({
            Name = "Color",
            Default = z(199, 199, 199),
            Flag = "world_atmosphere_color",
            Callback = function(color)
                atmosphere_utility:updateColor(color)
            end
        })
        
        -- Колорпикер для Decay
        _atmosphereToggle:Colorpicker({
            Name = "Decay",
            Default = z(92, 60, 13),
            Flag = "world_atmosphere_decay",
            Callback = function(color)
                atmosphere_utility:updateDecay(color)
            end
        })
        
        -- Слайдер для Density
        worldSection:Slider({
            Name = "Density",
            Min = 0,
            Max = 1,
            Default = 0.395,
            Decimals = 0.01,
            Flag = "world_atmosphere_density",
            Callback = function(value)
                atmosphere_utility:updateDensity(value)
            end
        })
        
        -- Слайдер для Haze
        worldSection:Slider({
            Name = "Haze",
            Min = 0,
            Max = 3,
            Default = 0,
            Decimals = 0.01,
            Flag = "world_atmosphere_haze",
            Callback = function(value)
                atmosphere_utility:updateHaze(value)
            end
        })
        
        -- Слайдер для Glare
        worldSection:Slider({
            Name = "Glare",
            Min = 0,
            Max = 2,
            Default = 0,
            Decimals = 0.01,
            Flag = "world_atmosphere_glare",
            Callback = function(value)
                atmosphere_utility:updateGlare(value)
            end
        })
        
        -- Слайдер для Offset
        worldSection:Slider({
            Name = "Offset",
            Min = 0,
            Max = 1,
            Default = 0,
            Decimals = 0.01,
            Flag = "world_atmosphere_offset",
            Callback = function(value)
                atmosphere_utility:updateOffset(value)
            end
        })
        
        -- Time utility
        local time_utility = {}
        local time_state = {
            enabled = false,
            hours = 12,
            minutes = 0,
            lighting = nil,
            update_connection = nil
        }
        
        -- Функция инициализации Time
        function time_utility:init()
            time_state.lighting = game:GetService("Lighting")
        end
        
        -- Функция применения времени
        function time_utility:applyTime()
            if not time_state.lighting then
                self:init()
            end
            
            if time_state.enabled then
                -- Отключаем предыдущее соединение если есть
                if time_state.update_connection then
                    time_state.update_connection:Disconnect()
                    time_state.update_connection = nil
                end
                
                -- Создаем соединение для постоянного обновления времени
                time_state.update_connection = b.Heartbeat:Connect(function()
                    if time_state.lighting then
                        -- Конвертируем часы и минуты в формат ClockTime
                        local clockTime = time_state.hours + (time_state.minutes / 60)
                        time_state.lighting.ClockTime = clockTime
                    end
                end)
            else
                -- Отключаем обновление времени
                if time_state.update_connection then
                    time_state.update_connection:Disconnect()
                    time_state.update_connection = nil
                end
            end
        end
        
        -- Функция обновления часов
        function time_utility:updateHours(value)
            time_state.hours = value
            if time_state.enabled and time_state.lighting then
                local clockTime = time_state.hours + (time_state.minutes / 60)
                time_state.lighting.ClockTime = clockTime
            end
        end
        
        -- Функция обновления минут
        function time_utility:updateMinutes(value)
            time_state.minutes = value
            if time_state.enabled and time_state.lighting then
                local clockTime = time_state.hours + (time_state.minutes / 60)
                time_state.lighting.ClockTime = clockTime
            end
        end
        
        -- Функция включения/выключения
        function time_utility:setEnabled(enabled)
            time_state.enabled = enabled
            self:applyTime()
        end
        
        -- Функция очистки
        function time_utility:cleanup()
            if time_state.update_connection then
                time_state.update_connection:Disconnect()
                time_state.update_connection = nil
            end
        end
        
        -- Инициализируем time утилиту
        time_utility:init()
        
        -- Создаем UI элементы для Time
        local _timeToggle = worldSection:Toggle({
            Name = "Time",
            Default = false,
            Flag = "world_time",
            Callback = function(value)
                time_utility:setEnabled(value)
            end
        })
        
        -- Слайдер для Hours
        worldSection:Slider({
            Name = "Hours",
            Min = 0,
            Max = 23,
            Default = 12,
            Decimals = 1,
            Flag = "world_time_hours",
            Callback = function(value)
                time_utility:updateHours(value)
            end
        })
        
        -- Слайдер для Minutes
        worldSection:Slider({
            Name = "Minutes",
            Min = 0,
            Max = 59,
            Default = 0,
            Decimals = 1,
            Flag = "world_time_minutes",
            Callback = function(value)
                time_utility:updateMinutes(value)
            end
        })
        
        -- Обработчики очистки при выходе
        g.CharacterRemoving:Connect(function()
            ambient_utility:restoreDefaults()
            tint_utility:cleanup()
            skybox_utility:cleanup()
            color_correction_utility:cleanup()
            atmosphere_utility:cleanup()
            time_utility:cleanup()
        end)
        
        -- Сохраняем утилиты в глобальную область
        _G.AmbientUtility = ambient_utility
        _G.TintUtility = tint_utility
        _G.SkyboxUtility = skybox_utility
        _G.ColorCorrectionUtility = color_correction_utility
        _G.AtmosphereUtility = atmosphere_utility
        _G.TimeUtility = time_utility
        
    end
    
end -- End Visuals Tab

do -- Watermark & Keybinds
    local Q = K:Watermark("Fentanyl | " .. g.Name .. " | " .. os.date("%y.%m.%d") .. " | Premium")
    local R = K:KeybindList()
    if Q then
        Q:SetVisibility(false)
    end
    if R then
        R:SetVisibility(false)
    end
    _G.Watermark = Q
    _G.KeybindList = R
end
do -- Settings Tab
    local S = L:Page({Name = "Settings", Columns = 2})
    local T = S:Section({Name = "Config", Side = 1})
    local U = ""
    local V = ""
    local _W = {}
    do
        if not isfolder("fentanyl") then
            makefolder("fentanyl")
        end
        if not isfolder("fentanyl/Configs") then
            makefolder("fentanyl/Configs")
        end
    end
    local function X()
        local configList = {}
        if isfolder("fentanyl/Configs") then
            for J, Y in ipairs(listfiles("fentanyl/Configs")) do
                local Z = Y:gsub("\\", "/")
                Z = Z:gsub("fentanyl/Configs/", "")
                p(configList, Z)
            end
        end
        return configList
    end
    local _ =
        T:Listbox(
        {Name = "Select Config", Items = X(), Default = "", Flag = "SelectedConfig", Callback = function(a0)
                U = a0
                print("Selected config:", a0)
            end}
    )
    local a1 =
        T:Textbox(
        {Name = "", Default = "", Placeholder = "Enter config name...", Flag = "ConfigName", Callback = function(a0)
                V = a0
            end}
    )
    local a2 =
        T:Button(
        {Name = "Create Config", Callback = function()
                if V and V ~= "" then
                    local a3 = V:gsub("%.json$", "") .. ".json"
                    local a4 = "fentanyl/Configs/" .. a3
                    if not isfile(a4) then
                        local a5 = K:GetConfig()
                        writefile(a4, a5)
                        K:Notification("Config created: " .. a3, 3, z(0, 255, 0))
                        _:Refresh(X())
                    else
                        K:Notification("Config already exists: " .. a3, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a6 =
        T:Button(
        {Name = "Save Config", Callback = function()
                local a3
                if U and U ~= "" then
                    a3 = U
                elseif V and V ~= "" then
                    a3 = V:gsub("%.json$", "") .. ".json"
                end
                if a3 then
                    local a4 = "fentanyl/Configs/" .. a3
                    local a5 = K:GetConfig()
                    writefile(a4, a5)
                    K:Notification("Config saved: " .. a3, 3, z(0, 255, 0))
                    _:Refresh(X())
                else
                    K:Notification("Please select or enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a7 =
        T:Button(
        {Name = "Load Config", Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    if isfile(a4) then
                        local a5 = readfile(a4)
                        K:LoadConfig(a5)
                        K:Notification("Config loaded: " .. U, 3, z(0, 255, 0))
                    else
                        K:Notification("Config not found: " .. U, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a8 =
        T:Button(
        {Name = "Delete Config", Risky = true, Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    print("Trying to delete config at path:", a4)
                    print("File exists:", isfile(a4))
                    if isfile(a4) then
                        delfile(a4)
                        K:Notification("Config deleted: " .. U, 3, z(0, 255, 0))
                        _:Refresh(X())
                        U = ""
                    else
                        K:Notification("Config not found: " .. a4, 5, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a9 =
        T:Button(
        {Name = "Refresh Config List", Callback = function()
                _:Refresh(X())
                K:Notification("Config list refreshed", 2, z(0, 255, 0))
            end}
    )
    local aa = S:Section({Name = "Theming", Side = 2})
    local ab = aa:Label("Accent Color", "Left")
    local ac =
        ab:Colorpicker(
        {
            Name = "Accent Color",
            Default = z(31, 226, 130),
            Alpha = 1,
            Flag = "ThemeAccentColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Accent", ad)
                if L.GradientTitle and L.GradientTitle.Enabled then
                    L.GradientTitle.Start = ad
                    L.GradientTitle.Middle = ad
                    L.GradientTitle.End = ad
                end
                
                -- Обновляем цвет ауры если она активна
                if _G.AuraUtility then
                    _G.AuraUtility:updateColor(ad)
                end
            end
        }
    )
    local af = aa:Label("Window Background", "Left")
    local ag =
        af:Colorpicker(
        {
            Name = "Window Background",
            Default = z(43, 43, 43),
            Alpha = 1,
            Flag = "ThemeWindowBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Window Background", ad)
            end
        }
    )
    local ah = aa:Label("Text Color", "Left")
    local ai =
        ah:Colorpicker(
        {
            Name = "Text Color",
            Default = z(180, 180, 180),
            Alpha = 1,
            Flag = "ThemeTextColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Text", ad)
            end
        }
    )
    local aj = aa:Label("Section Background", "Left")
    local ak =
        aj:Colorpicker(
        {
            Name = "Section Background",
            Default = z(19, 19, 19),
            Alpha = 1,
            Flag = "ThemeSectionBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Section Background", ad)
            end
        }
    )
    local al = aa:Label("Element Color", "Left")
    local am =
        al:Colorpicker(
        {
            Name = "Element Color",
            Default = z(63, 63, 63),
            Alpha = 1,
            Flag = "ThemeElementColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Element", ad)
            end
        }
    )
    local an = aa:Label("Border Color", "Left")
    local ao =
        an:Colorpicker(
        {
            Name = "Border Color",
            Default = z(68, 68, 68),
            Alpha = 1,
            Flag = "ThemeBorderColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Border", ad)
            end
        }
    )
    local ap = aa:Label("Outline Color", "Left")
    local aq =
        ap:Colorpicker(
        {
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 1,
            Flag = "ThemeOutlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Outline", ad)
            end
        }
    )
    local ar = aa:Label("Dark Liner", "Left")
    local as =
        ar:Colorpicker(
        {Name = "Dark Liner", Default = z(56, 56, 56), Alpha = 1, Flag = "ThemeDarkLiner", Callback = function(ad, ae)
                K:ChangeTheme("Dark Liner", ad)
            end}
    )
    local at = aa:Label("Risky Color", "Left")
    local au =
        at:Colorpicker(
        {
            Name = "Risky Color",
            Default = z(255, 50, 50),
            Alpha = 1,
            Flag = "ThemeRiskyColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Risky", ad)
            end
        }
    )
    local av = aa:Label("Inline Color", "Left")
    local aw =
        av:Colorpicker(
        {
            Name = "Inline Color",
            Default = z(12, 12, 12),
            Alpha = 1,
            Flag = "ThemeInlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Inline", ad)
            end
        }
    )
    local ax = S:Section({Name = "HUD", Side = 2})
    local ay =
        ax:Toggle(
        {Name = "Keybinds", Default = false, Flag = "HUDKeybinds", Callback = function(a0)
                if _G.KeybindList then
                    _G.KeybindList:SetVisibility(a0)
                end
            end}
    )
    local az =
        ax:Toggle(
        {Name = "Watermark", Default = false, Flag = "HUDWatermark", Callback = function(a0)
                if _G.Watermark then
                    _G.Watermark:SetVisibility(a0)
                end
            end}
    )
    local aA = ax:Label("GUI", "Left")
    local aB =
        aA:Keybind(
        {
            Name = "Toggle GUI",
            Mode = "Toggle",
            Default = Enum.KeyCode.Insert,
            Flag = "GUIToggleKey",
            Callback = function(aC)
                if L and L.SetOpen then
                    L:SetOpen(not L.IsOpen)
                end
            end
        }
    )
    do
        local aD = L.SetOpen
        L.SetOpen = function(self, aE)
            aD(self, aE)
            if aB and aB.Toggled ~= self.IsOpen then
                aB.Toggled = self.IsOpen
                if aB.KeybindListItem then
                    aB.KeybindListItem:SetStatus(self.IsOpen)
                end
            end
        end
    end
    do
        local aF = S:Section({Name = "Server", Side = 2})
        local aG =
            aF:Button(
            {Name = "Copy GameID", Callback = function()
                    setclipboard(tostring(game.GameId))
                    K:Notification("GameID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aH =
            aF:Button(
            {Name = "Copy JobID", Callback = function()
                    setclipboard(game.JobId)
                    K:Notification("JobID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aI =
            aF:Button(
            {
                Name = "Copy Join Script",
                Callback = function()
                    local aJ =
                        'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                    setclipboard(aJ)
                    K:Notification("Join script copied to clipboard", 2, z(0, 255, 0))
                end
            }
        )
        local aK =
            aF:Button(
            {Name = "Rejoin Game", Callback = function()
                    D:TeleportToPlaceInstance(game.PlaceId, game.JobId, g)
                end}
        )
        local aL =
            aF:Button(
            {
                Name = "Join New Server",
                Callback = function()
                    local aM, aN =
                        pcall(
                        function()
                            return e:JSONDecode(
                                game:HttpGetAsync(
                                    "https://games.roblox.com/v1/games/" ..
                                        game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                                )
                            )
                        end
                    )
                    if aM and aN and aN.data and #aN.data > 0 then
                        local aO = aN.data[h(1, #aN.data)]
                        D:TeleportToPlaceInstance(game.PlaceId, aO.id)
                    else
                        K:Notification("Failed to get server list", 3, z(255, 0, 0))
                    end
                end
            }
        )
    end
end

do -- Misc Tab
    
    
    do -- Movement Section
        local MovementSection = MiscPage:Section({Name = "Movement", Side = 1})
        
        -- Speed utility
        local speed_utility = {}
        local speed_state = {
            enabled = false,
            active = false,
            speed = 50,
            connection = nil,
            char_cache = {
                root = nil,
                humanoid = nil
            }
        }
        
        -- Fly utility
        local fly_utility = {}
        local fly_state = {
            enabled = false,
            active = false,
            speed = 1,
            connection = nil,
            stepped_connection = nil
        }
        
        -- NoClip utility function for fly
        function fly_utility:setNoClip(character, state)
            if not character then return end
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    if state then
                        if not part:GetAttribute("OriginalCollision") then
                            part:SetAttribute("OriginalCollision", part.CanCollide)
                            part:SetAttribute("OriginalTouch", part.CanTouch)
                            part:SetAttribute("OriginalQuery", part.CanQuery)
                        end
                        part.CanCollide, part.CanTouch, part.CanQuery = false, false, false
                    else
                        if part:GetAttribute("OriginalCollision") ~= nil then
                            part.CanCollide = part:GetAttribute("OriginalCollision")
                            part.CanTouch = part:GetAttribute("OriginalTouch") or true
                            part.CanQuery = part:GetAttribute("OriginalQuery") or true
                            part:SetAttribute("OriginalCollision", nil)
                            part:SetAttribute("OriginalTouch", nil)
                            part:SetAttribute("OriginalQuery", nil)
                        end
                    end
                end
            end
        end
        
        function fly_utility:updateFly(character)
            if fly_state.connection then 
                fly_state.connection:Disconnect()
                fly_state.connection = nil
            end
            if not character then return end
            if not (fly_state.enabled and fly_state.active) then return end
            
            self:setNoClip(character, true)
            
            fly_state.connection = b.Stepped:Connect(function()
                local char = g.Character
                if not char then return end
                self:setNoClip(char, true)
                
                local hrp = char:FindFirstChild("HumanoidRootPart")
                local hum = char:FindFirstChild("Humanoid")
                if not hrp or not hum then return end
                
                local speed = fly_state.speed * 50
                local velocity = B(0, 0, 0)
                
                if c:IsKeyDown(Enum.KeyCode.Space) then 
                    velocity = velocity + B(0, speed, 0)
                end
                if c:IsKeyDown(Enum.KeyCode.LeftControl) then 
                    velocity = velocity + B(0, -speed, 0)
                end
                if c:IsKeyDown(Enum.KeyCode.W) then 
                    velocity = velocity + (cam.CFrame.LookVector * speed)
                end
                if c:IsKeyDown(Enum.KeyCode.S) then 
                    velocity = velocity + (cam.CFrame.LookVector * -speed)
                end
                if c:IsKeyDown(Enum.KeyCode.D) then 
                    velocity = velocity + (cam.CFrame.RightVector * speed)
                end
                if c:IsKeyDown(Enum.KeyCode.A) then 
                    velocity = velocity + (cam.CFrame.RightVector * -speed)
                end
                
                hrp.Velocity = velocity
                hum:ChangeState("Freefall")
            end)
        end
        
        function fly_utility:stopFly()
            if fly_state.connection then 
                fly_state.connection:Disconnect()
                fly_state.connection = nil
            end
            
            local char = g.Character
            self:setNoClip(char, false)
            
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                local hum = char:FindFirstChild("Humanoid")
                if hrp then
                    hrp.Velocity = B(0, -2, 0)
                    local tmp
                    tmp = b.Stepped:Connect(function()
                        if not hrp or not hrp.Parent then 
                            tmp:Disconnect()
                            return
                        end
                        hrp.Velocity = B(0, hrp.Velocity.Y, 0)
                        tmp:Disconnect()
                    end)
                end
                if hum then 
                    hum:ChangeState("Landing")
                end
            end
        end
        
        function fly_utility:enable()
            fly_state.enabled = true
            fly_state.active = true
            if g.Character then
                self:updateFly(g.Character)
            end
        end
        
        function fly_utility:disable()
            fly_state.enabled = false
            fly_state.active = false
            self:stopFly()
        end
        
        function fly_utility:setSpeed(value)
            local num = tonumber(value)
            if num then
                fly_state.speed = math.clamp(num, 0.1, 100)
            end
        end
        
        function speed_utility:updateCharacter(character)
            if not character then return end
            
            speed_state.char_cache.root = character:WaitForChild("HumanoidRootPart")
            speed_state.char_cache.humanoid = character:WaitForChild("Humanoid")
            
            if speed_state.connection then
                speed_state.connection:Disconnect()
                speed_state.connection = nil
            end
            
            if speed_state.enabled then
                speed_state.connection = b.Heartbeat:Connect(function(dt)
                    if speed_state.enabled and speed_state.active then
                        local moveDirection = speed_state.char_cache.humanoid.MoveDirection
                        if moveDirection.Magnitude > 0 then
                            speed_state.char_cache.root.CFrame = speed_state.char_cache.root.CFrame + (moveDirection.Unit * speed_state.speed * dt)
                        end
                    end
                end)
            end
        end
        
        function speed_utility:enable()
            speed_state.enabled = true
            speed_state.active = true
            if g.Character then
                self:updateCharacter(g.Character)
            end
        end
        
        function speed_utility:disable()
            speed_state.enabled = false
            speed_state.active = false
            if speed_state.connection then
                speed_state.connection:Disconnect()
                speed_state.connection = nil
            end
        end
        
        function speed_utility:setSpeed(value)
            local num = tonumber(value)
            if num then
                speed_state.speed = math.clamp(num, 1, 2000)
            end
        end
        
        -- Character respawn support
        g.CharacterAdded:Connect(function(char)
            if speed_state.enabled then
                speed_utility:updateCharacter(char)
            end
            if fly_state.enabled then
                fly_utility:updateFly(char)
            end
        end)
        
        -- Speed UI Elements
        local SpeedToggle = MovementSection:Toggle({
            Name = "Speed",
            Flag = "SpeedEnabled",
            Default = false,
            Callback = function(value)
                if value then
                    speed_utility:enable()
                else
                    speed_utility:disable()
                end
            end
        })
        
        local SpeedTextbox = MovementSection:Textbox({
            Name = "Speed Value",
            Default = "50",
            Placeholder = "Enter speed...",
            Flag = "SpeedValue",
            Callback = function(value)
                speed_utility:setSpeed(value)
            end
        })
        
        -- Keybind for toggle
        SpeedToggle:Keybind({
            Name = "Speed Key",
            Mode = "Toggle",
            Default = Enum.KeyCode.V,
            Flag = "SpeedKey",
            Callback = function()
                if speed_state.enabled then
                    speed_state.active = not speed_state.active
                end
            end
        })
        
        -- Fly UI Elements
        local FlyToggle = MovementSection:Toggle({
            Name = "Fly",
            Flag = "FlyEnabled",
            Default = false,
            Callback = function(value)
                if value then
                    fly_utility:enable()
                else
                    fly_utility:disable()
                end
            end
        })
        
        local FlyTextbox = MovementSection:Textbox({
            Name = "Fly Speed",
            Default = "1",
            Placeholder = "Enter fly speed...",
            Flag = "FlySpeed",
            Callback = function(value)
                fly_utility:setSpeed(value)
            end
        })
        
        -- Fly Keybind
        FlyToggle:Keybind({
            Name = "Fly Key",
            Mode = "Toggle",
            Default = Enum.KeyCode.F,
            Flag = "FlyKey",
            Callback = function()
                if fly_state.enabled then
                    fly_state.active = not fly_state.active
                    if fly_state.active then
                        fly_utility:updateFly(g.Character)
                    else
                        fly_utility:stopFly()
                    end
                end
            end
        })
    end
end

do -- ESP Tab
    -- Инициализируем конфиг ESP если его нет
    _G.ESP_Config = _G.ESP_Config or {
        Box = {
            Enable = false,
            Color = z(255, 255, 255),
            Filled = {
                Enable = false,
                Transparency = 0.5,
                Gradient = {
                    Enable = true,
                    Color = {
                        Start = z(255, 255, 255),
                        End = z(0, 0, 255)
                    },
                    Rotating = {Enable = false}
                }
            }
        },
        Text = {
            Name = {
                Enable = false,
                Color = z(255, 255, 255),
                Size = 13,
                Font = "TahomaBold",
                Outline = true
            },
            Studs = {
                Enable = false,
                Color = z(255, 255, 255),
                Size = 13,
                Font = "TahomaBold",
                Outline = true
            },
            Tool = {
                Enable = false,
                Color = z(255, 255, 255),
                Size = 13,
                Font = "TahomaBold",
                Outline = true
            },
            State = {
                Enable = false,
                Color = z(255, 255, 255),
                Size = 13,
                Font = "TahomaBold",
                Outline = true
            }
        },
        Bars = {
            Enable = false,
            Health = {
                Enable = false,
                Color1 = z(0, 255, 0),
                Color2 = z(255, 0, 0),
                Side = "Left",
                Offset = 4
            },
            Armor = {
                Enable = false,
                Color1 = z(0, 0, 255),
                Color2 = z(255, 255, 0),
                Side = "Left",
                Offset = 4
            }
        },
        
        -- Дополнительные настройки ESP
        LimitDistance = false,
        MaxDistance = 1000
    }
    
    -- Загружаем и инициализируем ESP библиотеку один раз
    if not _G.ESP_Initialized then
        local success, result = pcall(function()
            return loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/fent.lua/refs/heads/main/esp"))()
        end)
        
        if success and result then
            _G.ESP_Library = result
            -- Инициализируем ESP только один раз при загрузке
            if _G.ESP_Library and _G.ESP_Library.init then
                _G.ESP_Library.init()
                _G.ESP_Initialized = true
            end
        else
            print("[ESP] Ошибка загрузки ESP библиотеки:", result)
        end
    end
    
    -- Секция Boxes в первой колонне
    local BoxesSection = ESP_Page:Section({Name = "Boxes", Side = 1})
    
    -- Тогл для включения бокс ESP
    local BoxESPToggle = BoxesSection:Toggle({
        Name = "Enable Box ESP",
        Default = false,
        Flag = "BoxESPEnabled",
        Callback = function(value)
            -- Просто обновляем конфиг, библиотека сама отслеживает изменения
            if _G.ESP_Config then
                _G.ESP_Config.Box.Enable = value
            end
        end
    })
    
    -- Колорпикер для цвета боксов
    BoxESPToggle:Colorpicker({
        Name = "Box Color",
        Default = z(255, 255, 255),
        Alpha = false,
        Flag = "BoxESPColor",
        Callback = function(color)
            -- Обновляем цвет боксов в конфиге
            if _G.ESP_Config then
                _G.ESP_Config.Box.Color = color
            end
        end
    })
    
    -- Тогл для заливки боксов
    local FilledToggle = BoxesSection:Toggle({
        Name = "Filled",
        Default = false,
        Flag = "BoxESPFilled",
        Callback = function(value)
            -- Обновляем конфиг для заливки боксов
            if _G.ESP_Config then
                _G.ESP_Config.Box.Filled.Enable = value
            end
        end
    })
    
    -- Первый колорпикер для градиента (начальный цвет)
    FilledToggle:Colorpicker({
        Name = "Gradient Start",
        Default = z(255, 255, 255),
        Alpha = false,
        Flag = "BoxESPGradientStart",
        Callback = function(color)
            -- Обновляем начальный цвет градиента
            if _G.ESP_Config then
                _G.ESP_Config.Box.Filled.Gradient.Color.Start = color
                -- Градиент всегда включен
                _G.ESP_Config.Box.Filled.Gradient.Enable = true
            end
        end
    })
    
    -- Второй колорпикер для градиента (конечный цвет)
    FilledToggle:Colorpicker({
        Name = "Gradient End",
        Default = z(0, 0, 255),
        Alpha = false,
        Flag = "BoxESPGradientEnd",
        Callback = function(color)
            -- Обновляем конечный цвет градиента
            if _G.ESP_Config then
                _G.ESP_Config.Box.Filled.Gradient.Color.End = color
                -- Градиент всегда включен
                _G.ESP_Config.Box.Filled.Gradient.Enable = true
            end
        end
    })
    
    -- Тогл для вращающегося градиента
    BoxesSection:Toggle({
        Name = "Rotating",
        Default = false,
        Flag = "BoxESPRotating",
        Callback = function(value)
            -- Обновляем настройку вращения градиента
            if _G.ESP_Config then
                _G.ESP_Config.Box.Filled.Gradient.Rotating.Enable = value
            end
        end
    })
    
    -- Секция HealthBar в первой колонне
    local HealthBarSection = ESP_Page:Section({Name = "HealthBar", Side = 1})
    
    -- Тогл для включения HealthBar
    local HealthBarToggle = HealthBarSection:Toggle({
        Name = "Enable HealthBar",
        Default = false,
        Flag = "HealthBarEnabled",
        Callback = function(value)
            -- Обновляем конфиг для HealthBar
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Health.Enable = value
            end
        end
    })
    
    -- Первый колорпикер для градиента HealthBar (начальный цвет)
    HealthBarToggle:Colorpicker({
        Name = "Health Start",
        Default = z(0, 255, 0),
        Alpha = false,
        Flag = "HealthBarGradientStart",
        Callback = function(color)
            -- Обновляем начальный цвет градиента HealthBar
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Health.Color1 = color
            end
        end
    })
    
    -- Второй колорпикер для градиента HealthBar (конечный цвет)
    HealthBarToggle:Colorpicker({
        Name = "Health End",
        Default = z(255, 0, 0),
        Alpha = false,
        Flag = "HealthBarGradientEnd",
        Callback = function(color)
            -- Обновляем конечный цвет градиента HealthBar
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Health.Color2 = color
            end
        end
    })
    
    -- Дропдаун для ориентации HealthBar
    HealthBarSection:Dropdown({
        Name = "Side",
        Items = {"Left", "Right", "Top", "Bot"},
        Default = "Left",
        Flag = "HealthBarSide",
        Callback = function(value)
            -- Обновляем ориентацию HealthBar
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Health.Side = value
            end
        end
    })
    
    -- Слайдер для padding HealthBar
    HealthBarSection:Slider({
        Name = "Padding",
        Min = 0,
        Max = 20,
        Default = 4,
        Flag = "HealthBarPadding",
        Callback = function(value)
            -- Обновляем padding HealthBar
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Health.Offset = value
            end
        end
    })
    
    
    -- Секция Armor в первой колонне
    local ArmorSection = ESP_Page:Section({Name = "Armor", Side = 1})
    
    -- Тогл для включения Armor
    local ArmorToggle = ArmorSection:Toggle({
        Name = "Enable Armor",
        Default = false,
        Flag = "ArmorEnabled",
        Callback = function(value)
            -- Обновляем конфиг для Armor
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Armor.Enable = value
            end
        end
    })
    
    -- Первый колорпикер для градиента Armor (начальный цвет)
    ArmorToggle:Colorpicker({
        Name = "Armor Start",
        Default = z(0, 0, 255),
        Alpha = false,
        Flag = "ArmorGradientStart",
        Callback = function(color)
            -- Обновляем начальный цвет градиента Armor
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Armor.Color1 = color
            end
        end
    })
    
    -- Второй колорпикер для градиента Armor (конечный цвет)
    ArmorToggle:Colorpicker({
        Name = "Armor End",
        Default = z(255, 255, 0),
        Alpha = false,
        Flag = "ArmorGradientEnd",
        Callback = function(color)
            -- Обновляем конечный цвет градиента Armor
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Armor.Color2 = color
            end
        end
    })
    
    -- Дропдаун для ориентации Armor
    ArmorSection:Dropdown({
        Name = "Side",
        Items = {"Left", "Right", "Top", "Bot"},
        Default = "Left",
        Flag = "ArmorSide",
        Callback = function(value)
            -- Обновляем ориентацию Armor
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Armor.Side = value
            end
        end
    })
    
    -- Слайдер для padding Armor
    ArmorSection:Slider({
        Name = "Padding",
        Min = 0,
        Max = 20,
        Default = 4,
        Flag = "ArmorPadding",
        Callback = function(value)
            -- Обновляем padding Armor
            if _G.ESP_Config then
                _G.ESP_Config.Bars.Armor.Offset = value
            end
        end
    })
    
    
    -- Секция Names во второй колонне
    local NamesSection = ESP_Page:Section({Name = "Names", Side = 2})
    
    -- Тогл для включения Name ESP
    local NameToggle = NamesSection:Toggle({
        Name = "Enable Name ESP",
        Default = false,
        Flag = "NameESPEnabled",
        Callback = function(value)
            -- Обновляем конфиг для Name ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.Name.Enable = value
            end
        end
    })
    
    -- Колорпикер для цвета шрифта
    NameToggle:Colorpicker({
        Name = "Text Color",
        Default = z(255, 255, 255),
        Alpha = false,
        Flag = "NameESPColor",
        Callback = function(color)
            -- Обновляем цвет шрифта
            if _G.ESP_Config then
                _G.ESP_Config.Text.Name.Color = color
            end
        end
    })
    
    -- Слайдер для размера шрифта Name
    NamesSection:Slider({
        Name = "Font Size",
        Min = 8,
        Max = 24,
        Default = 13,
        Flag = "NameESPFontSize",
        Callback = function(value)
            -- Обновляем размер шрифта Name
            if _G.ESP_Config then
                _G.ESP_Config.Text.Name.Size = value
            end
        end
    })
    
    -- Дропдаун для позиции Name ESP
    NamesSection:Dropdown({
        Name = "Side",
        Items = {"Top", "Bot"},
        Default = "Top",
        Flag = "NameESPSide",
        Callback = function(value)
            -- Обновляем позицию Name ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.Name.Side = value
            end
        end
    })
    
    -- Секция State во второй колонне
    local StateSection = ESP_Page:Section({Name = "State", Side = 2})
    
    -- Тогл для включения State ESP
    local StateToggle = StateSection:Toggle({
        Name = "Enable State ESP",
        Default = false,
        Flag = "StateESPEnabled",
        Callback = function(value)
            -- Обновляем конфиг для State ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.State.Enable = value
            end
        end
    })
    
    -- Колорпикер для цвета шрифта State
    StateToggle:Colorpicker({
        Name = "Text Color",
        Default = z(255, 255, 255),
        Alpha = false,
        Flag = "StateESPColor",
        Callback = function(color)
            -- Обновляем цвет шрифта State
            if _G.ESP_Config then
                _G.ESP_Config.Text.State.Color = color
            end
        end
    })
    
    -- Слайдер для размера шрифта State
    StateSection:Slider({
        Name = "Font Size",
        Min = 8,
        Max = 24,
        Default = 13,
        Flag = "StateESPFontSize",
        Callback = function(value)
            -- Обновляем размер шрифта State
            if _G.ESP_Config then
                _G.ESP_Config.Text.State.Size = value
            end
        end
    })
    
    -- Дропдаун для позиции State ESP
    StateSection:Dropdown({
        Name = "Side",
        Items = {"Top", "Bot"},
        Default = "Bot",
        Flag = "StateESPSide",
        Callback = function(value)
            -- Обновляем позицию State ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.State.Side = value
            end
        end
    })
    
    -- Секция Distance во второй колонне
    local DistanceSection = ESP_Page:Section({Name = "Distance", Side = 2})
    
    -- Тогл для включения Distance ESP
    local DistanceToggle = DistanceSection:Toggle({
        Name = "Enable Distance ESP",
        Default = false,
        Flag = "DistanceESPEnabled",
        Callback = function(value)
            -- Обновляем конфиг для Distance ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.Studs.Enable = value
            end
        end
    })
    
    -- Колорпикер для цвета шрифта Distance
    DistanceToggle:Colorpicker({
        Name = "Text Color",
        Default = z(255, 255, 255),
        Alpha = false,
        Flag = "DistanceESPColor",
        Callback = function(color)
            -- Обновляем цвет шрифта Distance
            if _G.ESP_Config then
                _G.ESP_Config.Text.Studs.Color = color
            end
        end
    })
    
    -- Слайдер для размера шрифта Distance
    DistanceSection:Slider({
        Name = "Font Size",
        Min = 8,
        Max = 24,
        Default = 13,
        Flag = "DistanceESPFontSize",
        Callback = function(value)
            -- Обновляем размер шрифта Distance
            if _G.ESP_Config then
                _G.ESP_Config.Text.Studs.Size = value
            end
        end
    })
    
    -- Дропдаун для позиции Distance ESP
    DistanceSection:Dropdown({
        Name = "Side",
        Items = {"Top", "Bot"},
        Default = "Bot",
        Flag = "DistanceESPSide",
        Callback = function(value)
            -- Обновляем позицию Distance ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.Studs.Side = value
            end
        end
    })
    
    -- Секция Tool во второй колонне
    local ToolSection = ESP_Page:Section({Name = "Tool", Side = 2})
    
    -- Тогл для включения Tool ESP
    local ToolToggle = ToolSection:Toggle({
        Name = "Enable Tool ESP",
        Default = false,
        Flag = "ToolESPEnabled",
        Callback = function(value)
            -- Обновляем конфиг для Tool ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.Tool.Enable = value
            end
        end
    })
    
    -- Колорпикер для цвета шрифта Tool
    ToolToggle:Colorpicker({
        Name = "Text Color",
        Default = z(255, 255, 255),
        Alpha = false,
        Flag = "ToolESPColor",
        Callback = function(color)
            -- Обновляем цвет шрифта Tool
            if _G.ESP_Config then
                _G.ESP_Config.Text.Tool.Color = color
            end
        end
    })
    
    -- Слайдер для размера шрифта Tool
    ToolSection:Slider({
        Name = "Font Size",
        Min = 8,
        Max = 24,
        Default = 13,
        Flag = "ToolESPFontSize",
        Callback = function(value)
            -- Обновляем размер шрифта Tool
            if _G.ESP_Config then
                _G.ESP_Config.Text.Tool.Size = value
            end
        end
    })
    
    -- Дропдаун для позиции Tool ESP
    ToolSection:Dropdown({
        Name = "Side",
        Items = {"Top", "Bot"},
        Default = "Bot",
        Flag = "ToolESPSide",
        Callback = function(value)
            -- Обновляем позицию Tool ESP
            if _G.ESP_Config then
                _G.ESP_Config.Text.Tool.Side = value
            end
        end
    })
    
    -- Секция Other во второй колонне
    local OtherSection = ESP_Page:Section({Name = "Other", Side = 2})
    
    -- Тогл для ограничения дистанции
    local LimitDistanceToggle = OtherSection:Toggle({
        Name = "Limit Distance",
        Default = false,
        Flag = "LimitDistanceEnabled",
        Callback = function(value)
            -- Обновляем конфиг для ограничения дистанции
            if _G.ESP_Config then
                _G.ESP_Config.LimitDistance = value
            end
        end
    })
    
    -- Слайдер для максимальной дистанции
    OtherSection:Slider({
        Name = "Max Distance",
        Min = 100,
        Max = 10000,
        Default = 1000,
        Flag = "MaxDistanceValue",
        Callback = function(value)
            -- Обновляем максимальную дистанцию
            if _G.ESP_Config then
                _G.ESP_Config.MaxDistance = value
            end
        end
    })
end

K:Notification("Script loaded, press Insert to toggle GUI", 4, z(0, 255, 0))
