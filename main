loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))() -- ac bypass dont touch or remove
local game = game
local workspace = workspace
local a = game:GetService("Players")
local b = game:GetService("RunService")
local c = game:GetService("UserInputService")
local d = game:GetService("TweenService")
local e = game:GetService("HttpService")
local f = game:GetService("Lighting")
local g = a.LocalPlayer
local h, i = math.random, math.huge
local j, k = math.floor, math.ceil
local l, m = math.abs, math.sqrt
local n, o = math.sin, math.cos
local p, q = table.insert, table.remove
local r, s = table.sort, table.concat
local t, u = string.format, string.match
local v, w = string.lower, string.upper
local x, y = string.sub, string.gsub
local pairs, ipairs = pairs, ipairs
local type, tostring = type, tostring
local pcall, xpcall = pcall, xpcall
local loadstring = loadstring
local setmetatable = setmetatable
local getmetatable = getmetatable
local z = Color3.fromRGB
local A = UDim2.new
local B = Vector3.new
local C = CFrame.new
local isfolder = isfolder
local isfile = isfile
local listfiles = listfiles
local writefile = writefile
local readfile = readfile
local delfile = delfile
local makefolder = makefolder
local setclipboard = setclipboard
local D = game:GetService("TeleportService")
local ps, run, uis, cam = a, b, c, workspace.CurrentCamera
local math, v2, v3, tick = math, Vector2.new, Vector3.new, tick
local LocalPlayer = g
local hookmetamethod = hookmetamethod
local checkcaller = checkcaller
local E = {}
local F = {}
do
    function E.new_connection(G, H)
        local I = G:Connect(H)
        p(F, I)
        return I
    end
    function E.disconnect_all()
        for J, I in ipairs(F) do
            if I then
                I:Disconnect()
            end
        end
        F = {}
    end
end

do -- Targeting Framework
    local targeting_state = {current = nil}
    pcall(function()
        _G.targeting_state = targeting_state
    end)
    
    local TargetingFramework = {}
    
    do -- Utility Functions
        local utility = {}
        
        function utility:ValidateClient(player)
            if not player then
                return false
            end
            local character = player.Character
            if not character then
                return false
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                return false
            end
            return humanoid.RootPart ~= nil
        end
        
        function utility:GetPreferredPart(character)
            return character and 
                (character:FindFirstChild("HumanoidRootPart") or 
                 character:FindFirstChild("Head") or 
                 character:FindFirstChild("UpperTorso") or
                 character:FindFirstChild("Torso")) or nil
        end
        
        function utility:ToScreen(position)
            local screenPos, onScreen = cam:WorldToViewportPoint(position)
            return v2(screenPos.X, screenPos.Y), onScreen
        end
        
        function utility:GetMouseLocation()
            return uis:GetMouseLocation()
        end
        
        function utility:GetMouseDistance(screenPos)
            return (utility:GetMouseLocation() - screenPos).Magnitude
        end
        
        function utility:getHeld()
            local character = LocalPlayer.Character
            if not character then return "None" end
            local tool = character:FindFirstChildOfClass("Tool")
            return tool or "None"
        end
        
        function utility:GetOrigin()
            local Tool = utility:getHeld()
            return (Tool ~= "None" and Tool.Handle and Tool.Handle.Position) or cam.CFrame.Position
        end
        
        TargetingFramework.utility = utility
    end
    
    do -- Core Framework Functions
        TargetingFramework._hit_listeners = {}
        TargetingFramework._target = {info = nil, listeners = {}}
        TargetingFramework._dd = {
            last_target = nil,
            last_char = nil,
            hum = nil,
            last_health = nil,
            last_max = nil,
            conn = nil,
            hum_conn = nil,
            last_debug_t = 0,
            override_player = nil
        }
        
        function TargetingFramework:GetClosestToMouse()
            local closestPlayer, closestDistance = nil, nil
            for _, player in ipairs(ps:GetPlayers()) do
                if player ~= LocalPlayer and self.utility:ValidateClient(player) then
                    local character = player.Character
                    local targetPart = self.utility:GetPreferredPart(character)
                    if targetPart then
                        local screenPos, onScreen = self.utility:ToScreen(targetPart.Position)
                        if onScreen then
                            local distance = self.utility:GetMouseDistance(screenPos)
                            if not closestDistance or distance < closestDistance then
                                closestPlayer, closestDistance = player, distance
                            end
                        end
                    end
                end
            end
            return closestPlayer, closestDistance or math.huge
        end
        
        function TargetingFramework:OnHit(callback)
            if typeof(callback) == "function" then
                p(self._hit_listeners, callback)
            end
        end
        
        function TargetingFramework:OnTargetUpdate(callback)
            if typeof(callback) == "function" then
                p(self._target.listeners, callback)
            end
        end
        
        function TargetingFramework:_emit_hit(targetInfo)
            for _, callback in ipairs(self._hit_listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:GetTargetInfo()
            local targetInfo = self._target.info
            return targetInfo ~= nil, targetInfo
        end
        
        function TargetingFramework:SetTargetInfo(player)
            local targetInfo = nil
            self._dd.override_player = player or nil
            
            if player and player.Character then
                local character = player.Character
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local rootPart = humanoid and humanoid.RootPart or character:FindFirstChild("HumanoidRootPart")
                local health = humanoid and humanoid.Health or nil
                local maxHealth = humanoid and humanoid.MaxHealth or nil
                local cframe = rootPart and rootPart.CFrame or (character.GetPivot and character:GetPivot() or nil)
                local position = rootPart and rootPart.Position or (cframe and cframe.Position or nil)
                
                targetInfo = {
                    isTarget = true,
                    player = player,
                    userId = player.UserId,
                    name = player.Name,
                    displayName = player.DisplayName,
                    character = character,
                    humanoid = humanoid,
                    root = rootPart,
                    cframe = cframe,
                    position = position,
                    health = health,
                    maxHealth = maxHealth,
                    alive = humanoid and humanoid.Health > 0,
                    time = os.clock()
                }
            end
            
            self._target.info = targetInfo
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, targetInfo)
            end
        end
        
        function TargetingFramework:ClearTargetInfo()
            self._target.info = nil
            self._dd.override_player = nil
            for _, callback in ipairs(self._target.listeners) do
                pcall(callback, nil)
            end
        end
        
        function TargetingFramework:SetCurrentTarget(player)
            self._dd.override_player = player
        end
        
        function TargetingFramework:ClearCurrentTarget()
            self._dd.override_player = nil
        end
        
        function TargetingFramework:GetCurrentTarget()
            return self._dd.override_player or (targeting_state and targeting_state.current or nil)
        end
    end
    
    do -- Target Selection Logic
        local TargetSelector = {}
        
        function TargetSelector:selectTarget()
            if targeting_state.current then
                targeting_state.current = nil
                TargetingFramework:ClearTargetInfo()
                TargetingFramework:ClearCurrentTarget()
            else
                local closestTarget, distance = TargetingFramework:GetClosestToMouse()
                if closestTarget then
                    targeting_state.current = closestTarget
                    TargetingFramework:SetTargetInfo(closestTarget)
                    TargetingFramework:SetCurrentTarget(closestTarget)
                end
            end
        end
        
        TargetingFramework.selector = TargetSelector
    end
    
    do -- Health Detection System
        if not TargetingFramework._dd.conn then
            TargetingFramework._dd.conn = run.Heartbeat:Connect(function()
                local dd = TargetingFramework._dd
                local currentTarget = dd.override_player or (targeting_state and targeting_state.current or nil)
                
                if currentTarget ~= dd.last_target then
                    dd.last_target = currentTarget
                    dd.last_char = nil
                    dd.hum = nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                end
                
                if not currentTarget then
                    return
                end
                
                local character = currentTarget.Character
                if character ~= dd.last_char or (dd.hum and not dd.hum.Parent) then
                    dd.last_char = character
                    dd.hum = character and character:FindFirstChildOfClass("Humanoid") or nil
                    dd.last_health = nil
                    dd.last_max = nil
                    
                    if dd.hum_conn then
                        pcall(function()
                            dd.hum_conn:Disconnect()
                        end)
                        dd.hum_conn = nil
                    end
                    
                    if dd.hum then
                        run.Heartbeat:Wait()
                        dd.hum_conn = dd.hum.HealthChanged:Connect(function(newHealth)
                            local maxHealth = dd.hum and dd.hum.MaxHealth or 0
                            if dd.last_health == nil or dd.last_max == nil or maxHealth ~= dd.last_max then
                                dd.last_health = newHealth
                                dd.last_max = maxHealth
                                return
                            end
                            
                            if newHealth < dd.last_health then
                                local damage = dd.last_health - newHealth
                                TargetingFramework:_emit_hit({
                                    player = currentTarget,
                                    damage = damage,
                                    health = newHealth,
                                    maxHealth = maxHealth,
                                    time = os.clock()
                                })
                            end
                            
                            dd.last_health = newHealth
                            dd.last_max = maxHealth
                        end)
                    end
                end
            end)
        end
    end
    
    _G.TargetingFramework = TargetingFramework
end


local K =
    loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/fent.lua/refs/heads/main/library"))()
local L =
    K:Window(
    {
        Name = "Fentik.sexyy",
        Size = UDim2.new(0, 700, 0, 670),
        GradientTitle = {
            Enabled = false,
            Enabled = false,
            Start = Color3.fromRGB(255, 255, 255),
            Middle = Color3.fromRGB(255, 255, 255),
            End = Color3.fromRGB(255, 255, 255),
            Speed = 0.1
        }
    }
)
local M = L:Page({Name = "Ragebot", Columns = 2})
local N = L:Page({Name = "Visuals", Columns = 2})
local O = L:Page({Name = "Misc", Columns = 2})
local P = L:Page({Name = "AntiAim", Columns = 2})

do -- Ragebot Tab
    local aP = M:Section({Name = "Targeting", Side = 1})
    local aQ = aP:Toggle({
        Name = "Targeting",
        Default = false,
        Flag = "TargetingEnabled",
        Callback = function(aR)
            if _G.TargetingFramework then
                if not aR then
                    _G.TargetingFramework:ClearTargetInfo()
                    _G.TargetingFramework:ClearCurrentTarget()
                    if _G.targeting_state then
                        _G.targeting_state.current = nil
                    end
                end
            end
        end
    })
    
    local aS = aQ:Keybind({
        Name = "Target Selection",
        Mode = "Toggle",
        Default = Enum.KeyCode.T,
        Flag = "TargetSelectionKey",
        Callback = function(aT)
            if K.Flags["TargetingEnabled"] and _G.TargetingFramework and _G.TargetingFramework.selector then
                _G.TargetingFramework.selector:selectTarget()
            end
        end
    })
    
    local aY = M:Section({Name = "Aimbot", Side = 1})
    local aZ = aY:Toggle({
        Name = "Enabled",
        Default = false,
        Flag = "AimbotEnabled",
        Callback = function(ba)
            -- Callback обрабатывается через aimbot logic
        end
    })
    
    local bb = aY:Textbox({
        Name = "XZ Prediction",
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotXZPrediction",
        Callback = function(bc)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bd = aY:Textbox({
        Name = "Y Prediction", 
        Default = "0.048",
        Placeholder = "0.048",
        Flag = "AimbotYPrediction",
        Callback = function(be)
            -- Значение автоматически обновляется через K.Flags
        end
    })
    
    local bf = aY:Toggle({
        Name = "ShowAimbot",
        Default = false,
        Flag = "ShowAimbot",
        Callback = function(bg)
            -- Callback обрабатывается через beam logic
        end
    })
    
    local bh = aY:Dropdown({
        Name = "Resolver Type",
        Items = {"Velocity", "MoveDirection", "CalculateCFrame"},
        Default = "Velocity",
        Flag = "ResolverType",
        Callback = function(bi)
            -- Callback обрабатывается через resolver logic
        end
    })
    
    local aT = M:Section({Name = "Notify", Side = 2})
    local aU = aT:Toggle({
        Name = "OnSelected",
        Default = false,
        Flag = "NotifyOnSelected",
        Callback = function(aV)
            -- Callback будет обработан через targeting framework
        end
    })
    
    local aW = aT:Toggle({
        Name = "OnDamage", 
        Default = false,
        Flag = "NotifyOnDamage",
        Callback = function(aX)
            -- Callback будет обработан через targeting framework
        end
    })
    
    do -- Notification Integration
        if _G.TargetingFramework then
            _G.TargetingFramework:OnTargetUpdate(function(targetInfo)
                if K.Flags["NotifyOnSelected"] then
                    if targetInfo then
                        K:Notification("Target selected: " .. targetInfo.name, 2, z(0, 255, 0))
                    else
                        K:Notification("Target cleared", 2, z(255, 255, 0))
                    end
                end
            end)
            
            _G.TargetingFramework:OnHit(function(hitInfo)
                if K.Flags["NotifyOnDamage"] and hitInfo then
                    local damageText = t("%.1f damage to %s", hitInfo.damage, hitInfo.player.Name)
                    K:Notification(damageText, 2, z(255, 100, 100))
                end
            end)
        end
    end
    
    do -- Aimbot Framework
        local AimbotFramework = {}
        local LastPosition = nil
        local LastUpdateTime = nil
        
        local function GetPredictedPosition(targetPlayer)
            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") then 
                return nil 
            end
            
            local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
            if not targetPart then 
                return nil 
            end
            
            if not LastPosition or not LastUpdateTime then
                LastPosition = targetPart.Position
                LastUpdateTime = tick()
                return LastPosition
            end
            
            local resolverType = K.Flags["ResolverType"] or "Velocity"
            local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
            local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
            
            if resolverType == "Velocity" then
                return targetPart.Position + B(
                    targetPart.Velocity.X * xzPrediction,
                    targetPart.Velocity.Y * yPrediction,
                    targetPart.Velocity.Z * xzPrediction
                )
            elseif resolverType == "MoveDirection" then
                return targetPart.Position + (targetPlayer.Character.Humanoid.MoveDirection * (xzPrediction * 10))
            elseif resolverType == "CalculateCFrame" then
                if (targetPart.Position - LastPosition).Magnitude < 0.001 then
                    return targetPart.Position
                else
                    LastUpdateTime, LastPosition = tick(), targetPart.Position
                    return LastPosition + (LastPosition - LastPosition).Unit * ((((LastPosition - LastPosition).Magnitude) / (tick() - LastUpdateTime)) * (0.1 * (xzPrediction * 10))) + B(0, ((LastPosition.Y - LastPosition.Y) / (tick() - LastUpdateTime) * (0.1 * xzPrediction)), 0)
                end
            end
            
            return targetPart.Position
        end
        
        local function CheckAimbot()
            return K.Flags["AimbotEnabled"] and K.Flags["TargetingEnabled"] and _G.targeting_state and _G.targeting_state.current
        end
        
        local originalIndex
        originalIndex = hookmetamethod(game, "__index", function(t, k)
            if t:IsA("Mouse") and (k == "Hit" or k == "Target") and not checkcaller() then
                if CheckAimbot() and _G.targeting_state.current then
                    local targetPlayer = _G.targeting_state.current
                    local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
                    
                    if targetPart then
                        local predictedPos = GetPredictedPosition(targetPlayer) or targetPart.Position
                        local hit = C(predictedPos)
                        return k == "Hit" and hit or targetPart
                    end
                end
            end
            return originalIndex(t, k)
        end)
        
        _G.AimbotFramework = AimbotFramework
    end
    
    do -- Beam Visualization
        local currentBeam = nil
        local beamConnection = nil
        
        local function CreateBeam()
            if currentBeam then
                currentBeam:Destroy()
                currentBeam = nil
            end
            
            local beam = Instance.new("Beam")
            beam.Color = ColorSequence.new(z(255, 0, 0))
            beam.Transparency = NumberSequence.new(0.3)
            beam.Width0 = 0.08
            beam.Width1 = 0.08
            beam.FaceCamera = true
            
            local attachment0 = Instance.new("Attachment")
            local attachment1 = Instance.new("Attachment")
            
            attachment0.Parent = workspace
            attachment1.Parent = workspace
            
            beam.Attachment0 = attachment0
            beam.Attachment1 = attachment1
            beam.Parent = workspace
            
            currentBeam = {beam = beam, att0 = attachment0, att1 = attachment1}
            return currentBeam
        end
        
        local function UpdateBeam()
            if not K.Flags["ShowAimbot"] or not K.Flags["AimbotEnabled"] or not K.Flags["TargetingEnabled"] then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not _G.targeting_state or not _G.targeting_state.current then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            if not currentBeam then
                currentBeam = CreateBeam()
            end
            
            -- Проверяем наличие оружия с handle
            local tool = _G.TargetingFramework and _G.TargetingFramework.utility and _G.TargetingFramework.utility:getHeld()
            if not tool or tool == "None" or not tool.Handle then
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
                return
            end
            
            local origin = tool.Handle.Position
            if not origin then return end
            
            local targetPlayer = _G.targeting_state.current
            local targetPart = targetPlayer.Character and (targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head"))
            if not targetPart then return end
            
            local function GetPredictedPosition(targetPlayer)
                if not targetPlayer or not targetPlayer.Character then return nil end
                
                local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Head")
                if not targetPart then return nil end
                
                -- Получаем актуальные значения из UI
                local xzPrediction = tonumber(K.Flags["AimbotXZPrediction"]) or 0.048
                local yPrediction = tonumber(K.Flags["AimbotYPrediction"]) or 0.048
                local velocity = targetPart.Velocity or B(0, 0, 0)
                
                -- Используем логику как в примере кода
                local predicted = targetPart.Position + B(
                    velocity.X * xzPrediction,
                    velocity.Y * yPrediction,
                    velocity.Z * xzPrediction
                )
                
                return predicted
            end
            
            local predictedPos = GetPredictedPosition(targetPlayer)
            currentBeam.att0.WorldPosition = origin
            currentBeam.att1.WorldPosition = predictedPos
        end
        
        beamConnection = run.Heartbeat:Connect(UpdateBeam)
        
        _G.BeamVisualization = {
            connection = beamConnection,
            cleanup = function()
                if beamConnection then
                    beamConnection:Disconnect()
                    beamConnection = nil
                end
                if currentBeam then
                    currentBeam.beam:Destroy()
                    currentBeam.att0:Destroy()
                    currentBeam.att1:Destroy()
                    currentBeam = nil
                end
            end
        }
    end
end
do
    local Q = K:Watermark("Fentanyl | " .. g.Name .. " | " .. os.date("%y.%m.%d") .. " | Premium")
    local R = K:KeybindList()
    if Q then
        Q:SetVisibility(false)
    end
    if R then
        R:SetVisibility(false)
    end
    _G.Watermark = Q
    _G.KeybindList = R
end
do
    local S = L:Page({Name = "Settings", Columns = 2})
    local T = S:Section({Name = "Config", Side = 1})
    local U = ""
    local V = ""
    local W = {}
    do
        if not isfolder("fentanyl") then
            makefolder("fentanyl")
        end
        if not isfolder("fentanyl/Configs") then
            makefolder("fentanyl/Configs")
        end
    end
    local function X()
        local W = {}
        if isfolder("fentanyl/Configs") then
            for J, Y in ipairs(listfiles("fentanyl/Configs")) do
                local Z = Y:gsub("\\", "/")
                Z = Z:gsub("fentanyl/Configs/", "")
                p(W, Z)
            end
        end
        return W
    end
    local _ =
        T:Listbox(
        {Name = "Select Config", Items = X(), Default = "", Flag = "SelectedConfig", Callback = function(a0)
                U = a0
                print("Selected config:", a0)
            end}
    )
    local a1 =
        T:Textbox(
        {Name = "", Default = "", Placeholder = "Enter config name...", Flag = "ConfigName", Callback = function(a0)
                V = a0
            end}
    )
    local a2 =
        T:Button(
        {Name = "Create Config", Callback = function()
                if V and V ~= "" then
                    local a3 = V:gsub("%.json$", "") .. ".json"
                    local a4 = "fentanyl/Configs/" .. a3
                    if not isfile(a4) then
                        local a5 = K:GetConfig()
                        writefile(a4, a5)
                        K:Notification("Config created: " .. a3, 3, z(0, 255, 0))
                        _:Refresh(X())
                    else
                        K:Notification("Config already exists: " .. a3, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a6 =
        T:Button(
        {Name = "Save Config", Callback = function()
                local a3
                if U and U ~= "" then
                    a3 = U
                elseif V and V ~= "" then
                    a3 = V:gsub("%.json$", "") .. ".json"
                end
                if a3 then
                    local a4 = "fentanyl/Configs/" .. a3
                    local a5 = K:GetConfig()
                    writefile(a4, a5)
                    K:Notification("Config saved: " .. a3, 3, z(0, 255, 0))
                    _:Refresh(X())
                else
                    K:Notification("Please select or enter a config name", 3, z(255, 255, 0))
                end
            end}
    )
    local a7 =
        T:Button(
        {Name = "Load Config", Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    if isfile(a4) then
                        local a5 = readfile(a4)
                        K:LoadConfig(a5)
                        K:Notification("Config loaded: " .. U, 3, z(0, 255, 0))
                    else
                        K:Notification("Config not found: " .. U, 3, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a8 =
        T:Button(
        {Name = "Delete Config", Risky = true, Callback = function()
                if U and U ~= "" then
                    local a4 = "fentanyl/Configs/" .. U
                    print("Trying to delete config at path:", a4)
                    print("File exists:", isfile(a4))
                    if isfile(a4) then
                        delfile(a4)
                        K:Notification("Config deleted: " .. U, 3, z(0, 255, 0))
                        _:Refresh(X())
                        U = ""
                    else
                        K:Notification("Config not found: " .. a4, 5, z(255, 0, 0))
                    end
                else
                    K:Notification("Please select a config", 3, z(255, 255, 0))
                end
            end}
    )
    local a9 =
        T:Button(
        {Name = "Refresh Config List", Callback = function()
                _:Refresh(X())
                K:Notification("Config list refreshed", 2, z(0, 255, 0))
            end}
    )
    local aa = S:Section({Name = "Theming", Side = 2})
    local ab = aa:Label("Accent Color", "Left")
    local ac =
        ab:Colorpicker(
        {
            Name = "Accent Color",
            Default = z(31, 226, 130),
            Alpha = 1,
            Flag = "ThemeAccentColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Accent", ad)
                if L.GradientTitle and L.GradientTitle.Enabled then
                    L.GradientTitle.Start = ad
                    L.GradientTitle.Middle = ad
                    L.GradientTitle.End = ad
                end
            end
        }
    )
    local af = aa:Label("Window Background", "Left")
    local ag =
        af:Colorpicker(
        {
            Name = "Window Background",
            Default = z(43, 43, 43),
            Alpha = 1,
            Flag = "ThemeWindowBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Window Background", ad)
            end
        }
    )
    local ah = aa:Label("Text Color", "Left")
    local ai =
        ah:Colorpicker(
        {
            Name = "Text Color",
            Default = z(180, 180, 180),
            Alpha = 1,
            Flag = "ThemeTextColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Text", ad)
            end
        }
    )
    local aj = aa:Label("Section Background", "Left")
    local ak =
        aj:Colorpicker(
        {
            Name = "Section Background",
            Default = z(19, 19, 19),
            Alpha = 1,
            Flag = "ThemeSectionBackground",
            Callback = function(ad, ae)
                K:ChangeTheme("Section Background", ad)
            end
        }
    )
    local al = aa:Label("Element Color", "Left")
    local am =
        al:Colorpicker(
        {
            Name = "Element Color",
            Default = z(63, 63, 63),
            Alpha = 1,
            Flag = "ThemeElementColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Element", ad)
            end
        }
    )
    local an = aa:Label("Border Color", "Left")
    local ao =
        an:Colorpicker(
        {
            Name = "Border Color",
            Default = z(68, 68, 68),
            Alpha = 1,
            Flag = "ThemeBorderColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Border", ad)
            end
        }
    )
    local ap = aa:Label("Outline Color", "Left")
    local aq =
        ap:Colorpicker(
        {
            Name = "Outline Color",
            Default = z(0, 0, 0),
            Alpha = 1,
            Flag = "ThemeOutlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Outline", ad)
            end
        }
    )
    local ar = aa:Label("Dark Liner", "Left")
    local as =
        ar:Colorpicker(
        {Name = "Dark Liner", Default = z(56, 56, 56), Alpha = 1, Flag = "ThemeDarkLiner", Callback = function(ad, ae)
                K:ChangeTheme("Dark Liner", ad)
            end}
    )
    local at = aa:Label("Risky Color", "Left")
    local au =
        at:Colorpicker(
        {
            Name = "Risky Color",
            Default = z(255, 50, 50),
            Alpha = 1,
            Flag = "ThemeRiskyColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Risky", ad)
            end
        }
    )
    local av = aa:Label("Inline Color", "Left")
    local aw =
        av:Colorpicker(
        {
            Name = "Inline Color",
            Default = z(12, 12, 12),
            Alpha = 1,
            Flag = "ThemeInlineColor",
            Callback = function(ad, ae)
                K:ChangeTheme("Inline", ad)
            end
        }
    )
    local ax = S:Section({Name = "HUD", Side = 2})
    local ay =
        ax:Toggle(
        {Name = "Keybinds", Default = false, Flag = "HUDKeybinds", Callback = function(a0)
                if _G.KeybindList then
                    _G.KeybindList:SetVisibility(a0)
                end
            end}
    )
    local az =
        ax:Toggle(
        {Name = "Watermark", Default = false, Flag = "HUDWatermark", Callback = function(a0)
                if _G.Watermark then
                    _G.Watermark:SetVisibility(a0)
                end
            end}
    )
    local aA = ax:Label("GUI", "Left")
    local aB =
        aA:Keybind(
        {
            Name = "Toggle GUI",
            Mode = "Toggle",
            Default = Enum.KeyCode.Insert,
            Flag = "GUIToggleKey",
            Callback = function(aC)
                if L and L.SetOpen then
                    L:SetOpen(not L.IsOpen)
                end
            end
        }
    )
    do
        local aD = L.SetOpen
        L.SetOpen = function(self, aE)
            aD(self, aE)
            if aB and aB.Toggled ~= self.IsOpen then
                aB.Toggled = self.IsOpen
                if aB.KeybindListItem then
                    aB.KeybindListItem:SetStatus(self.IsOpen)
                end
            end
        end
    end
    do
        local aF = S:Section({Name = "Server", Side = 2})
        local aG =
            aF:Button(
            {Name = "Copy GameID", Callback = function()
                    setclipboard(tostring(game.GameId))
                    K:Notification("GameID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aH =
            aF:Button(
            {Name = "Copy JobID", Callback = function()
                    setclipboard(game.JobId)
                    K:Notification("JobID copied to clipboard", 2, z(0, 255, 0))
                end}
        )
        local aI =
            aF:Button(
            {
                Name = "Copy Join Script",
                Callback = function()
                    local aJ =
                        'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                    setclipboard(aJ)
                    K:Notification("Join script copied to clipboard", 2, z(0, 255, 0))
                end
            }
        )
        local aK =
            aF:Button(
            {Name = "Rejoin Game", Callback = function()
                    D:TeleportToPlaceInstance(game.PlaceId, game.JobId, g)
                end}
        )
        local aL =
            aF:Button(
            {
                Name = "Join New Server",
                Callback = function()
                    local aM, aN =
                        pcall(
                        function()
                            return e:JSONDecode(
                                game:HttpGetAsync(
                                    "https://games.roblox.com/v1/games/" ..
                                        game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                                )
                            )
                        end
                    )
                    if aM and aN and aN.data and #aN.data > 0 then
                        local aO = aN.data[h(1, #aN.data)]
                        D:TeleportToPlaceInstance(game.PlaceId, aO.id)
                    else
                        K:Notification("Failed to get server list", 3, z(255, 0, 0))
                    end
                end
            }
        )
    end
end
K:Notification("Script loaded, press Insert to toggle GUI", 4, z(0, 255, 0))
