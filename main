-- Переменные (согласно правилам пользователя)
-- Services
local game = game
local Players = game:GetService("Players")
local workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")

-- Players
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Math
local random, huge = math.random, math.huge
local floor, ceil = math.floor, math.ceil
local abs, sqrt = math.abs, math.sqrt
local sin, cos = math.sin, math.cos
local rad, deg = math.rad, math.deg
local min, max = math.min, math.max
local clamp = math.clamp
local atan2 = math.atan2
local pi = math.pi

-- Глобальные переменные для ShowAimbot
showAimbot = false
aimbotColor = Color3.fromRGB(255, 0, 0)
aimbotTracer = nil
currentAimPosition = nil

-- Table
local insert, remove = table.insert, table.remove
local sort, concat = table.sort, table.concat

-- String
local format, match = string.format, string.match
local lower, upper = string.lower, string.upper
local sub, gsub = string.sub, string.gsub

-- Types
local Instance = Instance
local Enum = Enum
local Drawing = Drawing
local Color3 = Color3
local Vector2 = Vector2
local Vector3 = Vector3
local CFrame = CFrame
local Ray = Ray
local UDim2 = UDim2

-- Constructors
local setmetatable = setmetatable
local getmetatable = getmetatable
local newcclosure = newcclosure
local Instance_new = Instance.new
local Color3fromRGB = Color3.fromRGB
local UDim2new = UDim2.new
local Vector2new = Vector2.new
local Vector3new = Vector3.new
local CFramenew = CFrame.new

-- Other
local pairs, ipairs = pairs, ipairs
local type, tostring = type, tostring
local pcall, xpcall = pcall, xpcall
local loadstring = loadstring

-- File system functions
local isfolder = isfolder
local isfile = isfile
local listfiles = listfiles
local writefile = writefile
local readfile = readfile
local delfile = delfile
local makefolder = makefolder

-- Clipboard
local setclipboard = setclipboard

-- Services for server functions
local TeleportService = game:GetService("TeleportService")

-- Utility библиотека
local utility = {}
local connections = {}

-- Utility функции
do
    function utility.new_connection(event, callback)
        local connection = event:Connect(callback)
        insert(connections, connection)
        return connection
    end
    
    function utility.disconnect_all()
        for _, connection in ipairs(connections) do
            if connection then
                connection:Disconnect()
            end
        end
        connections = {}
    end
    
    function utility.getHeld()
        local character = LocalPlayer.Character
        if not character then return nil end
        
        for _, tool in pairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                return tool
            end
        end
        return nil
    end
    
    function utility.getCharacter(player)
        return player and player.Character
    end
    
    function utility.getHumanoidRootPart(character)
        return character and character:FindFirstChild("HumanoidRootPart")
    end
    
    function utility.getMousePosition()
        return UserInputService:GetMouseLocation()
    end
    
    function utility.worldToViewportPoint(position)
        return Camera:WorldToViewportPoint(position)
    end
end

-- Загрузка UI библиотеки
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/fent.lua/refs/heads/main/library"))()

-- Проверка загрузки библиотеки
if not Library then
    warn("Failed to load UI Library")
    return
end

-- Создание основного окна
local Window = Library:Window({
    Name = "Fentik.sexyy",
    Size = UDim2.new(0, 700, 0, 670),
    GradientTitle = {
        Enabled = false,
        Enabled = false,
        Start = Color3.fromRGB(255, 255, 255),
        Middle = Color3.fromRGB(255, 255, 255),
        End = Color3.fromRGB(255, 255, 255),
        Speed = 0.1
    }
})

local RagebotPage = Window:Page({
    Name = "Ragebot",
    Columns = 2
})

-- Ragebot вкладка (изолирована в блоке)
do
    -- Utility функции для RageBot
    local utility = {}
    
    utility.getCharacter = function(player)
        return player and player.Character
    end
    
    utility.getHumanoid = function(character)
        return character and character:FindFirstChildOfClass("Humanoid")
    end
    
    utility.getHumanoidRootPart = function(character)
        return character and character:FindFirstChild("HumanoidRootPart")
    end
    
    utility.isAlive = function(character)
        local humanoid = utility.getHumanoid(character)
        return humanoid and humanoid.Health > 0
    end
    
    utility.hasForceField = function(character)
        return character and character:FindFirstChild("ForceField") ~= nil
    end
    
    utility.getDistance = function(pos1, pos2)
        return (pos1 - pos2).Magnitude
    end
    
    utility.worldToViewportPoint = function(position)
        return workspace.CurrentCamera:WorldToViewportPoint(position)
    end
    
    utility.getMousePosition = function()
        local mouse = LocalPlayer:GetMouse()
        return Vector2new(mouse.X, mouse.Y)
    end
    
    utility.getBulletStart = function()
        local character = utility.getCharacter(LocalPlayer)
        if not character then return nil end
        
        for _, tool in pairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                local bulletStart = tool:FindFirstChild("BulletStart")
                if bulletStart then
                    return bulletStart
                end
            end
        end
        return nil
    end
    
    utility.canShoot = function()
        local character = utility.getCharacter(LocalPlayer)
        if not utility.isAlive(character) then return false end
        if utility.hasForceField(character) then return false end
        
        -- Проверяем наличие оружия
        local bulletStart = utility.getBulletStart()
        return bulletStart ~= nil
    end
    
    -- Framework функции для таргетинга
    local framework = {}
    
    framework.getValidTargets = function()
        local validTargets = {}
        local localChar = utility.getCharacter(LocalPlayer)
        if not localChar then return validTargets end
        
        local localHRP = utility.getHumanoidRootPart(localChar)
        if not localHRP then return validTargets end
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local targetChar = utility.getCharacter(player)
                if targetChar and utility.isAlive(targetChar) and not utility.hasForceField(targetChar) then
                    local targetHRP = utility.getHumanoidRootPart(targetChar)
                    if targetHRP then
                        insert(validTargets, {
                            player = player,
                            character = targetChar,
                            humanoidRootPart = targetHRP,
                            distance = utility.getDistance(localHRP.Position, targetHRP.Position)
                        })
                    end
                end
            end
        end
        
        return validTargets
    end
    
    framework.getClosestTarget = function()
        local targets = framework.getValidTargets()
        if #targets == 0 then return nil end
        
        sort(targets, function(a, b)
            return a.distance < b.distance
        end)
        
        return targets[1]
    end
    
    framework.getClosestToCursor = function()
        local targets = framework.getValidTargets()
        if #targets == 0 then return nil end
        
        local mousePos = utility.getMousePosition()
        local closestTarget = nil
        local closestDistance = huge
        
        for _, target in ipairs(targets) do
            local screenPos, onScreen = utility.worldToViewportPoint(target.humanoidRootPart.Position)
            local screenPoint = Vector2new(screenPos.X, screenPos.Y)
            local distance = (mousePos - screenPoint).Magnitude
            
            if distance < closestDistance then
                closestDistance = distance
                closestTarget = target
            end
        end
        
        return closestTarget
    end
    
    framework.getTargetPart = function(character, priority)
        if not character then return nil end
        
        -- R6 части тела
        if priority == "Head" then
            return character:FindFirstChild("Head")
        elseif priority == "Torso" then
            return character:FindFirstChild("Torso")
        elseif priority == "Left Arm" then
            return character:FindFirstChild("Left Arm")
        elseif priority == "Right Arm" then
            return character:FindFirstChild("Right Arm")
        elseif priority == "Left Leg" then
            return character:FindFirstChild("Left Leg")
        elseif priority == "Right Leg" then
            return character:FindFirstChild("Right Leg")
        elseif priority == "Random" then
            local parts = {}
            local r6Parts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
            for _, partName in ipairs(r6Parts) do
                local part = character:FindFirstChild(partName)
                if part then insert(parts, part) end
            end
            
            if #parts > 0 then
                return parts[random(1, #parts)]
            end
        end
        
        return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
    end
    
    framework.predictPosition = function(target, predictionTime)
        if not target or not target.humanoidRootPart then return target.humanoidRootPart.Position end
        
        local humanoid = utility.getHumanoid(target.character)
        if humanoid then
            local velocity = target.humanoidRootPart.AssemblyLinearVelocity
            if velocity then
                return target.humanoidRootPart.Position + (velocity * predictionTime)
            end
        end
        
        return target.humanoidRootPart.Position
    end
    
    framework.aimAt = function(targetPosition)
        local character = utility.getCharacter(LocalPlayer)
        if not character then return end
        
        -- Сохраняем позицию для трейсера
        currentAimPosition = targetPosition
        
        -- Обновляем трейсер если включен
        if showAimbot and aimbotTracer then
            framework.updateTracer(targetPosition)
        end
        
        -- Создаем/обновляем значения для встроенной системы стрельбы
        local aimPos = character:FindFirstChild("aimpos")
        if not aimPos then
            aimPos = Instance.new("Vector3Value")
            aimPos.Name = "aimpos"
            aimPos.Parent = character
        end
        aimPos.Value = targetPosition
        
        local rageAim = character:FindFirstChild("rageaim")
        if not rageAim then
            rageAim = Instance.new("BoolValue")
            rageAim.Name = "rageaim"
            rageAim.Parent = character
        end
        rageAim.Value = true
    end
    
    framework.shoot = function()
        local character = utility.getCharacter(LocalPlayer)
        if not character then return end
        
        local autoShoot = character:FindFirstChild("autoshoot")
        if not autoShoot then
            autoShoot = Instance.new("BoolValue")
            autoShoot.Name = "autoshoot"
            autoShoot.Parent = character
        end
        autoShoot.Value = true
    end
    
    framework.stopShooting = function()
        local character = utility.getCharacter(LocalPlayer)
        if not character then return end
        
        local autoShoot = character:FindFirstChild("autoshoot")
        if autoShoot then
            autoShoot.Value = false
        end
        
        local rageAim = character:FindFirstChild("rageaim")
        if rageAim then
            rageAim.Value = false
        end
        
        -- Скрываем трейсер
        if aimbotTracer then
            aimbotTracer.Parent = nil
        end
        currentAimPosition = nil
    end
    
    framework.createTracer = function()
        -- Создаем 3D трейсер через Part
        if aimbotTracer then
            aimbotTracer:Destroy()
        end
        
        aimbotTracer = Instance.new("Part")
        aimbotTracer.Name = "AimbotTracer"
        aimbotTracer.Anchored = true
        aimbotTracer.CanCollide = false
        aimbotTracer.Material = Enum.Material.Neon
        aimbotTracer.Color = aimbotColor
        aimbotTracer.Size = Vector3new(0.1, 0.1, 1)
        aimbotTracer.Transparency = 0.5
        
        return aimbotTracer
    end
    
    framework.updateTracer = function(targetPosition)
        if not aimbotTracer or not targetPosition then return end
        
        local character = utility.getCharacter(LocalPlayer)
        if not character then return end
        
        -- Получаем позицию начала трейсера (откуда стреляем)
        local startPosition
        
        -- Используем utility.getBulletStart() который уже правильно находит BulletStart
        local bulletStartPart = utility.getBulletStart()
        if bulletStartPart then
            startPosition = bulletStartPart.Position
        else
            -- Если нет BulletStart, используем голову или HRP
            local head = character:FindFirstChild("Head")
            local hrp = character:FindFirstChild("HumanoidRootPart")
            startPosition = (head and head.Position) or (hrp and hrp.Position)
        end
        
        if not startPosition then return end
        
        -- Вычисляем длину и позицию трейсера
        local distance = (targetPosition - startPosition).Magnitude
        local midPoint = (startPosition + targetPosition) / 2
        
        -- Обновляем трейсер
        aimbotTracer.Size = Vector3new(0.1, 0.1, distance)
        aimbotTracer.CFrame = CFramenew(midPoint, targetPosition)
        aimbotTracer.Color = aimbotColor
        aimbotTracer.Parent = workspace
    end
    
    -- Переменные для RageBot
    local rageBotEnabled = false
    local rageBotConnection = nil
    local targetingMode = "Closest"
    local selectedHitParts = {Head = true} -- По умолчанию только голова
    local overrideEnabled = false
    local overrideHitParts = {Head = true} -- Override хитпарты
    
    -- Система приоритетов для R6 частей тела
    local partPriorities = {
        Head = 10,
        Torso = 8,
        ["Left Arm"] = 6,
        ["Right Arm"] = 6,
        ["Left Leg"] = 4,
        ["Right Leg"] = 4
    }
    
    -- Функция проверки видимости части через raycast
    local function isPartVisible(part)
        local character = utility.getCharacter(LocalPlayer)
        if not character then return false end
        
        local bulletStart = utility.getBulletStart()
        local origin = bulletStart and bulletStart.Position or character.Head.Position
        
        local direction = (part.Position - origin).Unit * (part.Position - origin).Magnitude
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        -- Исключаем камеру и локального игрока (пули проходят сквозь нас)
        raycastParams.FilterDescendantsInstances = {workspace.CurrentCamera, character}
        
        local result = workspace:Raycast(origin, direction, raycastParams)
        
        -- Если луч попал в часть цели или ничего не попал - часть видима
        return not result or result.Instance:IsDescendantOf(part.Parent)
    end
    
    -- Переменные для стабилизации выбора части
    local lastSelectedPart = nil
    local partStabilityTimer = 0
    local PART_STABILITY_TIME = 0.05 -- Время стабилизации в секундах (уменьшено для быстрого отклика)
    
    -- Кэш для оптимизации raycast проверок
    local visibilityCache = {}
    local cacheExpireTime = 0.1 -- Кэш действует 100ms
    
    -- Оптимизированная функция проверки видимости с кэшированием
    local function isPartVisibleCached(part)
        local partId = tostring(part)
        local currentTime = tick()
        
        -- Проверяем кэш
        local cached = visibilityCache[partId]
        if cached and (currentTime - cached.time) < cacheExpireTime then
            return cached.visible
        end
        
        -- Выполняем проверку и кэшируем результат
        local visible = isPartVisible(part)
        visibilityCache[partId] = {visible = visible, time = currentTime}
        
        return visible
    end
    
    -- Функция динамического выбора части по приоритету и видимости (оптимизированная)
    local function getBestVisiblePart(targetCharacter)
        local bestPart = nil
        
        -- Выбираем какие хитпарты использовать (override или обычные)
        local currentHitParts = overrideEnabled and overrideHitParts or selectedHitParts
        
        -- Быстрая проверка последней выбранной части (без raycast если возможно)
        if lastSelectedPart and lastSelectedPart.Parent == targetCharacter and 
           currentHitParts[lastSelectedPart.Name] then
            local currentTime = tick()
            -- Если прошло мало времени, возвращаем без дополнительных проверок
            if (currentTime - partStabilityTimer) < PART_STABILITY_TIME then
                return lastSelectedPart
            end
            -- Иначе проверяем видимость с кэшем
            if isPartVisibleCached(lastSelectedPart) then
                partStabilityTimer = currentTime
                return lastSelectedPart
            end
        end
        
        -- Ищем лучшую доступную часть (сортируем по приоритету для быстрого поиска)
        local sortedParts = {}
        for partName, isSelected in pairs(currentHitParts) do
            if isSelected then
                local priority = partPriorities[partName] or 0
                table.insert(sortedParts, {name = partName, priority = priority})
            end
        end
        
        -- Сортируем по убыванию приоритета
        table.sort(sortedParts, function(a, b) return a.priority > b.priority end)
        
        -- Проверяем части в порядке приоритета
        for _, partData in ipairs(sortedParts) do
            local part = framework.getTargetPart(targetCharacter, partData.name)
            if part and isPartVisibleCached(part) then
                bestPart = part
                break -- Прерываем на первой найденной части с высшим приоритетом
            end
        end
        
        -- Обновляем последнюю выбранную часть
        if bestPart then
            lastSelectedPart = bestPart
            partStabilityTimer = tick()
        end
        
        return bestPart
    end
    
    -- Секция RageBot в первой колонне
    local RageBotSection = RagebotPage:Section({
        Name = "RageBot",
        Side = 1
    })
    
    -- Основной тоггл RageBot
    local RageBotToggle = RageBotSection:Toggle({
        Name = "Enable RageBot",
        Flag = "RageBotEnabled",
        Default = false,
        Callback = function(value)
            rageBotEnabled = value
            
            if rageBotEnabled then
                -- Запускаем RageBot
                rageBotConnection = RunService.RenderStepped:Connect(function()
                    if not utility.canShoot() then
                        framework.stopShooting()
                        return
                    end
                    
                    local target = nil
                    
                    -- Выбираем цель в зависимости от режима
                    if targetingMode == "Closest" then
                        target = framework.getClosestTarget()
                    elseif targetingMode == "Cursor" then
                        target = framework.getClosestToCursor()
                    end
                    
                    if target then
                        -- Динамически выбираем лучшую видимую часть
                        local targetPart = getBestVisiblePart(target.character)
                        if targetPart then
                            framework.aimAt(targetPart.Position)
                        end
                        
                        -- Автоматически стреляем
                        framework.shoot()
                    else
                        framework.stopShooting()
                    end
                end)
            else
                -- Останавливаем RageBot
                if rageBotConnection then
                    rageBotConnection:Disconnect()
                    rageBotConnection = nil
                end
                framework.stopShooting()
            end
        end
    })
    
    -- Режим таргетинга
    RageBotSection:Dropdown({
        Name = "Target Mode",
        Flag = "RageBotTargetMode",
        Items = {"Closest", "Cursor"},
        Default = "Closest",
        Callback = function(value)
            targetingMode = value
        end
    })
    
    -- Hit Parts мульти-выбор (R6 части)
    RageBotSection:Dropdown({
        Name = "Hit Parts",
        Flag = "RageBotHitParts",
        Items = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"},
        Default = {"Head"},
        Multi = true,
        Callback = function(values)
            -- Очищаем старые выборы
            selectedHitParts = {}
            -- Добавляем новые
            for _, partName in ipairs(values) do
                selectedHitParts[partName] = true
            end
        end
    })
    
    -- Секция Hitpart Override во второй колонне
    local HitpartOverrideSection = RagebotPage:Section({
        Name = "Hitpart Override",
        Side = 2
    })
    
    -- Объявляем переменную для кейбинда
    local _OverrideKeybind
    
    -- Override тоггл с кейбиндом
    local OverrideToggle = HitpartOverrideSection:Toggle({
        Name = "Enable Override",
        Flag = "HitpartOverride",
        Default = false,
        Callback = function(value)
            overrideEnabled = value
            -- Сбрасываем последнюю выбранную часть при переключении
            lastSelectedPart = nil
            partStabilityTimer = 0
            -- Обновляем состояние в KeybindList
            if _OverrideKeybind and _OverrideKeybind.KeybindListItem then
                _OverrideKeybind.KeybindListItem:SetStatus(value)
            end
        end
    })
    
    -- Кейбинд для переключения override
    _OverrideKeybind = OverrideToggle:Keybind({
        Name = "Override Key",
        Flag = "HitpartOverrideKey",
        Mode = "Toggle",
        Default = Enum.KeyCode.V,
        Callback = function(toggled)
            -- При нажатии кейбинда переключаем тоггл
            OverrideToggle:Set(toggled)
        end
    })
    
    -- Override Hit Parts мульти-выбор
    HitpartOverrideSection:Dropdown({
        Name = "Override Parts",
        Flag = "OverrideHitParts",
        Items = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"},
        Default = {"Head"},
        Multi = true,
        Callback = function(values)
            -- Очищаем старые выборы
            overrideHitParts = {}
            -- Добавляем новые
            for _, partName in ipairs(values) do
                overrideHitParts[partName] = true
            end
            -- Сбрасываем последнюю выбранную часть при изменении
            if overrideEnabled then
                lastSelectedPart = nil
                partStabilityTimer = 0
            end
        end
    })
    
    -- Show Aimbot тоггл с колорпикером
    local ShowAimbotToggle = RageBotSection:Toggle({
        Name = "Show Aimbot",
        Flag = "RageBotShowAimbot",
        Default = false,
        Callback = function(value)
            showAimbot = value
            
            if showAimbot then
                -- Создаем трейсер если его нет
                if not aimbotTracer then
                    aimbotTracer = framework.createTracer()
                end
                
                -- Показываем трейсер если есть текущая позиция
                if currentAimPosition then
                    framework.updateTracer(currentAimPosition)
                end
            else
                -- Скрываем трейсер
                if aimbotTracer then
                    aimbotTracer.Parent = nil
                end
            end
        end
    })
    
    -- Колорпикер для трейсера
    ShowAimbotToggle:Colorpicker({
        Name = "Tracer Color",
        Flag = "RageBotTracerColor",
        Default = Color3fromRGB(255, 0, 0),
        Alpha = 0.5,
        Callback = function(color, alpha)
            aimbotColor = color
            if aimbotTracer then
                aimbotTracer.Color = color
                aimbotTracer.Transparency = alpha
            end
        end
    })
end

local VisualsPage = Window:Page({
    Name = "Visuals",
    Columns = 2
})
local MiscPage = Window:Page({
    Name = "Misc",
    Columns = 2
})
local AntiAimPage = Window:Page({
    Name = "AntiAim",
    Columns = 2
})
-- HUD элементы (изолированы в блоке)
do
    local Watermark = Library:Watermark("Fentanyl | " .. LocalPlayer.Name .. " | " .. os.date("%y.%m.%d") .. " | Premium")
    local KeybindList = Library:KeybindList()
    
    -- Скрываем по умолчанию
    if Watermark then
        Watermark:SetVisibility(false)
    end
    if KeybindList then
        KeybindList:SetVisibility(false)
    end
    
    -- Делаем глобально доступными для тогглов
    _G.Watermark = Watermark
    _G.KeybindList = KeybindList
end


-- Settings вкладка (изолирована в блоке)
do
    local SettingsPage = Window:Page({
        Name = "Settings",
        Columns = 2
    })

    -- Config Manager Section
    local ConfigSection = SettingsPage:Section({
        Name = "Config",
        Side = 1
    })

    -- Переменные для конфиг менеджера
    local selectedConfig = ""  -- Выбранный из дропдауна
    local newConfigName = ""   -- Введенный в текстбокс
    local configList = {}

    -- Создание папок если их нет
    do
        if not isfolder("fentanyl") then
            makefolder("fentanyl")
        end
        if not isfolder("fentanyl/Configs") then
            makefolder("fentanyl/Configs")
        end
    end

    -- Функция для обновления списка конфигов
    local function updateConfigList()
        local configList = {}
        if isfolder("fentanyl/Configs") then
            for _, file in ipairs(listfiles("fentanyl/Configs")) do
                -- Нормализуем пути - заменяем \ на / и убираем директорию
                local name = file:gsub("\\", "/")
                name = name:gsub("fentanyl/Configs/", "")
                insert(configList, name)
            end
        end
        return configList
    end

    -- Листбокс для выбора конфигов
    local ConfigList = ConfigSection:Listbox({
        Name = "Select Config",
        Items = updateConfigList(),
        Default = "",
        Flag = "SelectedConfig",
        Callback = function(value)
            selectedConfig = value
            print("Selected config:", value)
        end
    })

    -- Текстбокс для имени нового конфига
    local ConfigNameBox = ConfigSection:Textbox({
        Name = "",
        Default = "",
        Placeholder = "Enter config name...",
        Flag = "ConfigName",
        Callback = function(value)
            newConfigName = value
        end
    })

    -- Кнопка создания конфига
    local CreateButton = ConfigSection:Button({
        Name = "Create Config",
        Callback = function()
            if newConfigName and newConfigName ~= "" then
                local configName = newConfigName:gsub("%.json$", "") .. ".json"
                local configPath = "fentanyl/Configs/" .. configName
                
                if not isfile(configPath) then
                    -- Получаем данные конфига и сохраняем
                    local configData = Library:GetConfig()
                    writefile(configPath, configData)
                    Library:Notification("Config created: " .. configName, 3, Color3fromRGB(0, 255, 0))
                    ConfigList:Refresh(updateConfigList())
                else
                    Library:Notification("Config already exists: " .. configName, 3, Color3fromRGB(255, 0, 0))
                end
            else
                Library:Notification("Please enter a config name", 3, Color3fromRGB(255, 255, 0))
            end
        end
    })

    -- Кнопка сохранения конфига
    local SaveButton = ConfigSection:Button({
        Name = "Save Config",
        Callback = function()
            local configName
            if selectedConfig and selectedConfig ~= "" then
                configName = selectedConfig
            elseif newConfigName and newConfigName ~= "" then
                configName = newConfigName:gsub("%.json$", "") .. ".json"
            end
            
            if configName then
                local configPath = "fentanyl/Configs/" .. configName
                local configData = Library:GetConfig()
                writefile(configPath, configData)
                Library:Notification("Config saved: " .. configName, 3, Color3fromRGB(0, 255, 0))
                ConfigList:Refresh(updateConfigList())
            else
                Library:Notification("Please select or enter a config name", 3, Color3fromRGB(255, 255, 0))
            end
        end
    })

    -- Кнопка загрузки конфига
    local LoadButton = ConfigSection:Button({
        Name = "Load Config",
        Callback = function()
            if selectedConfig and selectedConfig ~= "" then
                local configPath = "fentanyl/Configs/" .. selectedConfig
                
                if isfile(configPath) then
                    local configData = readfile(configPath)
                    Library:LoadConfig(configData)
                    Library:Notification("Config loaded: " .. selectedConfig, 3, Color3fromRGB(0, 255, 0))
                else
                    Library:Notification("Config not found: " .. selectedConfig, 3, Color3fromRGB(255, 0, 0))
                end
            else
                Library:Notification("Please select a config to load", 3, Color3fromRGB(255, 255, 0))
            end
        end
    })

    -- Кнопка удаления конфига
    local DeleteButton = ConfigSection:Button({
        Name = "Delete Config",
        Risky = true,
        Callback = function()
            if selectedConfig and selectedConfig ~= "" then
                local configPath = "fentanyl/Configs/" .. selectedConfig
                print("Trying to delete config at path:", configPath)
                print("File exists:", isfile(configPath))
                
                if isfile(configPath) then
                    delfile(configPath)
                    Library:Notification("Config deleted: " .. selectedConfig, 3, Color3fromRGB(0, 255, 0))
                    ConfigList:Refresh(updateConfigList())
                    selectedConfig = ""
                else
                    Library:Notification("Config not found at: " .. configPath, 5, Color3fromRGB(255, 0, 0))
                end
            else
                Library:Notification("Please select a config to delete", 3, Color3fromRGB(255, 255, 0))
            end
        end
    })

    -- Кнопка обновления списка конфигов
    local RefreshButton = ConfigSection:Button({
        Name = "Refresh Config List",
        Callback = function()
            ConfigList:Refresh(updateConfigList())
            Library:Notification("Config list refreshed", 2, Color3fromRGB(0, 255, 0))
        end
    })


    -- Theme Customization Section
    local ThemeSection = SettingsPage:Section({
        Name = "Theming",
        Side = 2
    })

    -- Accent Color Picker
    local AccentLabel = ThemeSection:Label("Accent Color", "Left")

    local _AccentColorPicker = AccentLabel:Colorpicker({
        Name = "Accent Color",
        Default = Color3fromRGB(31, 226, 130),
        Alpha = 1,
        Flag = "ThemeAccentColor",
        Callback = function(color, alpha)
            -- Обновляем акцентный цвет в теме
            Library:ChangeTheme("Accent", color)
            
            -- Обновляем градиент заголовка окна
            if Window.GradientTitle and Window.GradientTitle.Enabled then
                Window.GradientTitle.Start = color
                Window.GradientTitle.Middle = color
                Window.GradientTitle.End = color
            end
        end
    })

    -- Window Background Color Picker
    local WindowBgLabel = ThemeSection:Label("Window Background", "Left")
    local _WindowBgColorPicker = WindowBgLabel:Colorpicker({
        Name = "Window Background",
        Default = Color3fromRGB(43, 43, 43),
        Alpha = 1,
        Flag = "ThemeWindowBackground",
        Callback = function(color, alpha)
            Library:ChangeTheme("Window Background", color)
        end
    })

    -- Text Color Picker
    local TextLabel = ThemeSection:Label("Text Color", "Left")
    local _TextColorPicker = TextLabel:Colorpicker({
        Name = "Text Color",
        Default = Color3fromRGB(180, 180, 180),
        Alpha = 1,
        Flag = "ThemeTextColor",
        Callback = function(color, alpha)
            Library:ChangeTheme("Text", color)
        end
    })

    -- Section Background Color Picker
    local SectionBgLabel = ThemeSection:Label("Section Background", "Left")
    local _SectionBgColorPicker = SectionBgLabel:Colorpicker({
        Name = "Section Background",
        Default = Color3fromRGB(19, 19, 19),
        Alpha = 1,
        Flag = "ThemeSectionBackground",
        Callback = function(color, alpha)
            Library:ChangeTheme("Section Background", color)
        end
    })

    -- Element Color Picker
    local ElementLabel = ThemeSection:Label("Element Color", "Left")
    local _ElementColorPicker = ElementLabel:Colorpicker({
        Name = "Element Color",
        Default = Color3fromRGB(63, 63, 63),
        Alpha = 1,
        Flag = "ThemeElementColor",
        Callback = function(color, alpha)
            Library:ChangeTheme("Element", color)
        end
    })

    -- Border Color Picker
    local BorderLabel = ThemeSection:Label("Border Color", "Left")
    local _BorderColorPicker = BorderLabel:Colorpicker({
        Name = "Border Color",
        Default = Color3fromRGB(68, 68, 68),
        Alpha = 1,
        Flag = "ThemeBorderColor",
        Callback = function(color, alpha)
            Library:ChangeTheme("Border", color)
        end
    })

    -- Outline Color Picker
    local OutlineLabel = ThemeSection:Label("Outline Color", "Left")
    local _OutlineColorPicker = OutlineLabel:Colorpicker({
        Name = "Outline Color",
        Default = Color3fromRGB(0, 0, 0),
        Alpha = 1,
        Flag = "ThemeOutlineColor",
        Callback = function(color, alpha)
            Library:ChangeTheme("Outline", color)
        end
    })

    -- Dark Liner Color Picker
    local DarkLinerLabel = ThemeSection:Label("Dark Liner", "Left")
    local _DarkLinerColorPicker = DarkLinerLabel:Colorpicker({
        Name = "Dark Liner",
        Default = Color3fromRGB(56, 56, 56),
        Alpha = 1,
        Flag = "ThemeDarkLiner",
        Callback = function(color, alpha)
            Library:ChangeTheme("Dark Liner", color)
        end
    })

    -- Risky Color Picker
    local RiskyLabel = ThemeSection:Label("Risky Color", "Left")
    local _RiskyColorPicker = RiskyLabel:Colorpicker({
        Name = "Risky Color",
        Default = Color3fromRGB(255, 50, 50),
        Alpha = 1,
        Flag = "ThemeRiskyColor",
        Callback = function(color, alpha)
            Library:ChangeTheme("Risky", color)
        end
    })

    -- Inline Color Picker
    local InlineLabel = ThemeSection:Label("Inline Color", "Left")
    local _InlineColorPicker = InlineLabel:Colorpicker({
        Name = "Inline Color",
        Default = Color3fromRGB(12, 12, 12),
        Alpha = 1,
        Flag = "ThemeInlineColor",
        Callback = function(color, alpha)
            Library:ChangeTheme("Inline", color)
        end
    })

    -- HUD Section
    local HUDSection = SettingsPage:Section({
        Name = "HUD",
        Side = 2
    })

    -- Keybinds Toggle
    local _KeybindsToggle = HUDSection:Toggle({
        Name = "Keybinds",
        Default = false,
        Flag = "HUDKeybinds",
        Callback = function(value)
            if _G.KeybindList then
                _G.KeybindList:SetVisibility(value)
            end
        end
    })

    -- Watermark Toggle
    local _WatermarkToggle = HUDSection:Toggle({
        Name = "Watermark",
        Default = false,
        Flag = "HUDWatermark",
        Callback = function(value)
            if _G.Watermark then
                _G.Watermark:SetVisibility(value)
            end
        end
    })

    -- GUI Toggle Label с кейбиндом
    local GUIToggleLabel = HUDSection:Label("GUI", "Left")
    local _GUIKeybind = GUIToggleLabel:Keybind({
        Name = "Toggle GUI",
        Mode = "Toggle",
        Default = Enum.KeyCode.Insert,
        Flag = "GUIToggleKey",
        Callback = function(toggled)
            -- Переключаем видимость GUI используя встроенный метод библиотеки
            if Window and Window.SetOpen then
                Window:SetOpen(not Window.IsOpen)
            end
        end
    })
    
    -- Синхронизируем состояние кейбинда с состоянием GUI
    do
        local originalSetOpen = Window.SetOpen
        Window.SetOpen = function(self, state)
            originalSetOpen(self, state)
            -- Обновляем состояние кейбинда в соответствии с состоянием GUI
            if _GUIKeybind and _GUIKeybind.Toggled ~= self.IsOpen then
                _GUIKeybind.Toggled = self.IsOpen
                -- Обновляем отображение в KeybindList
                if _GUIKeybind.KeybindListItem then
                    _GUIKeybind.KeybindListItem:SetStatus(self.IsOpen)
                end
            end
        end
    end

    -- Server Section (изолирована в блоке)
    do
        local ServerSection = SettingsPage:Section({
            Name = "Server",
            Side = 2
        })

        -- Copy GameID Button
        local _CopyGameIDButton = ServerSection:Button({
            Name = "Copy GameID",
            Callback = function()
                setclipboard(tostring(game.GameId))
                Library:Notification("GameID copied to clipboard", 2, Color3fromRGB(0, 255, 0))
            end
        })

        -- Copy JobID Button
        local _CopyJobIDButton = ServerSection:Button({
            Name = "Copy JobID",
            Callback = function()
                setclipboard(game.JobId)
                Library:Notification("JobID copied to clipboard", 2, Color3fromRGB(0, 255, 0))
            end
        })

        -- Copy Join Script Button
        local _CopyJoinScriptButton = ServerSection:Button({
            Name = "Copy Join Script",
            Callback = function()
                local joinScript = 'game:GetService("TeleportService"):TeleportToPlaceInstance(' 
                    .. game.PlaceId 
                    .. ', "' 
                    .. game.JobId 
                    .. '", game.Players.LocalPlayer)'
                setclipboard(joinScript)
                Library:Notification("Join script copied to clipboard", 2, Color3fromRGB(0, 255, 0))
            end
        })

        -- Rejoin Game Button
        local _RejoinButton = ServerSection:Button({
            Name = "Rejoin Game",
            Callback = function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
            end
        })

        -- Join New Server Button
        local _JoinNewServerButton = ServerSection:Button({
            Name = "Join New Server",
            Callback = function()
                local success, apiRequest = pcall(function()
                    return HttpService:JSONDecode(
                        game:HttpGetAsync(
                            "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                        )
                    )
                end)
                
                if success and apiRequest and apiRequest.data and #apiRequest.data > 0 then
                    local data = apiRequest.data[random(1, #apiRequest.data)]
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, data.id)
                else
                    Library:Notification("Failed to get server list", 3, Color3fromRGB(255, 0, 0))
                end
            end
        })
    end -- конец Server секции
end -- конец Settings вкладки

-- Уведомление о загрузке скрипта
Library:Notification("Script loaded, press Insert to toggle GUI", 4, Color3fromRGB(0, 255, 0))
